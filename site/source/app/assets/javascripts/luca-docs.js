window.Luca = window.Luca || {}; window.Luca.documentation = [{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/application.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/application.coffee","type":"component_definition","starts_on_line":63,"class_name":"Luca.Application","header_documentation":"<p>The <code>Luca.Application</code> is the main entry point into your Application.\nIt acts as a global state machine, page controller, and router, in addition\nto providing access to other singletons such as the CollectionManager, and SocketManager.</p>\n\n<p>The structure of a common <code>Luca.Application</code> is that it contains one or many <code>Pages</code> which\nthemselves are made up of the components of your application.  One <code>Page</code> is visible at a time\nand which page is displayed is managed by an instance of the <code>Luca.components.Controller</code> class.</p>\n\n<h3>Example Configuration</h3>\n\n<pre><code>application = Luca.register     &quot;App.Application&quot;\napplication.extends             &quot;Luca.Application&quot;\napplication.defines\n  name: &quot;MyApplication&quot;\n  routes: \n    &quot;&quot; : &quot;home&quot;\n    &quot;standard/backbone/style/:route&quot; : &quot;name_of_page#name_of_method&quot;\n  components:[\n    name: &quot;home&quot;\n  ,\n    type: &quot;your_view&quot;\n    name: &quot;name_of_page&quot;\n    name_of_method: (routeParam)-&gt;\n      @doSomethignToSetupYourPageWithThePassed(routeParam)  \n  ]\n</code></pre>\n\n<p>App.onReady ()-&gt;\n    window.MyApp = new App.Application();\n    window.MyApp.boot() </p>\n\n<h4>@routes and pages</h4>\n\n<p>In the above example, our application contains two pages, one with the name &#39;home&#39;\nand one with the name &#39;name<em>of</em>page&#39;.  It also specifies a <code>@routes</code> property which\nis identical to the configuration you would see in a standard <code>Backbone.Router</code>.\nWhenever the route matches &#39;standard/backbone/style/route&#39; the <code>App.Application</code> instance\nwill send an instruction to the <code>Luca.components.Controller</code> to <code>activate</code> the page whose name\nis passed in the <code>@routes</code> config.</p>\n\n<p>If that page defines a method called <code>@routeHandler</code> it will be called with the parameters\nfrom the route.  In the <code>@routes</code> config you can specify your own route handler method\nby using the rails style <code>page_name#action</code> and it will call the <code>@action</code> method instead\non the view named <code>page_name</code>.\nThe <code>App.Application</code> instance, also accessible by <code>window.MyApp</code>, or through the helper <code>App()</code>\nor <code>Luca.getApplication()</code> maintains the state of which page is active.  You can access this\nin your code by calling <code>App().activePage()</code>.</p>\n\n<h4>Controllers</h4>\n\n<p>The <code>Luca.components.Controller</code> is a special type of component which contains \nother views, or <code>Pages</code> which only one will be visible at any given time.  It expects\nthat each page will have its own unique <code>@name</code> property.  A <code>Luca.components.Controller</code> can\ncontain other controllers, providing you with a way of structuring your application layout\nin an organized, hierarchal fashion. \nBy default, any <code>Luca.Application</code> will have one <code>Luca.components.Controller</code> automatically\ncreated named &#39;main_controller&#39; which is accessible by <code>MyApp.getMainController()</code>.  Any\ncomponents you define on the <code>Luca.Application</code> instance will be wrapped by the main controller\nautomatically unless you specify <code>@useController = false</code> in your Application component definition.</p>\n","type_alias":"application","css_class_identifier":"luca-application","defines_methods":{"initialize":{"defined_on_line":161,"documentation":"<p>Creating your Application and all of its components and pages is\ngenerally as simple as creating an instance of your Application class:\nLuca.onReady ()-&gt;\nwindow.MyApp = new Luca.Application()\nwindow.MyApp.boot()</p>\n","arguments":[{"argument":"@options","value":"{}"}]},"activeView":{"defined_on_line":231,"documentation":"<p>@activeView() returns a reference to the instance of the view\nwhich is currently monopolizing the viewport.  In an application\nwhich uses a controller hierarchy, it will be the last controller\nhas activated one of its pages.</p>\n","arguments":[]},"activeSection":{"defined_on_line":238,"documentation":"<p>Returns the name of the active component on the main controller</p>\n","arguments":[]},"activeSubSection":{"defined_on_line":244,"documentation":"<p>Returns the name of the active component on the nested controllers\non the main controller, if there is one.  These get set on the\nstate machine in response to card switch events on the controller component</p>\n","arguments":[]},"activePages":{"defined_on_line":247,"documentation":"","arguments":[]},"boot":{"defined_on_line":259,"documentation":"<p>boot should trigger the ready event, which will call the initial call\nto render() your application, which will have a cascading effect on every\nsubcomponent in the view, recursively rendering everything which is set\nto automatically render (i.e. any non-deferrable components ).</p>\n\n<p>you should use boot to fire up any dependent collections, manager, any\nsort of data processing, whatever your application requires to run outside\nof the views</p>\n","arguments":[]},"collection":{"defined_on_line":266,"documentation":"<p>delegate to the collection manager&#39;s get or create function.\nuse App.collection() to create or access existing collections</p>\n","arguments":[]},"get":{"defined_on_line":270,"documentation":"<p>Get an attribute from our internal state machine</p>\n","arguments":[{"argument":"attribute","value":null}]},"set":{"defined_on_line":274,"documentation":"<p>Set an attribute on our internal state machine</p>\n","arguments":[{"argument":"attribute","value":null},{"argument":"value","value":null},{"argument":"options","value":null}]},"view":{"defined_on_line":278,"documentation":"<p>Access a named view by its @name property.</p>\n","arguments":[{"argument":"name","value":null}]},"navigate_to":{"defined_on_line":286,"documentation":"<p>delegate to the main controller so that we can switch the active section\neasily directly from the application.  If passed a callback, this function\nwill get called in the context of the activated component.  This method is useful\ninside of custom route handlers if you are manually defining them on a <code>Backbone.Router</code>\ninstead of using the built in <code>@routes</code> helper.</p>\n","arguments":[{"argument":"component_name","value":null},{"argument":"callback","value":null}]},"setupControllerBindings":{"defined_on_line":294,"documentation":"<p>Any time the Application&#39;s main controller changes its active page\nwe track the name of that page ( aka section ) on our state machine.\nIf the active page on the main controller is another controller component,\nthen we will track that controller&#39;s active component as our active sub section.</p>\n","arguments":[]},"setupMainController":{"defined_on_line":317,"documentation":"<p>A typical structure for a Luca.Application is that it will act as a <code>Viewport</code> which\nmonopolizes the entire top level element in your dom ( either the body tag, or a top\nlevel element just underneath it)  This <code>Viewport</code> is an abstract element where we can\nsetup global event bindings, like keyBindings and such.  The <code>Viewport</code> will generally\ncontain a <code>Luca.components.Controller</code> instance called &quot;main_controller&quot; that is responsible\nfor displaying the active page for a given route.</p>\n","arguments":[]},"setupCollectionManager":{"defined_on_line":336,"documentation":"","arguments":[]},"setupSocketManager":{"defined_on_line":373,"documentation":"<p>If our application is configured with a <code>@socketManagerOptions</code> property,\nit will create a socket manager instance for us automatically.  It won&#39;t\nstart the socket manager process until the <code>@boot()</code> method is called on the application.</p>\n","arguments":[]},"setupRouter":{"defined_on_line":382,"documentation":"<p>Sets up an instance of the Backbone.Router, and sets up the\ncall to start the history tracking API once the appropriate\napplication events have been fired.</p>\n","arguments":[]},"setupKeyHandler":{"defined_on_line":415,"documentation":"<p>The default implementation of setupKeyHandler is kept around for backward\ncompatibility purposes.  In Luca 1.0 we will be using keymaster.js for our\nkey binding setup.</p>\n","arguments":[]},"pageHierarchy":{"defined_on_line":434,"documentation":"<p>An application inspection helper, it describes the structure of this application&#39;s\ncontrolled components.  For an application that consists of multiple nested controllers\nit will recursively walk each controller and build a tree of the various pages / controlers.</p>\n","arguments":[]},"registerInstance":{"defined_on_line":453,"documentation":"<p>Registers this instance of the Luca.Appliction\nso that it is available via the Luca() helper, or through\na call to Luca.Application.get().</p>\n","arguments":[{"argument":"app","value":null}]},"checkForKeymaster":{"defined_on_line":459,"documentation":"<p>If the keymaster library is present, swap out the\nsetupKeyHandler method with something which will enable\nkeymaster support instead of our legacy system.</p>\n","arguments":[]},"routeTo":{"defined_on_line":473,"documentation":"<p>This is used internally by the Application as it sets up\nthe @routes property and uses it to configure the Luca.Router\ninstance for your app.  It allows you to specify the page you want\nto monopolize the viewport in your application by name, and regardless\nof how deeply nested that page may be among your controllers, it will know\nwhat to do.</p>\n","arguments":[{"argument":"pages...","value":null}]},"startHistory":{"defined_on_line":520,"documentation":"<p>Public: you can override Luca.Application.startHistory to\nmodify how Backbone.history.start is called.  This will get called\nby the Application instance in response to the @autoStartHistory property.</p>\n","arguments":[]}},"defines_properties":{"name":{"defined_on_line":70,"documentation":"","default":"\"MyApp\""},"stateful":{"defined_on_line":77,"documentation":"<p>The Application uses a Backbone.Model as a state machine, which\nallows you to get / set attributes, persist them somewhere, and\nmost importantly to bind to change events of certain attributes.</p>\n\n<p>the @defaultState property will be the default attributes</p>\n","default":"{}"},"autoBoot":{"defined_on_line":81,"documentation":"<p>if autoBoot is set to true, the application will\nattempt to boot on document ready.</p>\n","default":"false"},"autoStartHistory":{"defined_on_line":87,"documentation":"<p>automatically starts the @router if it exists,\nonce the components for the application have\nbeen created.  Pass the event name you want to\nlisten for on this component before you start history</p>\n","default":"\"before"},"pushState":{"defined_on_line":90,"documentation":"<p>use Backbone.history push state?</p>\n","default":"false"},"startHistorySilently":{"defined_on_line":94,"documentation":"<p>If the server renders the entire page\nfirst, then we should start history silently.</p>\n","default":"false"},"rootUrl":{"defined_on_line":99,"documentation":"<p>In cases where we use pushState, we need to tell\nthe application what the actual root url of our app\nis, since everything after would otherwise be a hashbang</p>\n","default":"undefined"},"useCollectionManager":{"defined_on_line":103,"documentation":"<p>we will create a collection manager singleton\nby default unless otherwise specified.</p>\n","default":"true"},"collectionManager":{"defined_on_line":107,"documentation":"<p>to pass options to the collection manager, set the @collectionManager\nhash which will get passed once the collection manager is created</p>\n","default":"{}"},"collectionManagerClass":{"defined_on_line":112,"documentation":"<p>by default we will use the standard collection manager which ships with\nLuca.  If you would like to use your own extension of the collection manager\njust pass a reference to the class you would like to use.</p>\n","default":"\"Luca.CollectionManager\""},"plugin":{"defined_on_line":117,"documentation":"<p>Luca plugin apps are apps which mount onto existing\nluca apps, and will not have the behavior of a main\napp which acts as a singleton</p>\n","default":"false"},"useController":{"defined_on_line":123,"documentation":"<p>by default, the application will use a controller\ncomponent, which is a card view container which shows\none view at a time.  this is useful for having an application\nwith several &#39;pages&#39; so to speak</p>\n","default":"true"},"mainControllerContainer":{"defined_on_line":128,"documentation":"<p>If your Application does not behave as a Viewport that monopolizes\nits entire element, but instead you wish to render the application\ncontroller to a specific element,  you can specify the css selector of that element.</p>\n","default":"undefined"},"keyEvents":{"defined_on_line":145,"documentation":"<p>keyEvents understands the following modifiers:\n- <code>\u21e7</code>, <code>shift</code>, <code>option</code>, <code>\u2325</code>, <code>alt</code>, <code>ctrl</code>, <code>control</code>, <code>command</code>, and <code>\u2318</code>.\nThe following special keys can be used for shortcuts:\n<code>backspace</code>, <code>tab</code>, <code>clear</code>, <code>enter</code>, <code>return</code>, <code>esc</code>, <code>escape</code>, <code>space</code>,\n<code>up</code>, <code>down</code>, <code>left</code>, <code>right</code>, <code>home</code>, <code>end</code>, <code>pageup</code>, <code>pagedown</code>, <code>del</code>, <code>delete</code>\nand <code>f1</code> through <code>f19</code>.</p>\n\n<p><strong>Note</strong>: This requires the keymaster.js library to be loaded.  This library is included\nwith the bundled dependencies that ship with Luca.</p>\n\n<p>Example:\napplication.configuration\nkeyEvents:\n&#39;\u2318+r, ctrl+r&#39;: &quot;keyHandlerFunction&quot;\nkeyHandlerFunction: -&gt; alert &#39;something + r was pressed&#39;</p>\n","default":"{}"},"createRoleBasedGetters":{"defined_on_line":148,"documentation":"<p>create getter methods for the various roles in the application&#39;s components on the application itself.</p>\n","default":"false"},"useSocketManager":{"defined_on_line":152,"documentation":"<p>create an instance of Luca.SocketManager which is a Backbone.Events style abstraction that\nsits on top of services like faye, or socket.io</p>\n","default":"false"},"socketManagerOptions":{"defined_on_line":153,"documentation":"","default":"{}"},"instances":{"defined_on_line":429,"documentation":"","default":"{}"}},"source_file_contents":"# The `Luca.Application` is the main entry point into your Application.\n# It acts as a global state machine, page controller, and router, in addition\n# to providing access to other singletons such as the CollectionManager, and SocketManager.\n# \n# The structure of a common `Luca.Application` is that it contains one or many `Pages` which\n# themselves are made up of the components of your application.  One `Page` is visible at a time\n# and which page is displayed is managed by an instance of the `Luca.components.Controller` class.\n#\n# ### Example Configuration  \n#     application = Luca.register     \"App.Application\"\n#     application.extends             \"Luca.Application\"\n#\n#     application.defines\n#       name: \"MyApplication\"\n#       routes: \n#         \"\" : \"home\"\n#         \"standard/backbone/style/:route\" : \"name_of_page#name_of_method\"\n#\n#       components:[\n#         name: \"home\"\n#       ,\n#         type: \"your_view\"\n#         name: \"name_of_page\"\n#         name_of_method: (routeParam)->\n#           @doSomethignToSetupYourPageWithThePassed(routeParam)  \n#       ]\n#\n#   App.onReady ()->\n#     window.MyApp = new App.Application();\n#     window.MyApp.boot() \n#\n# #### @routes and pages\n#\n# In the above example, our application contains two pages, one with the name 'home'\n# and one with the name 'name_of_page'.  It also specifies a `@routes` property which\n# is identical to the configuration you would see in a standard `Backbone.Router`.\n#\n# Whenever the route matches 'standard/backbone/style/route' the `App.Application` instance\n# will send an instruction to the `Luca.components.Controller` to `activate` the page whose name\n# is passed in the `@routes` config.\n# \n# If that page defines a method called `@routeHandler` it will be called with the parameters\n# from the route.  In the `@routes` config you can specify your own route handler method\n# by using the rails style `page_name#action` and it will call the `@action` method instead\n# on the view named `page_name`.\n#\n# The `App.Application` instance, also accessible by `window.MyApp`, or through the helper `App()`\n# or `Luca.getApplication()` maintains the state of which page is active.  You can access this\n# in your code by calling `App().activePage()`.\n#\n# #### Controllers\n# \n# The `Luca.components.Controller` is a special type of component which contains \n# other views, or `Pages` which only one will be visible at any given time.  It expects\n# that each page will have its own unique `@name` property.  A `Luca.components.Controller` can\n# contain other controllers, providing you with a way of structuring your application layout\n# in an organized, hierarchal fashion. \n#\n# By default, any `Luca.Application` will have one `Luca.components.Controller` automatically\n# created named 'main_controller' which is accessible by `MyApp.getMainController()`.  Any\n# components you define on the `Luca.Application` instance will be wrapped by the main controller\n# automatically unless you specify `@useController = false` in your Application component definition.\napplication = Luca.register       \"Luca.Application\"\napplication.extends               \"Luca.containers.Viewport\"\n\napplication.triggers              \"controller:change\",\n                                  \"action:change\"\n\napplication.publicConfiguration\n  name: \"MyApp\"\n\n  # The Application uses a Backbone.Model as a state machine, which\n  # allows you to get / set attributes, persist them somewhere, and\n  # most importantly to bind to change events of certain attributes.\n  #\n  # the @defaultState property will be the default attributes\n  stateful: {}\n\n  # if autoBoot is set to true, the application will\n  # attempt to boot on document ready.\n  autoBoot: false\n\n  # automatically starts the @router if it exists,\n  # once the components for the application have\n  # been created.  Pass the event name you want to\n  # listen for on this component before you start history\n  autoStartHistory: \"before:render\"\n\n  # use Backbone.history push state?\n  pushState: false\n\n  # If the server renders the entire page\n  # first, then we should start history silently.\n  startHistorySilently: false\n\n  # In cases where we use pushState, we need to tell\n  # the application what the actual root url of our app\n  # is, since everything after would otherwise be a hashbang \n  rootUrl: undefined\n  \n  # we will create a collection manager singleton\n  # by default unless otherwise specified.\n  useCollectionManager: true\n\n  # to pass options to the collection manager, set the @collectionManager\n  # hash which will get passed once the collection manager is created\n  collectionManager: {}\n\n  # by default we will use the standard collection manager which ships with\n  # Luca.  If you would like to use your own extension of the collection manager\n  # just pass a reference to the class you would like to use.\n  collectionManagerClass: \"Luca.CollectionManager\"\n\n  # Luca plugin apps are apps which mount onto existing\n  # luca apps, and will not have the behavior of a main\n  # app which acts as a singleton\n  plugin: false\n\n  # by default, the application will use a controller\n  # component, which is a card view container which shows\n  # one view at a time.  this is useful for having an application\n  # with several 'pages' so to speak\n  useController: true\n\n  # If your Application does not behave as a Viewport that monopolizes\n  # its entire element, but instead you wish to render the application\n  # controller to a specific element,  you can specify the css selector of that element.\n  mainControllerContainer: undefined\n\n  # keyEvents understands the following modifiers:\n  # - `\u21e7`, `shift`, `option`, `\u2325`, `alt`, `ctrl`, `control`, `command`, and `\u2318`.\n  # The following special keys can be used for shortcuts:\n  # `backspace`, `tab`, `clear`, `enter`, `return`, `esc`, `escape`, `space`,\n  # `up`, `down`, `left`, `right`, `home`, `end`, `pageup`, `pagedown`, `del`, `delete`\n  # and `f1` through `f19`.\n  #\n  # **Note**: This requires the keymaster.js library to be loaded.  This library is included\n  # with the bundled dependencies that ship with Luca.\n  #\n  # Example:\n  #       application.configuration\n  #         keyEvents:\n  #           '\u2318+r, ctrl+r': \"keyHandlerFunction\"\n  #         keyHandlerFunction: -> alert 'something + r was pressed'\n  keyEvents: {}\n\n  # create getter methods for the various roles in the application's components on the application itself.\n  createRoleBasedGetters: false\n\n  # create an instance of Luca.SocketManager which is a Backbone.Events style abstraction that\n  # sits on top of services like faye, or socket.io \n  useSocketManager: false\n  socketManagerOptions: {}\n\napplication.publicMethods\n  # Creating your Application and all of its components and pages is \n  # generally as simple as creating an instance of your Application class:\n  #       Luca.onReady ()->\n  #         window.MyApp = new Luca.Application() \n  #         window.MyApp.boot()\n  initialize: (@options={})->\n    app             = @\n    appName         = @name\n    alreadyRunning  = Luca.getApplication?()\n\n    Luca.Application.registerInstance(@)\n\n    Luca.concerns.StateModel.__initializer.call(@)\n\n    # The Collection Manager is responsible for managing instances \n    # of collections, usually to guarantee only a single collection is\n    # instantiated for a given resource, to maintain 'authoritative' \n    # representations of models.\n    @setupCollectionManager()\n\n    # Socket Manager provides a bridge between remote pub/sub providers and \n    # the backbone.events interface on various components in the system.\n    @setupSocketManager()\n\n    Luca.containers.Viewport::initialize.apply @, arguments\n\n    # The Controller is the piece of the application that handles showing\n    # and hiding 'pages' of the app.  The Application has a navigate_to\n    # method which delegates to the controller, and allows you to navigate\n    # to a given page, or component, by its name.  The controller integrates\n    # with the state machine of the application\n    @setupMainController() if @useController is true \n\n    # we will render when all of the various components\n    # which handle our data dependencies determine that\n    # we are ready\n    @defer(()-> app.render()).until(@, \"ready\")\n\n    # Set up the Backbone Router\n    @setupRouter()\n\n    # the keyHandler allows us to specify\n    # keyEvents on our application with an API very similar\n    # to the DOM events API for Backbone.View\n    #\n    # Example:\n    #\n    # keyEvents:\n    #   meta:\n    #     forwardslash: \"altSlashHandler\"\n    if (@useKeyHandler is true or @useKeyRouter is true) and @keyEvents?\n      @setupKeyHandler() \n\n    # if the application is a plugin designed to modify the behavior\n    # of another app, then don't claim ownership.  otherwise the most common\n    # use-case is that there will be one application instance\n    unless @plugin is true or alreadyRunning\n      Luca.getApplication = (name)=>\n        return app unless name?\n        Luca.Application.instances[ name ]\n\n    if @autoBoot\n      if Luca.util.resolve(@name)\n        throw \"Attempting to override window.#{ @name } when it already exists\"\n\n      $ ->\n        window[ appName ] = app\n        app.boot()\n\n    Luca.trigger \"application:available\", @\n\n  # @activeView() returns a reference to the instance of the view\n  # which is currently monopolizing the viewport.  In an application\n  # which uses a controller hierarchy, it will be the last controller\n  # has activated one of its pages.\n  activeView: ()->\n    if active = @activeSubSection()\n      @view( active )\n    else\n      @view( @activeSection() )\n\n  # Returns the name of the active component on the main controller\n  activeSection: ()->\n    @get(\"active_section\")\n\n  # Returns the name of the active component on the nested controllers\n  # on the main controller, if there is one.  These get set on the\n  # state machine in response to card switch events on the controller component\n  activeSubSection: ()->\n    @get(\"active_sub_section\")\n\n  activePages: ()->\n    console.log \"This method will be getting removed in Luca 1.0\"\n    @$('.luca-controller').map (index,element)=> $(element).data('active-section')\n\n  # boot should trigger the ready event, which will call the initial call\n  # to render() your application, which will have a cascading effect on every\n  # subcomponent in the view, recursively rendering everything which is set\n  # to automatically render (i.e. any non-deferrable components ).\n  #\n  # you should use boot to fire up any dependent collections, manager, any\n  # sort of data processing, whatever your application requires to run outside\n  # of the views\n  boot: ()->\n    @trigger \"ready\"\n    for service in [@collectionManager, @socket, @router]\n      service?.trigger(\"ready\")\n\n  # delegate to the collection manager's get or create function.\n  # use App.collection() to create or access existing collections\n  collection: ()->\n    @collectionManager.getOrCreate.apply(@collectionManager, arguments)\n\n  # Get an attribute from our internal state machine\n  get: (attribute)->\n    @state.get(attribute)\n\n  # Set an attribute on our internal state machine\n  set: (attribute, value, options)->\n    @state.set.apply(@state, arguments)\n\n  # Access a named view by its @name property. \n  view: (name)->\n    Luca.cache(name)\n\n  # delegate to the main controller so that we can switch the active section\n  # easily directly from the application.  If passed a callback, this function\n  # will get called in the context of the activated component.  This method is useful\n  # inside of custom route handlers if you are manually defining them on a `Backbone.Router`\n  # instead of using the built in `@routes` helper.\n  navigate_to: (component_name, callback)->\n    @getMainController().navigate_to(component_name, callback)\n\napplication.privateMethods\n  # Any time the Application's main controller changes its active page\n  # we track the name of that page ( aka section ) on our state machine.\n  # If the active page on the main controller is another controller component,\n  # then we will track that controller's active component as our active sub section.\n  setupControllerBindings: ()->\n    app = @\n    # any time the main controller card switches we should track\n    # the active card on the global state chart\n    @getMainController()?.bind \"after:card:switch\", (previous,current)=>\n      @state.set(active_section:current.name)\n      app.trigger \"controller:change\", previous.name, current.name\n\n    # any time the card switches on one of the sub controllers\n    # then we should track the active sub section on the global state chart\n    @getMainController()?.each (component)=>\n      type = component.type || component.ctype\n      if type.match(/controller$/)\n        component.bind \"after:card:switch\", (previous,current)=>\n          @state.set(active_sub_section:current.name)\n          app.trigger \"action:change\", previous.name, current.name\n\n  # A typical structure for a Luca.Application is that it will act as a `Viewport` which\n  # monopolizes the entire top level element in your dom ( either the body tag, or a top \n  # level element just underneath it)  This `Viewport` is an abstract element where we can\n  # setup global event bindings, like keyBindings and such.  The `Viewport` will generally\n  # contain a `Luca.components.Controller` instance called \"main_controller\" that is responsible\n  # for displaying the active page for a given route. \n  setupMainController: ()->\n    if @useController is true\n      definedComponents = @components || []\n      base =  \n        type: 'controller'\n        name: \"main_controller\"\n        role: \"main_controller\"\n        components: definedComponents\n\n      if @mainControllerContainer?\n        _.extend(base, container: @mainControllerContainer)\n\n      @components = [base]\n    \n    @getMainController = ()=> \n      @findComponentByRole('main_controller')\n\n    @defer( @setupControllerBindings, false ).until(\"after:components\")\n\n  setupCollectionManager: ()->\n    return unless @useCollectionManager is true\n\n    return if @collectionManager? and @collectionManager?.get?\n\n    if _.isString( @collectionManagerClass )\n      @collectionManagerClass = Luca.util.resolve( @collectionManagerClass )\n\n    collectionManagerOptions = @collectionManagerOptions || {}\n\n    # if the collectionManager property is present, and it\n    # isn't a reference to a collection manager instance, then\n    # it is being used as a configuration hash for when we do create\n    # the collection manager. so let's stash it.\n    if _.isObject(@collectionManager) and not _.isFunction( @collectionManager?.get )\n      collectionManagerOptions = @collectionManager\n      @collectionManager = undefined\n\n    # if the collection manager property is a string, then it is a\n    # reference to a name of a collection manager to use.  so let's\n    # stash it\n    if _.isString(@collectionManager)\n      collectionManagerOptions =\n        name: @collectionManager\n\n\n    # let's try and get the collection manager by name if we can\n    @collectionManager = Luca.CollectionManager.get?( collectionManagerOptions.name )\n\n    # if we can't, then we will have to create one ourselves\n    unless _.isFunction(@collectionManager?.get)\n      collectionManagerOptions.autoStart = false\n      @collectionManager = new @collectionManagerClass( collectionManagerOptions )\n\n  # If our application is configured with a `@socketManagerOptions` property,\n  # it will create a socket manager instance for us automatically.  It won't\n  # start the socket manager process until the `@boot()` method is called on the application. \n  setupSocketManager: ()->\n    return if _.isEmpty(@socketManagerOptions)\n    _.extend(@socketManagerOptions, autoStart: false)\n\n    @socket = new Luca.SocketManager(@socketManagerOptions) \n \n  # Sets up an instance of the Backbone.Router, and sets up the\n  # call to start the history tracking API once the appropriate\n  # application events have been fired. \n  setupRouter: ()->\n    return if not @router? and not @routes?\n\n    routerClass = Luca.Router\n    routerClass = Luca.util.resolve(@router) if _.isString(@router)\n\n    routerConfig = routerClass.prototype\n    routerConfig.routes ||= {}\n    routerConfig.app = @\n\n    if _.isObject( @routes )\n      for routePattern, endpoint of @routes\n        if endpoint.match(/\\ /)\n          [page, action] = endpoint.split(' ')\n        else if endpoint.match(/\\#/)\n          [page, action] = endpoint.split('#')\n\n        fn = _.uniqueId(page)\n        routerConfig[fn] = Luca.Application.routeTo(page).action(action)\n        routerConfig.routes[ routePattern ] = fn\n\n    @router = new routerClass(routerConfig) \n\n    # if this application has a router associated with it\n    # then we need to start backbone history on a certain event.\n    # you can control which by setting the @startHistoryOn property\n    if @router and @autoStartHistory\n      @autoStartHistory = \"before:render\" if @autoStartHistory is true\n      @defer( Luca.Application.startHistory, false).until(@, @autoStartHistory)\n\n  # The default implementation of setupKeyHandler is kept around for backward\n  # compatibility purposes.  In Luca 1.0 we will be using keymaster.js for our\n  # key binding setup. \n  setupKeyHandler: ()->\n    return unless @keyEvents\n\n    @keyEvents.control_meta ||= {}\n\n    # allow for both meta_control, control_meta for the combo\n    _.extend(@keyEvents.control_meta, @keyEvents.meta_control) if @keyEvents.meta_control\n\n    handler = _.bind(@keyHandler, @)\n\n    for keyEvent in (@keypressEvents || [\"keydown\"])\n      $( document ).on( keyEvent, handler )\n\napplication.classMethods\n  instances:{}\n\n  # An application inspection helper, it describes the structure of this application's\n  # controlled components.  For an application that consists of multiple nested controllers\n  # it will recursively walk each controller and build a tree of the various pages / controlers.\n  pageHierarchy: ()->\n    app             = Luca()\n    mainController  = app.getMainController()\n\n    getTree = (node)->  \n      return {} unless node.components? or node.pages?\n\n      # recursively walks the pages on a controller\n      _( node.components || node.pages ).reduce (memo, page)->\n        memo[ page.name ] = page.name\n        memo[ page.name ] = getTree(page) if page.navigate_to?\n        memo\n      , {}\n\n    getTree( mainController )\n\n  # Registers this instance of the Luca.Appliction\n  # so that it is available via the Luca() helper, or through\n  # a call to Luca.Application.get().\n  registerInstance: (app)->\n    Luca.Application.instances[ app.name ] = app\n\n  # If the keymaster library is present, swap out the \n  # setupKeyHandler method with something which will enable \n  # keymaster support instead of our legacy system.\n  checkForKeymaster: ()->\n    if window?.key?.noConflict\n      Luca.key = window.key.noConflict()\n\n      Luca.Application::setupKeyHandler = ()->\n        return unless @keyEvents\n        Luca.util.setupKeymaster(@keyEvents, \"all\").on(@)\n\n  # This is used internally by the Application as it sets up\n  # the @routes property and uses it to configure the Luca.Router\n  # instance for your app.  It allows you to specify the page you want\n  # to monopolize the viewport in your application by name, and regardless\n  # of how deeply nested that page may be among your controllers, it will know \n  # what to do.  \n  routeTo: (pages...)->\n    last = _( pages ).last()\n    first = _( pages ).first()\n\n    callback = undefined    \n    specifiedAction = undefined\n\n    routeHelper = (args...)->\n      path = @app || Luca()\n      index = 0\n\n      # we can specify a page by name, and not have to know its full path.\n      if pages.length is 1 and target = Luca(first)\n        pages = target.controllerPath()\n\n      # when we do know the full path\n      for page in pages when _.isString(page)\n        nextItem = pages[++index]\n        target = Luca(page)\n\n        if page is last \n          if specifiedAction? and not target[specifiedAction]? and not target.routeHandler?\n            console.log \"You specified a component action to call when a route matches, but it does not exist on the component\"\n\n          callback = if specifiedAction? and target[ specifiedAction ]?\n            _.bind(target[ specifiedAction ], target)\n          else if target.routeHandler?\n            target.routeHandler  \n\n        callback ||= if _.isFunction(nextItem)\n          _.bind(nextItem, target)\n        else if _.isObject(nextItem) \n          if action = nextItem.action and target[action]?\n            _.bind(target[action], target)\n\n        path = path.navigate_to page, ()->\n          callback?.apply(target, args)\n\n    routeHelper.action = (action)->\n      specifiedAction = action\n      routeHelper\n\n    routeHelper\n\n  # Public: you can override Luca.Application.startHistory to \n  # modify how Backbone.history.start is called.  This will get called\n  # by the Application instance in response to the @autoStartHistory property.\n  startHistory: ()->\n    Backbone.history.start\n      pushState: @pushState\n      rootUrl: @rootUrl\n      silent: @startHistorySilently\n\napplication.afterDefinition ()->\n  Luca.routeHelper = Luca.Application.routeTo\n  Luca.Application.checkForKeymaster()\n\napplication.register()"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/collection_loader_view.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/collection_loader_view.coffee","type":"component_definition","starts_on_line":6,"class_name":"Luca.components.CollectionLoaderView","header_documentation":"<p>Collection Loader View is a simple modal view\nYou can provide your own template for the collection loader modal\nif you want to. Default implementation uses twitter bootstrap modal and\nprogress bar (<a href=\"http://twitter.github.com/bootstrap/\">http://twitter.github.com/bootstrap/</a>). You template\nshould contain <code>progress</code>, <code>bar</code> and <code>message</code> classes</p>\n","type_alias":"collection_loader_view","css_class_identifier":"luca-collection-loader-view","defines_methods":{"initialize":{"defined_on_line":14,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"modalContainer":{"defined_on_line":22,"documentation":"","arguments":[]},"setupBindings":{"defined_on_line":25,"documentation":"","arguments":[]}},"defines_properties":{"className":{"defined_on_line":10,"documentation":"","default":"'luca-ui-collection-loader-view'"},"template":{"defined_on_line":12,"documentation":"","default":"\"components/collection_loader_view\""}},"source_file_contents":"# Collection Loader View is a simple modal view\n# You can provide your own template for the collection loader modal\n# if you want to. Default implementation uses twitter bootstrap modal and\n# progress bar (http://twitter.github.com/bootstrap/). You template\n# should contain `progress`, `bar` and `message` classes\nloaderView = Luca.register        \"Luca.components.CollectionLoaderView\"\nloaderView.extends                \"Luca.View\"\n\nloaderView.defines\n  className: 'luca-ui-collection-loader-view'\n\n  template: \"components/collection_loader_view\"\n\n  initialize: (@options={})->\n    Luca.components.Template::initialize.apply @,arguments\n\n    @container ||= $('body')\n    @manager   ||= Luca.CollectionManager.get()\n\n    @setupBindings()\n\n  modalContainer: ()->\n    $(\"#progress-modal\", @el)\n\n  setupBindings: ()->\n    @manager.bind \"collection_loaded\", (name)=>\n      loaded   = @manager.loadedCollectionsCount()\n      total    = @manager.totalCollectionsCount()\n      progress = parseInt((loaded / total) * 100)\n      collectionName = _.string.titleize( _.string.humanize( name ) )\n\n      @modalContainer().find('.progress .bar').attr(\"style\", \"width: #{progress}%;\")\n      @modalContainer().find('.message').html(\"Loaded #{ collectionName }...\")\n\n    @manager.bind \"all_collections_loaded\", ()=>\n      @modalContainer().find('.message').html(\"All done!\")\n      _.delay ()=>\n        @modalContainer().modal('hide')\n      , 400"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/collection_view.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/collection_view.coffee","type":"component_definition","starts_on_line":43,"class_name":"Luca.CollectionView","header_documentation":"<p>The <code>Luca.CollectionView</code> renders models from a <code>Luca.Collection</code> into multiple\nelements, and provides methods for filtering, paginating, sorting the underlying\ncollection and re-rendering the contents of its <code>@el</code> accordingly.</p>\n\n<h4>Basic Example</h4>\n\n<pre><code>collectionView = Luca.register  &quot;App.views.Books&quot;\ncollectionView.extends          &quot;Luca.CollectionView&quot;\ncollectionView.defines\n  itemProperty: &quot;author&quot;\n  collection: new Luca.Collection([\n    author: &quot;George Orwell&quot;\n    title:  &quot;Animal Farm&quot;\n  ,\n    author: &quot;Noam Chomsky&quot;\n    title: &quot;Manufacturing Consent&quot;\n  ])\nview = new App.views.Books()\n</code></pre>\n\n<h4>Extending it to make it Filterable and Paginatable</h4>\n\n<pre><code>filterable = Luca.register    &quot;App.views.FilterableBooks&quot;\nfilterable.extends            &quot;App.views.Books&quot;\nfilterable.defines\n  collection: &quot;books&quot; \n  paginatable: 12\n  filterable:\n    query:\n      author: &quot;George Orwell&quot;\n\n view = new App.views.FilterableBooks()\n</code></pre>\n\n<h4>Filterable Collections</h4>\n\n<p>The <code>Luca.CollectionView</code> will attempt to perform a local query against its\ncollection which behaves like a <code>Backbone.QueryCollection</code>.  It will do this\nby default without making a remote request to the API.  </p>\n\n<p>If you do not want this behavior, you can configure the <code>Luca.CollectionView</code> to \nbehave as if the filtering was happen remotely in your REST API.<br>\n      filterable:\n        options:\n          remote: true</p>\n","type_alias":"collection_view","css_class_identifier":"luca-collection-view","defines_methods":{"initialize":{"defined_on_line":96,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"locateItemElement":{"defined_on_line":135,"documentation":"<p>Given the id of a model, find the underlying DOM element which was rendered by this collection.\nAssumes that the data-model-id attribute is set, which it is by default by @attributesForItem.</p>\n","arguments":[{"argument":"id","value":null}]},"refresh":{"defined_on_line":142,"documentation":"<p>Refresh is responsible for applying any filtering, pagination, or sorting options that may be set\nfrom the various Luca.concerns mixed in by <code>Luca.CollectionView</code> and making a query to the underlying\ncollection.  It will then take the set of models returned by <code>@getModels</code> and pass them through the\nitem rendering pipeline.</p>\n","arguments":[]},"renderModels":{"defined_on_line":162,"documentation":"","arguments":[{"argument":"models","value":null},{"argument":"query","value":null},{"argument":"options","value":null}]},"attributesForItem":{"defined_on_line":168,"documentation":"<p>Determines which attributes should be set on the item DOM element.</p>\n","arguments":[{"argument":"item","value":null},{"argument":"model","value":null}]},"contentForItem":{"defined_on_line":173,"documentation":"<p>Determines the content for the item DOM element.  Will use the appropriate options\nspecified by <code>@itemTemplate</code>, <code>@itemRenderer</code>, or <code>@itemProperty</code></p>\n","arguments":[{"argument":"item","value":"{}"}]},"makeItem":{"defined_on_line":186,"documentation":"<p>Uses the various options passed to the <code>CollectionView</code> to assemble a call to <code>Luca.View::make</code>.</p>\n","arguments":[{"argument":"model","value":null},{"argument":"index","value":null}]},"refreshModel":{"defined_on_line":197,"documentation":"<p>Given a model, attempt to re-render the contents of its item in this view&#39;s DOM contents.</p>\n","arguments":[{"argument":"model","value":null}]},"registerEvent":{"defined_on_line":203,"documentation":"","arguments":[{"argument":"domEvent","value":null},{"argument":"selector","value":null},{"argument":"handler","value":null}]}},"defines_properties":{"collection":{"defined_on_line":64,"documentation":"<p>Specify which collection will be used to supply the models to be rendered.\nAccepts either a string alias for the Collection class, or an instance of\nany class which inherits from Backbone.Collection</p>\n","default":"undefined"},"tagName":{"defined_on_line":67,"documentation":"<p>By default the CollectionView will be rendered inside of an OL tag.</p>\n","default":"\"ol\""},"bodyClassName":{"defined_on_line":72,"documentation":"<p>The CollectionView behaves as a Luca.Panel which means it has an area for\ntop and bottom toolbars.  The actual content that gets rendered from the\ncollection will be rendered inside an element with the specified class.</p>\n","default":"\"collection-ui-panel\""},"itemTagName":{"defined_on_line":75,"documentation":"<p>Each item from the collection will be rendered inside of an element specified by @itemTagName</p>\n","default":"'li'"},"itemClassName":{"defined_on_line":78,"documentation":"<p>Each item element will be assigned a CSS class specified by @itemClassName</p>\n","default":"'collection-item'"},"itemTemplate":{"defined_on_line":83,"documentation":"<p>Specify which template should be used to render each item in the collection.\nAccepts a string which will be passed to Luca.template(@itemTemplate).  Your template\ncan expect to be passed an object with the <code>model</code> and <code>index</code> properties on it.</p>\n","default":"undefined"},"itemRenderer":{"defined_on_line":87,"documentation":"<p>Accepts a reference to a function, which will be called with an object with the <code>model</code> and <code>index</code>\nproperties on it.  This function should return a String which will be injected into the item DOM element.</p>\n","default":"undefined"},"itemProperty":{"defined_on_line":90,"documentation":"<p>Plucks the specified property from the model and inserts it into the item DOM element.</p>\n","default":"undefined"},"observeChanges":{"defined_on_line":93,"documentation":"<p>If @observeChanges is set to true, any change in an underlying model will automatically be re-rendered.</p>\n","default":"false"}},"source_file_contents":"# The `Luca.CollectionView` renders models from a `Luca.Collection` into multiple\n# elements, and provides methods for filtering, paginating, sorting the underlying\n# collection and re-rendering the contents of its `@el` accordingly.\n#\n# #### Basic Example\n#     collectionView = Luca.register  \"App.views.Books\"\n#     collectionView.extends          \"Luca.CollectionView\"\n#\n#     collectionView.defines\n#       itemProperty: \"author\"\n#       collection: new Luca.Collection([\n#         author: \"George Orwell\"\n#         title:  \"Animal Farm\"\n#       ,\n#         author: \"Noam Chomsky\"\n#         title: \"Manufacturing Consent\"\n#       ])\n#\n#     view = new App.views.Books()\n# #### Extending it to make it Filterable and Paginatable\n#     filterable = Luca.register    \"App.views.FilterableBooks\"\n#     filterable.extends            \"App.views.Books\"\n#     filterable.defines\n#       collection: \"books\" \n#       paginatable: 12\n#       filterable:\n#         query:\n#           author: \"George Orwell\"\n#    \n#      view = new App.views.FilterableBooks()\n# #### Filterable Collections\n#\n# The `Luca.CollectionView` will attempt to perform a local query against its\n# collection which behaves like a `Backbone.QueryCollection`.  It will do this\n# by default without making a remote request to the API.  \n# \n# If you do not want this behavior, you can configure the `Luca.CollectionView` to \n# behave as if the filtering was happen remotely in your REST API.  \n#\n#       filterable:\n#         options:\n#           remote: true\ncollectionView = Luca.register      \"Luca.CollectionView\"\n\ncollectionView.extends            \"Luca.Panel\"\n\ncollectionView.replaces           \"Luca.components.CollectionView\"\n\ncollectionView.mixesIn            \"QueryCollectionBindings\", \n                                  \"LoadMaskable\", \n                                  \"Filterable\", \n                                  \"Paginatable\",\n                                  \"Sortable\"\n\ncollectionView.triggers           \"before:refresh\",\n                                  \"after:refresh\",\n                                  \"refresh\",\n                                  \"empty:results\"\n\ncollectionView.publicConfiguration\n  # Specify which collection will be used to supply the models to be rendered.\n  # Accepts either a string alias for the Collection class, or an instance of\n  # any class which inherits from Backbone.Collection\n  collection: undefined\n\n  # By default the CollectionView will be rendered inside of an OL tag.\n  tagName: \"ol\"\n\n  # The CollectionView behaves as a Luca.Panel which means it has an area for\n  # top and bottom toolbars.  The actual content that gets rendered from the \n  # collection will be rendered inside an element with the specified class.\n  bodyClassName: \"collection-ui-panel\"\n\n  # Each item from the collection will be rendered inside of an element specified by @itemTagName\n  itemTagName: 'li'\n\n  # Each item element will be assigned a CSS class specified by @itemClassName \n  itemClassName: 'collection-item'\n\n  # Specify which template should be used to render each item in the collection.  \n  # Accepts a string which will be passed to Luca.template(@itemTemplate).  Your template\n  # can expect to be passed an object with the `model` and `index` properties on it.\n  itemTemplate: undefined\n\n  # Accepts a reference to a function, which will be called with an object with the `model` and `index`\n  # properties on it.  This function should return a String which will be injected into the item DOM element.\n  itemRenderer: undefined\n\n  # Plucks the specified property from the model and inserts it into the item DOM element.\n  itemProperty: undefined\n\n  # If @observeChanges is set to true, any change in an underlying model will automatically be re-rendered.\n  observeChanges: false\n\ncollectionView.publicMethods\n  initialize: (@options={})->\n    _.extend(@, @options)\n    _.bindAll @, \"refresh\"\n\n    unless @collection? or @options.collection\n      console.log \"Error on initialize of collection view\", @\n      throw \"Collection Views must specify a collection\"\n\n    unless @itemTemplate? || @itemRenderer? || @itemProperty?\n      throw \"Collection Views must specify an item template or item renderer function\"\n\n    if _.isString(@collection) \n      if Luca.CollectionManager.get()\n        @collection = Luca.CollectionManager.get().getOrCreate(@collection)\n      else\n        console.log \"String Collection but no collection manager\"\n\n    unless Luca.isBackboneCollection(@collection)\n      console.log \"Missing Collection on #{ @name || @cid }\", @, @collection\n      throw \"Collection Views must have a valid backbone collection\"\n\n    # INVESTIGATE THIS BEING DOUBLE WORK\n    @on \"data:refresh\", @refresh, @\n    @on \"collection:reset\", @refresh, @\n\n    @on \"collection:remove\", @refresh, @\n    @on \"collection:add\", @refresh, @\n    @on \"collection:change\", @refreshModel, @ if @observeChanges is true\n\n    Luca.Panel::initialize.apply(@, arguments)\n\n    view = @\n    if @getCollection()?.length > 0\n      @on \"after:render\", ()->\n        view.refresh()\n        view.unbind \"after:render\", @\n\n  # Given the id of a model, find the underlying DOM element which was rendered by this collection.\n  # Assumes that the data-model-id attribute is set, which it is by default by @attributesForItem.\n  locateItemElement: (id)->\n    @$(\".#{ @itemClassName }[data-model-id='#{ id }']\")\n\n  # Refresh is responsible for applying any filtering, pagination, or sorting options that may be set\n  # from the various Luca.concerns mixed in by `Luca.CollectionView` and making a query to the underlying\n  # collection.  It will then take the set of models returned by `@getModels` and pass them through the\n  # item rendering pipeline.\n  refresh: ()->\n    query = @getLocalQuery()\n    options = @getQueryOptions()\n    models  = @getModels(query, options)\n\n    @$bodyEl().empty()\n\n    @trigger(\"before:refresh\", models, query, options)\n\n    if models.length is 0\n      @trigger(\"empty:results\", query, options)\n\n    @renderModels(models, query, options)\n\n    @trigger(\"after:refresh\", models, query, options)\n\n    @\n\n\ncollectionView.privateMethods\n  renderModels: (models, query, options)->\n    index = 0\n    for model in models\n      @$append @makeItem(model, index++)\n\n  # Determines which attributes should be set on the item DOM element. \n  attributesForItem: (item, model)->\n    _.extend {}, class: @itemClassName, \"data-index\": item.index, \"data-model-id\": item.model.get('id')\n\n  # Determines the content for the item DOM element.  Will use the appropriate options\n  # specified by `@itemTemplate`, `@itemRenderer`, or `@itemProperty`\n  contentForItem: (item={})->\n    if @itemTemplate? and templateFn = Luca.template(@itemTemplate)\n      return content = templateFn.call(@, item)\n\n    if @itemRenderer? and _.isFunction( @itemRenderer )\n      return content = @itemRenderer.call(@, item, item.model, item.index)\n\n    if @itemProperty and item.model?\n      return content = item.model.read( @itemProperty )\n\n    \"\"\n\n  # Uses the various options passed to the `CollectionView` to assemble a call to `Luca.View::make`.\n  makeItem: (model, index)->\n    item = if @prepareItem? then @prepareItem.call(@, model, index) else (model:model, index: index)\n    attributes = @attributesForItem(item, model) \n    content = @contentForItem(item)\n\n    try\n      Luca.View::make(@itemTagName, attributes, content)\n    catch e\n      console.log \"Error generating DOM element for CollectionView\", @, model, index\n\n  # Given a model, attempt to re-render the contents of its item in this view's DOM contents.\n  refreshModel: (model)->\n    index = @collection.indexOf( model )\n    @locateItemElement(model.get('id')).empty().append( @contentForItem({model,index}, model) )\n    @trigger(\"model:refreshed\", index, model)\n\n\n  registerEvent: (domEvent, selector, handler)->\n    if !handler? and _.isFunction(selector)\n      handler = selector\n      selector = undefined\n\n    eventTrigger = _([domEvent,\"#{ @itemTagName }.#{ @itemClassName }\", selector]).compact().join(\" \")\n    Luca.View::registerEvent(eventTrigger,handler)\n\ncollectionView.register()\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/controller.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/controller.coffee","type":"component_definition","starts_on_line":25,"class_name":"Luca.components.Controller","header_documentation":"<p>The Controller is a special type of CardView that is used to provide structure to a Luca.Application.  Each\ncomponent in the controller is expected to have a unique <code>@name</code> property.  The Application&#39;s router configuration\nwill map URL / Hashbangs to the <code>@name</code>s of components that belong to the Application controller.<br>\nApplications which structure their &#39;pages&#39; in controllers, or sections, will have the names of which\nsection or page is active inside of its state model.  One example / common application structure we see:\n      application:\n        main<em>controller:\n          controller / section</em>one:\n            page<em>one\n            page</em>two\n            page<em>three\n          controller / section</em>two\n            page<em>alpha\n            page</em>bravo\nIn the above example, the Application would attempt to route to page<em>one, and the state \nof the application may look like:\n      application.activeSection() #=&gt; &#39;section</em>one&#39;\n      application.activeSubSection() # =&gt; &#39;page<em>one&#39;\n      application.activePage() # =&gt; page</em>one</p>\n","type_alias":"controller","css_class_identifier":"luca-controller","defines_methods":{"default":{"defined_on_line":45,"documentation":"<p>Navigate to the default ( or first ) component on this controller.\nThis will automatically get called upon rendering, so that it sets up\nthe proper state tracking, event binding, etc.</p>\n","arguments":[{"argument":"callback","value":null}]},"activePage":{"defined_on_line":50,"documentation":"<p>Returns the name of the component which is currently active\non this controller.</p>\n","arguments":[]},"navigate_to":{"defined_on_line":55,"documentation":"<p>Navigate to a page on this controller by name.  If passed an optional\ncallback, the callback will be called within the context of the activated page.</p>\n","arguments":[{"argument":"page","value":null},{"argument":"callback","value":null}]},"setupComponentKeyEvents":{"defined_on_line":84,"documentation":"<p>For each component we control, if there is a keyEvents property defined\nthen we will define a keymaster scope for that component&#39;s name, and setup\nbindings as directed.  This is important because each time a controller\nactivates a component, that component will attempt to change the scope of\nthe keymaster so that components becomes responsible for handling detected key events.</p>\n","arguments":[]},"controllerPath":{"defined_on_line":106,"documentation":"<p>The Controller Path is an array of the names of the controllers\na given component belongs to.  This method will get patched on to each\ncomponent that belongs to a controller.  It will always be bound to the instance\nof the component itself.  Example:</p>\n\n<p>application.contains\nname: &quot;main<em>controller&quot;\ncomponents: [\nname: &quot;sub</em>controller&quot;\ncomponents:[\nname: &quot;page&quot;\n]\n]</p>\n\n<p>The @controllerPath() method for the component named page would be [&#39;sub_controller&#39;,&#39;page&#39;].\nThis will be used internally by the Application route builder, so that each of page&#39;s parent\ncontrollers are activated in the proper order needed to make page visible.</p>\n","arguments":[]},"initialize":{"defined_on_line":124,"documentation":"","arguments":[{"argument":"@options","value":null}]},"each":{"defined_on_line":143,"documentation":"","arguments":[{"argument":"fn","value":null}]},"activeSection":{"defined_on_line":146,"documentation":"","arguments":[]},"pageControllers":{"defined_on_line":149,"documentation":"","arguments":[{"argument":"deep","value":"false"}]},"controllers":{"defined_on_line":152,"documentation":"","arguments":[{"argument":"deep","value":"false"}]},"availablePages":{"defined_on_line":157,"documentation":"","arguments":[]},"availableSections":{"defined_on_line":160,"documentation":"","arguments":[]},"pageNames":{"defined_on_line":170,"documentation":"","arguments":[]},"sectionNames":{"defined_on_line":173,"documentation":"","arguments":[{"argument":"deep","value":"false"}]}},"defines_properties":{"tracker":{"defined_on_line":32,"documentation":"<p>If there is an active application, we will attempt to\nset the name of our currently activated page on the application&#39;s\nstate machine.  The attribute we will set can be configured by setting this value.</p>\n","default":"\"page\""},"activeAttribute":{"defined_on_line":36,"documentation":"<p>We will set the name of the active page / section on our DOM element\nThe attribute we will set can be configured by setting this.</p>\n","default":"\"active-section\""},"stateful":{"defined_on_line":37,"documentation":"","default":"true"},"defaultPage":{"defined_on_line":38,"documentation":"","default":"undefined"},"defaultCard":{"defined_on_line":39,"documentation":"","default":"0"},"Luca.View":{"defined_on_line":120,"documentation":"","default":""}},"source_file_contents":"# The Controller is a special type of CardView that is used to provide structure to a Luca.Application.  Each\n# component in the controller is expected to have a unique `@name` property.  The Application's router configuration\n# will map URL / Hashbangs to the `@name`s of components that belong to the Application controller.  \n#\n# Applications which structure their 'pages' in controllers, or sections, will have the names of which\n# section or page is active inside of its state model.  One example / common application structure we see:\n#\n#       application:\n#         main_controller:\n#           controller / section_one:\n#             page_one\n#             page_two\n#             page_three\n#           controller / section_two\n#             page_alpha\n#             page_bravo\n#\n# In the above example, the Application would attempt to route to page_one, and the state \n# of the application may look like:\n#\n#       application.activeSection() #=> 'section_one'\n#       application.activeSubSection() # => 'page_one'\n#       application.activePage() # => page_one\n#\ncontroller = Luca.register        \"Luca.components.Controller\"\ncontroller.extends                \"Luca.containers.CardView\"\n\ncontroller.publicConfiguration\n  # If there is an active application, we will attempt to \n  # set the name of our currently activated page on the application's\n  # state machine.  The attribute we will set can be configured by setting this value.\n  tracker: \"page\"\n\n  # We will set the name of the active page / section on our DOM element\n  # The attribute we will set can be configured by setting this.\n  activeAttribute: \"active-section\"\n  stateful: true\n  defaultPage: undefined\n  defaultCard: 0\n\ncontroller.publicMethods  \n  # Navigate to the default ( or first ) component on this controller.\n  # This will automatically get called upon rendering, so that it sets up\n  # the proper state tracking, event binding, etc.\n  default: (callback)->\n    @navigate_to(@defaultPage || @defaultCard, callback)\n\n  # Returns the name of the component which is currently active\n  # on this controller.\n  activePage: ()-> \n    @activeSection()\n\n  # Navigate to a page on this controller by name.  If passed an optional\n  # callback, the callback will be called within the context of the activated page.\n  navigate_to: (page, callback)->\n    page ||= @defaultCard\n\n    @activate page, false, (activator, previous,current)=>\n      if current.activatedByController is true\n        current.trigger(\"on:controller:reactivation\")\n      else\n        current.trigger(\"on:controller:activation\")\n        current.activatedByController = true\n\n      @state.set(active_section: current.name )\n\n      if @tracker? and app = @app || Luca.getApplication?()\n        app.state.set(@tracker, current.name)\n\n      Luca.key?.setScope( current.name )\n\n      if _.isFunction( callback )\n        callback.call(current)\n\n    # return the component we are navigating to\n    @find(page)\n\ncontroller.classMethods\n  # For each component we control, if there is a keyEvents property defined\n  # then we will define a keymaster scope for that component's name, and setup\n  # bindings as directed.  This is important because each time a controller \n  # activates a component, that component will attempt to change the scope of\n  # the keymaster so that components becomes responsible for handling detected key events.\n  setupComponentKeyEvents: ()->\n    @_().each (component)->    \n      if _.isObject(component.keyEvents) and component.name?\n        Luca.util.setupKeymaster(component.keyEvents, component.name).on(component)    \n\n  # The Controller Path is an array of the names of the controllers\n  # a given component belongs to.  This method will get patched on to each\n  # component that belongs to a controller.  It will always be bound to the instance\n  # of the component itself.  Example:\n  # \n  #       application.contains\n  #         name: \"main_controller\"\n  #         components: [\n  #           name: \"sub_controller\"\n  #           components:[\n  #             name: \"page\"\n  #           ]\n  #         ]\n  #\n  # The @controllerPath() method for the component named page would be ['sub_controller','page'].\n  # This will be used internally by the Application route builder, so that each of page's parent\n  # controllers are activated in the proper order needed to make page visible.\n  controllerPath: ()->\n    component = @\n    \n    list = [component.name]\n    atBase = false\n\n    while component and not atBase\n      component = component.getParent?()\n      atBase = true if component?.role is \"main_controller\"\n      list.push( component.name ) if component? and not atBase\n\n    list.reverse()\n\ncontroller.afterDefinition ()->\n  Luca.View::hooks.push \"on:controller:activation\"\n\ncontroller.defines\n\n  initialize: (@options)->\n    # let's phase out the 'card' terminology \n    # and 'section' while we're at it.  page is the word.\n    @defaultCard ||= @defaultPage ||= @components[0]?.name || 0\n    @defaultPage ||= @defaultCard \n\n    @defaultState ||= \n      active_section: @defaultPage\n\n    Luca.containers.CardView::initialize.apply @, arguments\n\n    throw \"Controllers must specify a defaultCard property and/or the first component must have a name\" unless @defaultCard?\n\n    @_().each (component)->\n      component.controllerPath = Luca.components.Controller.controllerPath\n\n    @on \"after:render\", @default, @\n    @on \"before:render\", Luca.components.Controller.setupComponentKeyEvents, @\n\n  each: (fn)->\n    _( @components ).each (component)=> fn.call(@,component)\n\n  activeSection: ()->\n    @get(\"active_section\")\n\n  pageControllers: (deep=false)->\n    @controllers.apply(@, arguments)\n\n  controllers:(deep=false)->\n    @select (component)->\n      type = (component.type || component.ctype) \n      type is \"controller\" or type is \"page_controller\"\n\n  availablePages: ()->\n    @availableSections.apply(@, arguments)    \n\n  availableSections: ()->\n    console.log \"The availableSections()/availablePages() method will be removed in 1.0\"\n    base = {}\n    base[ @name ] = @sectionNames()\n\n    _( @controllers() ).reduce (memo,controller)=>\n      memo[ controller.name ] = controller.sectionNames()  \n      memo\n    , base \n\n  pageNames: ()->\n    @sectionNames()\n\n  sectionNames: (deep=false)->\n    @pluck('name')\n\n\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/base.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/base.coffee","type":"component_definition","starts_on_line":7,"class_name":"Luca.core.Field","header_documentation":"<p>The <code>Luca.core.Field</code> is an abstract base class for field components\nwhich are used in the <code>Luca.components.FormView</code>.  They provide common\nfunctionality like getValue, setValue, change and validation event bindings. \nAdditionally, the field component provides common Twitter Bootstrap styling\nhooks, such as error, warning, and success status flagging.</p>\n","type_alias":"field","css_class_identifier":"luca-core-field","defines_methods":{"disable":{"defined_on_line":57,"documentation":"<p>Disable this field</p>\n","arguments":[]},"enable":{"defined_on_line":61,"documentation":"<p>Enable this field</p>\n","arguments":[]},"getValue":{"defined_on_line":65,"documentation":"<p>Gets the value from the input element in this field control</p>\n","arguments":[]},"setValue":{"defined_on_line":70,"documentation":"<p>Sets the value on the input element inside this field control</p>\n","arguments":[{"argument":"value","value":null}]},"updateState":{"defined_on_line":75,"documentation":"<p>Update the state of this field.  Valid options are defined on\nthis fields <code>@statuses</code> property</p>\n","arguments":[{"argument":"state","value":null}]},"clearErrors":{"defined_on_line":82,"documentation":"<p>Remove any visual error indications from this field control</p>\n","arguments":[]},"displayErrors":{"defined_on_line":86,"documentation":"<p>Display a visual error state on this field</p>\n","arguments":[{"argument":"errors","value":null}]},"getParsedValue":{"defined_on_line":93,"documentation":"<p>Runs the value from the underlying input element\nthrough a type conversion process configured by\nthe <code>@valueType</code> field</p>\n","arguments":[{"argument":"raw","value":null}]},"initialize":{"defined_on_line":108,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"beforeRender":{"defined_on_line":132,"documentation":"","arguments":[]},"change_handler":{"defined_on_line":138,"documentation":"","arguments":[{"argument":"e","value":null}]},"getInputElement":{"defined_on_line":141,"documentation":"","arguments":[]}},"defines_properties":{"className":{"defined_on_line":16,"documentation":"","default":"'luca-ui-field'"},"disabled":{"defined_on_line":19,"documentation":"<p>Controls whether or not this field is rendered in a disabled state</p>\n","default":"undefined"},"helperText":{"defined_on_line":22,"documentation":"<p>Controls the bootstrap helperText value for this field control</p>\n","default":"undefined"},"label":{"defined_on_line":25,"documentation":"<p>Text value for the label element that goes along with this field control</p>\n","default":"undefined"},"labelAlign":{"defined_on_line":30,"documentation":"<p>Controls the positioning of the label element.  Valid options are\n&#39;top&#39;, &#39;left&#39;.  For any other custom display you can control this\non your own by specifying a template</p>\n","default":"'top'"},"placeHolder":{"defined_on_line":34,"documentation":"<p>Controls the value displayed in this field when it is in an untouched state\nby the user.  Uses the html5 placeholder attribute</p>\n","default":"undefined"},"required":{"defined_on_line":38,"documentation":"<p>Controls whether or not we want to display visual indicator\nthat this field is required.</p>\n","default":"undefined"},"statuses":{"defined_on_line":42,"documentation":"<p>Which statuses can be applied to this field? Valid options are taken\nfrom bootstrap state styling.</p>\n","default":"["},"valueType":{"defined_on_line":51,"documentation":"<p>What is the type of value that this field\nshould have? You can use this to coerce the <code>getValue()</code> type\ninto an integer, string, or float.</p>\n","default":"\"string\""},"isField":{"defined_on_line":104,"documentation":"<p>A convenience method for identifying field components</p>\n","default":"true"},"template":{"defined_on_line":105,"documentation":"","default":"'fields/text_field'"}},"source_file_contents":"# The `Luca.core.Field` is an abstract base class for field components\n# which are used in the `Luca.components.FormView`.  They provide common\n# functionality like getValue, setValue, change and validation event bindings. \n#\n# Additionally, the field component provides common Twitter Bootstrap styling\n# hooks, such as error, warning, and success status flagging.\nfield = Luca.register         \"Luca.core.Field\"\n\nfield.extends                 \"Luca.View\"\n\nfield.triggers                \"before:validation\",\n                              \"after:validation\",\n                              \"on:change\"\n\nfield.publicConfiguration\n  className: 'luca-ui-field'\n\n  # Controls whether or not this field is rendered in a disabled state\n  disabled: undefined\n\n  # Controls the bootstrap helperText value for this field control\n  helperText: undefined\n\n  # Text value for the label element that goes along with this field control\n  label: undefined\n\n  # Controls the positioning of the label element.  Valid options are\n  # 'top', 'left'.  For any other custom display you can control this\n  # on your own by specifying a template\n  labelAlign: 'top'\n\n  # Controls the value displayed in this field when it is in an untouched state\n  # by the user.  Uses the html5 placeholder attribute\n  placeHolder: undefined\n\n  # Controls whether or not we want to display visual indicator\n  # that this field is required. \n  required: undefined\n\n  # Which statuses can be applied to this field? Valid options are taken\n  # from bootstrap state styling.\n  statuses: [\n    \"warning\"\n    \"error\"\n    \"success\"\n  ]\n\n  # What is the type of value that this field\n  # should have? You can use this to coerce the `getValue()` type\n  # into an integer, string, or float.\n  valueType: \"string\"\n\n\n\nfield.publicMethods\n  # Disable this field\n  disable: ()->\n    @getInputElement().attr('disabled', true)\n\n  # Enable this field\n  enable: ()->\n    @getInputElement().attr('disabled', false)\n\n  # Gets the value from the input element in this field control\n  getValue: ()->\n    raw = @getInputElement()?.val()\n    @getParsedValue(raw)\n\n  # Sets the value on the input element inside this field control\n  setValue: (value)->\n    @getInputElement()?.val(value)\n\n  # Update the state of this field.  Valid options are defined on\n  # this fields `@statuses` property\n  updateState: (state)->\n    for cssClass in @statuses\n      @$el.removeClass(cssClass)\n\n    @$el.addClass(state)\n\n  # Remove any visual error indications from this field control\n  clearErrors: ()->\n    @$el.removeClass('error')\n\n  # Display a visual error state on this field\n  displayErrors: (errors)->\n    @updateState('error')\n\nfield.privateMethods\n  # Runs the value from the underlying input element\n  # through a type conversion process configured by\n  # the `@valueType` field\n  getParsedValue: (raw)->\n    return raw if _.str.isBlank( raw )\n\n    switch @valueType\n      when \"integer\" then parseInt(raw)\n      when \"string\" then \"#{ raw }\"\n      when \"float\" then parseFloat(raw)\n      else raw\n\nfield.privateConfiguration\n  # A convenience method for identifying field components\n  isField: true\n  template: 'fields/text_field'\n\nfield.privateMethods\n  initialize: (@options={})->\n    _.extend @, @options\n\n    @input_id ||= _.uniqueId('field')\n    @input_name ||= @name\n    @input_class ||= \"\"\n    @input_type ||= \"\"\n    @helperText ||= \"\"\n    @label = @name if not @label? or @label.length is 0\n    @label ||= \"*#{ @label }\" if @required and not @label?.match(/^\\*/)\n    @inputStyles ||= \"\"\n    @input_value ||= @value || \"\"\n\n    @disable() if @disabled\n\n    @updateState( @state )\n    @placeHolder ||= \"\"\n\n    # In order to support using Luca.View template properties everywhere.\n\n    # Will need to work around how the field classes\n    # apply templates to themselves.\n    Luca.View::initialize.apply(@, arguments)\n\n  beforeRender: ()->\n    if Luca.config.enableBoostrap\n      @$el.addClass('control-group')\n\n    @$el.addClass('required') if @required\n\n  change_handler: (e)->\n    @trigger \"on:change\", @, e\n\n  getInputElement: ()->\n    @input ||= @$('input').eq(0)\n\nfield.register()\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/button_field.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/button_field.coffee","type":"component_definition","starts_on_line":7,"class_name":"Luca.fields.ButtonField","header_documentation":"<p>The <code>Luca.fields.ButtonField</code> provides an easy way to generate\na button element, with an optional icon.  Supports all of the\navailable bootstrap icons, and color states.<br>\nThe <code>Luca.fields.ButtonField</code> component will typically be used as \npart of a <code>Luca.components.FormView</code> or a <code>Luca.components.PanelToolbar</code>.</p>\n","type_alias":"button_field","css_class_identifier":"luca-fields-button-field","defines_methods":{"clickHandler":{"defined_on_line":64,"documentation":"","arguments":[{"argument":"e","value":null}]},"initialize":{"defined_on_line":68,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"afterInitialize":{"defined_on_line":75,"documentation":"","arguments":[]},"setValue":{"defined_on_line":88,"documentation":"","arguments":[]}},"defines_properties":{"buttonSize":{"defined_on_line":19,"documentation":"<p>Which size should this button be? Valid options are:\n- none ( default )\n- large\n- mini\n- small</p>\n","default":"undefined"},"class":{"defined_on_line":32,"documentation":"<p>Which bootstrap color class should we apply to this button?\nValid options are any css button class, or the defaults which\nship with bootstrap:</p>\n\n<ul>\n<li>btn-primary</li>\n<li>btn-info</li>\n<li>btn-success</li>\n<li>btn-warning</li>\n<li>btn-danger</li>\n<li>btn-inverse</li>\n<li>btn-link</li>\n</ul>\n","default":"undefined"},"icon_class":{"defined_on_line":36,"documentation":"<p>specifies the bootstrap icon class you want to use for this button\nyou can use &#39;icon-ok-sign&#39; or just &#39;ok-sign&#39;</p>\n","default":"undefined"},"label":{"defined_on_line":39,"documentation":"<p>specifies the text value of the button</p>\n","default":"undefined"},"text":{"defined_on_line":43,"documentation":"<p>an alias for label, or input_value.  controls which text\ndisplays inside of the button</p>\n","default":"undefined"},"white":{"defined_on_line":46,"documentation":"<p>should we render the white icon?</p>\n","default":"false"},"readOnly":{"defined_on_line":49,"documentation":"","default":"true"},"input_value":{"defined_on_line":50,"documentation":"","default":"undefined"},"input_type":{"defined_on_line":51,"documentation":"","default":"\"button\""},"input_name":{"defined_on_line":53,"documentation":"","default":"undefined"},"buttonClasses":{"defined_on_line":54,"documentation":"","default":"\"\""},"isButton":{"defined_on_line":57,"documentation":"","default":"true"},"autoBindEventHandlers":{"defined_on_line":58,"documentation":"","default":"true"},"template":{"defined_on_line":59,"documentation":"","default":"\"fields/button_field\""},"events":{"defined_on_line":60,"documentation":"","default":null}},"source_file_contents":"# The `Luca.fields.ButtonField` provides an easy way to generate\n# a button element, with an optional icon.  Supports all of the\n# available bootstrap icons, and color states.  \n#\n# The `Luca.fields.ButtonField` component will typically be used as \n# part of a `Luca.components.FormView` or a `Luca.components.PanelToolbar`.\nbuttonField = Luca.register         \"Luca.fields.ButtonField\"\n\nbuttonField.extends                 \"Luca.core.Field\"\n\nbuttonField.triggers                \"button:click\"\n\nbuttonField.publicConfiguration\n  # Which size should this button be? Valid options are:\n  # - none ( default )\n  # - large\n  # - mini\n  # - small\n  buttonSize: undefined\n\n  # Which bootstrap color class should we apply to this button?\n  # Valid options are any css button class, or the defaults which\n  # ship with bootstrap: \n  #\n  # - btn-primary\n  # - btn-info\n  # - btn-success\n  # - btn-warning\n  # - btn-danger\n  # - btn-inverse\n  # - btn-link\n  class: undefined \n\n  # specifies the bootstrap icon class you want to use for this button \n  # you can use 'icon-ok-sign' or just 'ok-sign'\n  icon_class: undefined\n\n  # specifies the text value of the button\n  label: undefined    \n\n  # an alias for label, or input_value.  controls which text \n  # displays inside of the button\n  text: undefined\n\n  # should we render the white icon? \n  white: false\n\nbuttonField.privateConfiguration\n  readOnly:       true\n  input_value:    undefined \n  input_type:     \"button\" \n  icon_class:     undefined\n  input_name:     undefined\n  buttonClasses:  \"\" \n\nbuttonField.privateConfiguration\n  isButton: true\n  autoBindEventHandlers: true\n  template: \"fields/button_field\"\n  events:\n    \"click input\" : \"clickHandler\"\n\nbuttonField.privateMethods\n  clickHandler: (e)->\n    me = my = $( e.currentTarget )\n    @trigger \"button:click\"\n\n  initialize: (@options={})->\n    _.extend @, @options\n\n    Luca.core.Field::initialize.apply @, arguments\n\n    @template = \"fields/button_field_link\" if @icon_class?.length\n\n  afterInitialize: ()->\n    @input_id ||= _.uniqueId('button')\n    @input_name ||= @name ||= @input_id\n    @input_value ||= @label ||= @text\n    @input_class ||= @class ||= @buttonClasses\n\n    if @buttonSize?.length > 0\n      @input_class += \" #{ buttonSize.replace(/btn-/,'') }\"\n\n    @icon_class ||= \"\"\n    @icon_class = \"icon-#{ @icon_class }\" if @icon_class.length and !@icon_class.match(/^icon-/)\n    @icon_class += \" icon-white\" if @white\n\n  setValue: ()-> \n    true\n\nbuttonField.register()\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/checkbox_array.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/checkbox_array.coffee","type":"component_definition","starts_on_line":4,"class_name":"Luca.fields.CheckboxArray","header_documentation":"<p>The <code>Luca.fields.CheckboxArray</code> renders an array of values \ninto checkbox controls.  This is for fields which can have\na list of values associated with them.</p>\n","type_alias":"checkbox_array","css_class_identifier":"luca-fields-checkbox-array","defines_methods":{"initialize":{"defined_on_line":18,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"afterInitialize":{"defined_on_line":31,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"clickHandler":{"defined_on_line":47,"documentation":"","arguments":[{"argument":"event","value":null}]},"controls":{"defined_on_line":56,"documentation":"","arguments":[]},"renderCheckboxes":{"defined_on_line":59,"documentation":"","arguments":[]},"uncheckAll":{"defined_on_line":77,"documentation":"","arguments":[]},"allFields":{"defined_on_line":80,"documentation":"","arguments":[]},"checkSelected":{"defined_on_line":86,"documentation":"<p>Check the selected items.  Expects an array of values\nfor boxes you would like to see checked.</p>\n","arguments":[{"argument":"items","value":null}]},"getValue":{"defined_on_line":99,"documentation":"<p>Gets an array of values for the checkboxes in this array\nwhich are checked.</p>\n","arguments":[]},"setValue":{"defined_on_line":102,"documentation":"","arguments":[{"argument":"items","value":null}]},"getValues":{"defined_on_line":113,"documentation":"","arguments":[]},"setValues":{"defined_on_line":116,"documentation":"","arguments":[{"argument":"items","value":null}]}},"defines_properties":{"template":{"defined_on_line":8,"documentation":"","default":"\"fields/checkbox_array\""},"className":{"defined_on_line":10,"documentation":"","default":"\"luca-ui-checkbox-array\""},"events":{"defined_on_line":12,"documentation":"","default":null},"selectedItems":{"defined_on_line":15,"documentation":"","default":"[]"}},"source_file_contents":"# The `Luca.fields.CheckboxArray` renders an array of values \n# into checkbox controls.  This is for fields which can have\n# a list of values associated with them.\ncheckboxArray = Luca.register     \"Luca.fields.CheckboxArray\"\ncheckboxArray.extends             \"Luca.core.Field\"\n\ncheckboxArray.privateConfiguration\n  template: \"fields/checkbox_array\"\n\n  className: \"luca-ui-checkbox-array\"\n\n  events:\n    \"click input\" : \"clickHandler\"\n\n  selectedItems: []\n\ncheckboxArray.privateMethods\n  initialize: (@options={})->\n    _.extend @, @options\n    _.extend @, Luca.concerns.Deferrable\n    _.bindAll @, \"renderCheckboxes\", \"clickHandler\", \"checkSelected\"\n\n    Luca.core.Field::initialize.apply @, arguments\n\n    @input_id ||= _.uniqueId('field')\n    @input_name ||= @name\n    @label ||= @name\n    @valueField ||= \"id\"\n    @displayField ||= \"name\"\n\n  afterInitialize: (@options={})->\n    try\n      @configure_collection()\n    catch e\n      console.log \"Error Configuring Collection\", @, e.message\n\n    cbArray = @\n\n    unless Luca.isBackboneCollection(@collection)\n      throw \"Checkbox Array Fields must specify a @collection property\"\n      \n    if @collection.length > 0\n      @renderCheckboxes()\n    else\n      @defer(\"renderCheckboxes\").until(@collection,\"reset\")\n\n  clickHandler: (event)->\n    checkbox = $(event.target)\n\n    if checkbox.prop('checked')\n      @selectedItems.push( checkbox.val() )\n    else\n      if _( @selectedItems ).include( checkbox.val() )\n        @selectedItems = _( @selectedItems ).without( checkbox.val() )\n\n  controls: ()->\n    @$('.controls')\n\n  renderCheckboxes: ()->\n    @controls().empty()\n    @selectedItems = []\n\n    @collection.each (model)=>\n      value = model.get(@valueField)\n      label = model.get(@displayField)\n      input_id = _.uniqueId(\"#{ @cid }_checkbox\")\n\n      inputElement = @make(\"input\",type:\"checkbox\",class:\"array-checkbox\",name:@input_name,value:value,id: input_id)\n      element = @make(\"label\", {for:input_id}, inputElement)\n\n      $( element ).append(\" #{ label }\")\n      @controls().append( element )\n\n    @trigger(\"checkboxes:rendered\", @checkboxesRendered = true)\n    @\n\n  uncheckAll: ()->\n    @allFields().prop('checked', false)\n\n  allFields: ()->\n    @controls().find(\"input[type='checkbox']\")\n\ncheckboxArray.publicMethods\n  # Check the selected items.  Expects an array of values \n  # for boxes you would like to see checked.\n  checkSelected: (items)->\n    @selectedItems = items if items?\n\n    @uncheckAll()\n\n    for value in @selectedItems\n      checkbox = @controls().find(\"input[value='#{ value }']\")\n      checkbox.prop('checked', true)\n\n    @selectedItems\n\n  # Gets an array of values for the checkboxes in this array\n  # which are checked.\n  getValue: ()->\n    @$(field).val() for field in @allFields() when @$(field).prop('checked')\n\n  setValue: (items)->\n    @selectedItems = items\n\n    if @checkboxesRendered is true\n      @checkSelected(items)\n    else\n      cbArray = @\n      @defer ()->\n        cbArray.checkSelected(items)\n      .until(\"checkboxes:rendered\")\n\n  getValues: ()->\n    @getValue()\n\n  setValues: (items)->\n    @setValue(items)"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/checkbox_field.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/checkbox_field.coffee","type":"component_definition","starts_on_line":1,"class_name":"Luca.fields.CheckboxField","header_documentation":"","type_alias":"checkbox_field","css_class_identifier":"luca-fields-checkbox-field","defines_methods":{"change_handler":{"defined_on_line":18,"documentation":"","arguments":[{"argument":"e","value":null}]},"initialize":{"defined_on_line":28,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"setValue":{"defined_on_line":39,"documentation":"","arguments":[{"argument":"checked","value":null}]},"getValue":{"defined_on_line":42,"documentation":"","arguments":[]}},"defines_properties":{"send_blanks":{"defined_on_line":9,"documentation":"","default":"true"},"input_value":{"defined_on_line":10,"documentation":"","default":"1"},"template":{"defined_on_line":13,"documentation":"","default":"'fields/checkbox_field'"},"events":{"defined_on_line":14,"documentation":"","default":null},"version":{"defined_on_line":46,"documentation":"","default":"1"}},"source_file_contents":"checkboxField = Luca.register         \"Luca.fields.CheckboxField\"\n\ncheckboxField.extends                 \"Luca.core.Field\"\n\ncheckboxField.triggers                \"checked\",\n                                      \"unchecked\"\n\ncheckboxField.publicConfiguration\n  send_blanks: true\n  input_value: 1\n\ncheckboxField.privateConfiguration\n  template: 'fields/checkbox_field'\n  events:\n    \"change input\" : \"change_handler\"\n\ncheckboxField.privateInterface\n  change_handler: (e)->\n    me = my = $(e.target)\n\n    if me.is(\":checked\")\n      @trigger \"checked\"\n    else\n      @trigger \"unchecked\"\n\n    @trigger \"on:change\", @, e, me.is(\":checked\")\n\n  initialize: (@options={})->\n    _.extend @, @options\n    _.bindAll @, \"change_handler\"\n\n    Luca.core.Field::initialize.apply @, arguments\n\n    @input_id ||= _.uniqueId('field')\n    @input_name ||= @name\n    @label ||= @name\n\ncheckboxField.publicInterface\n  setValue: (checked)->\n    @getInputElement().attr('checked', checked)\n\n  getValue:()->\n    @getInputElement().is(\":checked\")\n\ncheckboxField.defines\n  version: 1"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/file_upload_field.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/file_upload_field.coffee","type":"component_definition","starts_on_line":1,"class_name":"Luca.fields.FileUploadField","header_documentation":"","type_alias":"file_upload_field","css_class_identifier":"luca-fields-file-upload-field","defines_methods":{"afterInitialize":{"defined_on_line":9,"documentation":"","arguments":[]}},"defines_properties":{"version":{"defined_on_line":5,"documentation":"","default":"1"},"template":{"defined_on_line":7,"documentation":"","default":"'fields/file_upload_field'"}},"source_file_contents":"fileUpload = Luca.register              \"Luca.fields.FileUploadField\"\nfileUpload.extends                      \"Luca.core.Field\"\n\nfileUpload.defines\n  version: 1\n\n  template: 'fields/file_upload_field'\n\n  afterInitialize: ()->\n    @input_id ||= _.uniqueId('field')\n    @input_name ||= @name\n    @label ||= @name\n    @helperText ||= \"\"\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/hidden_field.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/hidden_field.coffee","type":"component_definition","starts_on_line":1,"class_name":"Luca.fields.HiddenField","header_documentation":"","type_alias":"hidden_field","css_class_identifier":"luca-fields-hidden-field","defines_methods":{"afterInitialize":{"defined_on_line":7,"documentation":"","arguments":[]}},"defines_properties":{"template":{"defined_on_line":5,"documentation":"","default":"'fields/hidden_field'"}},"source_file_contents":"hiddenField = Luca.register       \"Luca.fields.HiddenField\"\nhiddenField.extends               \"Luca.core.Field\"\n\nhiddenField.defines\n  template: 'fields/hidden_field'\n\n  afterInitialize: ()->\n    @input_id ||= _.uniqueId('field')\n    @input_name ||= @name\n    @input_value ||= @value\n    @label ||= @name"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/label_field.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/label_field.coffee","type":"component_definition","starts_on_line":1,"class_name":"Luca.components.LabelField","header_documentation":"","type_alias":"label_field","css_class_identifier":"luca-label-field","defines_methods":{"formatter":{"defined_on_line":5,"documentation":"","arguments":[{"argument":"value","value":null}]},"setValue":{"defined_on_line":9,"documentation":"","arguments":[{"argument":"value","value":null}]}},"defines_properties":{},"source_file_contents":"labelField = Luca.register          \"Luca.components.LabelField\"\nlabelField.extends                  \"Luca.core.Field\"\n\nlabelField.defines\n  formatter: (value)->\n    value ||= @getValue()\n    _.str.titleize( value )\n\n  setValue: (value)->\n    @trigger(\"change\", value, @getValue())\n    @getInputElement().attr('value', value)\n    @$('.value').html( @formatter(value) )\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/select_field.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/select_field.coffee","type":"component_definition","starts_on_line":1,"class_name":"Luca.fields.SelectField","header_documentation":"","type_alias":"select_field","css_class_identifier":"luca-fields-select-field","defines_methods":{"setValue":{"defined_on_line":47,"documentation":"<p>sets the value of this select field.</p>\n","arguments":[{"argument":"value","value":null}]},"getValue":{"defined_on_line":54,"documentation":"<p>returns the value of the select field.  runs\nthe value through the getParsedValue method which\nenforces the valueType type conversion.</p>\n","arguments":[]},"initialize":{"defined_on_line":64,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"afterInitialize":{"defined_on_line":80,"documentation":"","arguments":[]},"parseData":{"defined_on_line":99,"documentation":"<p>if the select field is configured with a data property\nthen parse that data into the proper format.  either\nan array of objects with the valueField and displayField\nproperties, or an array of arrays with [valueField, displayField]</p>\n","arguments":[]},"getInputElement":{"defined_on_line":109,"documentation":"","arguments":[]},"afterRender":{"defined_on_line":112,"documentation":"","arguments":[]},"beforeFetch":{"defined_on_line":118,"documentation":"","arguments":[]},"change_handler":{"defined_on_line":121,"documentation":"","arguments":[{"argument":"e","value":null}]},"resetOptions":{"defined_on_line":124,"documentation":"","arguments":[]},"populateOptions":{"defined_on_line":132,"documentation":"","arguments":[]}},"defines_properties":{"allowMultiple":{"defined_on_line":10,"documentation":"<p>Enables multi-select UI element.</p>\n","default":"false"},"includeBlank":{"defined_on_line":14,"documentation":"<p>Includes a blank option in addition to all of the items\nin the underlying collection.  Defaults to <code>true</code></p>\n","default":"true"},"blankValue":{"defined_on_line":18,"documentation":"<p>determines which value is sent when\nthe blank option is selected?</p>\n","default":"''"},"blankText":{"defined_on_line":22,"documentation":"<p>Determines the text displayed when\nthe blank option is selected</p>\n","default":"'Select One'"},"maxDisplayLength":{"defined_on_line":28,"documentation":"<p>Specifying a value for maxDisplayLength will truncate\nvalues displayed in the select field when they reach\npast a certain point, using the _.str truncate method.\nLeave at 0 if you want to keep this feature disabled.</p>\n","default":"0"},"retainValue":{"defined_on_line":34,"documentation":"<p>When the underlying collection is reset and we re-render\nthe options elements, should we keep the value that was set\non this field prior to that? Defaults to <code>true</code> unless otherwise\nspecified.</p>\n","default":"undefined"},"label":{"defined_on_line":38,"documentation":"<p>Determines which value is rendered in the label element that gets\nrendered along with this control group.</p>\n","default":"undefined"},"template":{"defined_on_line":41,"documentation":"","default":"\"fields/select_field\""},"events":{"defined_on_line":42,"documentation":"","default":null}},"source_file_contents":"selectField = Luca.register   \"Luca.fields.SelectField\"\n\nselectField.extends           \"Luca.core.Field\"\n\nselectField.triggers          \"after:select\",\n                              \"on:change\"\n\nselectField.publicConfiguration\n  # Enables multi-select UI element.\n  allowMultiple: false\n\n  # Includes a blank option in addition to all of the items\n  # in the underlying collection.  Defaults to `true` \n  includeBlank: true\n\n  # determines which value is sent when \n  # the blank option is selected?\n  blankValue: ''\n\n  # Determines the text displayed when \n  # the blank option is selected \n  blankText: 'Select One'\n\n  # Specifying a value for maxDisplayLength will truncate\n  # values displayed in the select field when they reach \n  # past a certain point, using the _.str truncate method.\n  # Leave at 0 if you want to keep this feature disabled.\n  maxDisplayLength: 0 \n\n  # When the underlying collection is reset and we re-render\n  # the options elements, should we keep the value that was set\n  # on this field prior to that? Defaults to `true` unless otherwise\n  # specified.\n  retainValue: undefined\n\n  # Determines which value is rendered in the label element that gets\n  # rendered along with this control group. \n  label: undefined\n\nselectField.privateConfiguration\n  template: \"fields/select_field\"\n  events:\n    \"change select\" : \"change_handler\"\n\nselectField.publicMethods\n  # sets the value of this select field.\n  setValue: (value)->\n    @currentValue = value\n    Luca.core.Field::setValue.apply @, arguments\n\n  # returns the value of the select field.  runs\n  # the value through the getParsedValue method which\n  # enforces the valueType type conversion.\n  getValue: ()->\n    raw = @getInputElement()?.val()\n\n    if @allowMultiple\n      _.map raw, (value)=>\n        @getParsedValue(value)\n    else\n      @getParsedValue(raw)\n\nselectField.privateMethods\n  initialize: (@options={})->\n    _.extend @, @options\n    _.extend @, Luca.concerns.Deferrable\n    _.bindAll @, \"change_handler\"\n\n    if _.isArray(@collection)\n      @collection = data: @collection\n\n    Luca.core.Field::initialize.apply @, arguments\n\n    @input_id ||= _.uniqueId('field')\n    @input_name ||= @name\n    @valueType ||= Luca.config.idAttributeType if @valueField is \"id\"\n    @label ||= @name\n    @retainValue = true unless @retainValue? \n\n  afterInitialize: ()->\n    if @collection?.data\n      @valueField ||= \"id\"\n      @displayField ||= \"name\"\n      @sortOptionsBy ||= @displayField\n      @parseData()\n\n    try\n      @configure_collection( @setAsDeferrable )\n    catch e\n      console.log \"Error Configuring Collection\", @, e.message\n\n    @collection?.bind \"before:fetch\", @beforeFetch, @\n    @collection?.bind \"reset\", @populateOptions, @\n\n  # if the select field is configured with a data property\n  # then parse that data into the proper format.  either\n  # an array of objects with the valueField and displayField\n  # properties, or an array of arrays with [valueField, displayField]\n  parseData: ()->\n    @collection.data = _( @collection.data ).map (record)=>\n      return record if not _.isArray( record )\n\n      hash = {}\n      hash[ @valueField ] = record[0]\n      hash[ @displayField ] = record[1] || record[0]\n\n      hash\n\n  getInputElement: ()->\n    @input ||= @$('select').eq(0)\n\n  afterRender: ()->\n    if @collection?.models?.length > 0\n      @populateOptions()\n    else\n      @collection?.trigger(\"reset\")\n\n  beforeFetch: ()->\n    @resetOptions()\n\n  change_handler: (e)->\n    @trigger \"on:change\", @, e\n\n  resetOptions: ()->\n    @getInputElement().html('')\n\n    if @allowMultiple\n      @getInputElement().attr(multiple: true)\n    else if @includeBlank\n      @getInputElement().append(\"<option value='#{ @blankValue }'>#{ @blankText }</option>\")\n\n  populateOptions: ()->\n    @resetOptions()\n\n    if @collection?.length > 0\n      if @sortOptionsBy?\n        models = @collection.sortBy (model)=>\n          if model.read?\n            model.read( @sortOptionsBy )\n          else\n            model.get( @sortOptionsBy )\n      else\n        models = @collection.models\n\n      for model in models\n        v = model.read?( @valueField ) || model.get(@valueField)\n        d = model.read?( @displayField ) || model.get(@displayField)\n\n        if @maxDisplayLength and @maxDisplayLength > 0\n          d = _.str.truncate(d, @maxDisplayLength)\n\n        selected = \"selected\" if @selected and v is @selected\n        option = \"<option #{ selected } value='#{ v }'>#{ d }</option>\"\n        @getInputElement().append( option )\n\n    @trigger \"after:populate:options\", @\n    @setValue( @currentValue )\n\nselectField.register()"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/text_area_field.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/text_area_field.coffee","type":"component_definition","starts_on_line":1,"class_name":"Luca.fields.TextAreaField","header_documentation":"","type_alias":"text_area_field","css_class_identifier":"luca-fields-text-area-field","defines_methods":{"initialize":{"defined_on_line":16,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"setValue":{"defined_on_line":35,"documentation":"","arguments":[{"argument":"value","value":null}]},"getValue":{"defined_on_line":38,"documentation":"","arguments":[]},"field":{"defined_on_line":41,"documentation":"","arguments":[]},"keyup_handler":{"defined_on_line":44,"documentation":"","arguments":[{"argument":"e","value":null}]},"blur_handler":{"defined_on_line":50,"documentation":"","arguments":[{"argument":"e","value":null}]},"focus_handler":{"defined_on_line":53,"documentation":"","arguments":[{"argument":"e","value":null}]},"change_handler":{"defined_on_line":56,"documentation":"","arguments":[{"argument":"e","value":null}]}},"defines_properties":{"autoBindEventHandlers":{"defined_on_line":4,"documentation":"","default":"true"},"events":{"defined_on_line":6,"documentation":"","default":null},"template":{"defined_on_line":10,"documentation":"","default":"'fields/text_area_field'"},"height":{"defined_on_line":12,"documentation":"","default":"\"200px\""},"width":{"defined_on_line":13,"documentation":"","default":"\"90%\""},"keyEventThrottle":{"defined_on_line":14,"documentation":"","default":"300"}},"source_file_contents":"textArea = Luca.register          \"Luca.fields.TextAreaField\"\ntextArea.extends                  \"Luca.core.Field\"\ntextArea.defines\n  autoBindEventHandlers: true\n\n  events:\n    \"blur textarea\" : \"blur_handler\"\n    \"focus textarea\" : \"focus_handler\"\n\n  template: 'fields/text_area_field'\n\n  height: \"200px\"\n  width: \"90%\"\n  keyEventThrottle: 300\n\n  initialize: (@options={})->\n\n    @input_id ||= _.uniqueId('field')\n    @input_name ||= @name\n    @label ||= @name\n    @input_class ||= @class\n    @input_value ||= \"\"\n    @inputStyles ||= \"height:#{ @height };width:#{ @width }\"\n    @placeHolder ||= \"\"\n\n    Luca.core.Field::initialize.apply @, arguments\n\n    if @enableKeyEvents is true\n      @keyup_handler = _.debounce(@keyup_handler, @keyEventThrottle || 10)\n\n      console.log \"Registering Key Events\"\n      @registerEvent(\"keyup textarea\",\"keyup_handler\")     \n      @registerEvent(\"keydown textarea\",\"keyup_handler\")     \n\n  setValue: (value)->\n    $( @field() ).val(value)\n\n  getValue: ()->\n    $( @field() ).val()\n\n  field: ()->\n    @input = @$(\"textarea\")\n\n  keyup_handler: (e)->\n    # TODO: Should ignore certain keyup events\n    # which would not indicate a change\n    @trigger \"on:change\", @, e\n    @trigger \"on:keyup\", @, e\n\n  blur_handler: (e)->\n    @trigger \"on:blur\", @, e\n\n  focus_handler: (e)->\n    @trigger \"on:focus\", @, e\n\n  change_handler: (e)-> \n    @trigger \"on:change\", @, e"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/text_field.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/text_field.coffee","type":"component_definition","starts_on_line":1,"class_name":"Luca.fields.TextField","header_documentation":"","type_alias":"text_field","css_class_identifier":"luca-fields-text-field","defines_methods":{"initialize":{"defined_on_line":18,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"keyup_handler":{"defined_on_line":43,"documentation":"","arguments":[{"argument":"e","value":null}]},"blur_handler":{"defined_on_line":49,"documentation":"","arguments":[{"argument":"e","value":null}]},"focus_handler":{"defined_on_line":52,"documentation":"","arguments":[{"argument":"e","value":null}]},"change_handler":{"defined_on_line":55,"documentation":"","arguments":[{"argument":"e","value":null}]}},"defines_properties":{"_inheritEvents":{"defined_on_line":5,"documentation":"","default":null},"template":{"defined_on_line":10,"documentation":"","default":"'fields/text_field'"},"autoBindEventHandlers":{"defined_on_line":12,"documentation":"","default":"true"},"send_blanks":{"defined_on_line":14,"documentation":"","default":"true"},"keyEventThrottle":{"defined_on_line":16,"documentation":"","default":"300"}},"source_file_contents":"textField = Luca.register     'Luca.fields.TextField'\ntextField.extends             'Luca.core.Field'\n\ntextField.defines\n  _inheritEvents:\n    \"blur input\" : \"blur_handler\"\n    \"focus input\" : \"focus_handler\"\n    \"change input\" : \"change_handler\"\n\n  template: 'fields/text_field'\n\n  autoBindEventHandlers: true\n\n  send_blanks: true\n\n  keyEventThrottle: 300\n\n  initialize: (@options={})->\n    if @enableKeyEvents\n      if @keyEventThrottle\n        @keyup_handler = _.debounce(@keyup_handler, @keyEventThrottle)\n        \n      @registerEvent(\"keyup input\",\"keyup_handler\")     \n\n    @input_id ||= _.uniqueId('field')\n    @input_name ||= @name\n    @label ||= @name\n    @input_class ||= @class\n    @input_value ||= @value || \"\" \n    \n    if @prepend\n      @$el.addClass 'input-prepend'\n      @addOn = @prepend\n\n    if @append\n      @$el.addClass 'input-append'\n      @addOn = @append\n\n    @placeHolder ||= \"\"\n\n    Luca.core.Field::initialize.apply @, arguments\n\n  keyup_handler: (e)->\n    # TODO: Should ignore certain keyup events\n    # which would not indicate a change\n    @trigger \"on:change\", @, e\n    @trigger \"on:keyup\", @, e\n\n  blur_handler: (e)->\n    @trigger \"on:blur\", @, e\n\n  focus_handler: (e)->\n    @trigger \"on:focus\", @, e\n\n  change_handler: (e)-> \n    @trigger \"on:change\", @, e\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/type_ahead_field.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/type_ahead_field.coffee","type":"component_definition","starts_on_line":1,"class_name":"Luca.fields.TypeAheadField","header_documentation":"","type_alias":"type_ahead_field","css_class_identifier":"luca-fields-type-ahead-field","defines_methods":{"getSource":{"defined_on_line":6,"documentation":"","arguments":[]},"matcher":{"defined_on_line":9,"documentation":"","arguments":[{"argument":"item","value":null}]},"beforeRender":{"defined_on_line":12,"documentation":"","arguments":[]},"afterRender":{"defined_on_line":16,"documentation":"","arguments":[]}},"defines_properties":{},"source_file_contents":"typeAheadField = Luca.register      \"Luca.fields.TypeAheadField\"\ntypeAheadField.extends              \"Luca.fields.TextField\" \n\n\ntypeAheadField.defines\n  getSource: ()->\n    Luca.util.read(@source) || []\n\n  matcher: (item)->\n    true\n\n  beforeRender: ()->\n    Luca.fields.TextField::beforeRender.apply(@, arguments)\n    @getInputElement().attr('data-provide','typeahead')\n\n  afterRender: ()->\n    Luca.fields.TextField::afterRender.apply(@, arguments)\n    @getInputElement().typeahead\n      matcher: @matcher\n      source: @getSource()"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/form_view.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/form_view.coffee","type":"component_definition","starts_on_line":7,"class_name":"Luca.components.FormView","header_documentation":"<p>The FormView component is a special container which provides functionality\naround the components inside which extend from the Luca.core.Field class.\nThe FormView component integrates well with Luca.Models and can control\nthe attributes on that model, respond to validations, and submit changes\nto an API.</p>\n","type_alias":"form_view","css_class_identifier":"luca-form-view","defines_methods":{"initialize":{"defined_on_line":110,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"onFieldChange":{"defined_on_line":138,"documentation":"","arguments":[{"argument":"field","value":null},{"argument":"e","value":null}]},"getDefaultToolbar":{"defined_on_line":142,"documentation":"","arguments":[]},"applyStyleClasses":{"defined_on_line":146,"documentation":"","arguments":[]},"applyBootstrapStyleClasses":{"defined_on_line":153,"documentation":"","arguments":[]},"resetHandler":{"defined_on_line":161,"documentation":"","arguments":[{"argument":"e","value":null}]},"submitHandler":{"defined_on_line":170,"documentation":"","arguments":[{"argument":"e","value":null}]},"afterComponents":{"defined_on_line":180,"documentation":"","arguments":[]},"eachField":{"defined_on_line":188,"documentation":"","arguments":[{"argument":"iterator","value":null}]},"getField":{"defined_on_line":191,"documentation":"","arguments":[{"argument":"name","value":null}]},"getFields":{"defined_on_line":197,"documentation":"","arguments":[{"argument":"attr","value":null},{"argument":"value","value":null}]},"loadModel":{"defined_on_line":208,"documentation":"","arguments":[{"argument":"model","value":null}]},"reset":{"defined_on_line":230,"documentation":"","arguments":[]},"clear":{"defined_on_line":233,"documentation":"","arguments":[]},"isDirty":{"defined_on_line":242,"documentation":"","arguments":[]},"setValues":{"defined_on_line":247,"documentation":"<p>set the values on the form\nwithout syncing</p>\n","arguments":[{"argument":"source","value":null},{"argument":"options","value":"{}"}]},"getValues":{"defined_on_line":270,"documentation":"<p>Public: returns a hash of values for the form fields in this view.</p>\n\n<p>options - An options Hash to control the behavior of values returned (default: {}):\nreject<em>blank: don&#39;t include values which are blank (default: true)\nskip</em>buttons: don&#39;t include button fields (default: true)\nblanks: an inverse alias for reject_blank (default: false)</p>\n","arguments":[{"argument":"options","value":"{}"}]},"removeErrors":{"defined_on_line":309,"documentation":"","arguments":[]},"displayErrors":{"defined_on_line":316,"documentation":"","arguments":[{"argument":"errors","value":null}]},"displayValidationErrorsMessage":{"defined_on_line":326,"documentation":"","arguments":[]},"submit_success_handler":{"defined_on_line":329,"documentation":"","arguments":[{"argument":"model","value":null},{"argument":"response","value":null},{"argument":"xhr","value":null}]},"submit_fatal_error_handler":{"defined_on_line":338,"documentation":"","arguments":[{"argument":"model","value":null},{"argument":"response","value":null},{"argument":"xhr","value":null}]},"submit":{"defined_on_line":348,"documentation":"","arguments":[{"argument":"save","value":"true"},{"argument":"saveOptions","value":"{}"}]},"hasModel":{"defined_on_line":359,"documentation":"","arguments":[]},"currentModel":{"defined_on_line":362,"documentation":"","arguments":[{"argument":"options","value":"{}"}]},"applyFormValuesToModel":{"defined_on_line":368,"documentation":"","arguments":[{"argument":"options","value":null}]},"setLegend":{"defined_on_line":371,"documentation":"","arguments":[{"argument":"@legend","value":null}]},"flash":{"defined_on_line":374,"documentation":"","arguments":[{"argument":"message","value":null}]},"successMessage":{"defined_on_line":382,"documentation":"","arguments":[{"argument":"message","value":null}]},"errorMessage":{"defined_on_line":389,"documentation":"","arguments":[{"argument":"message","value":null}]},"setupToolbar":{"defined_on_line":394,"documentation":"","arguments":[]}},"defines_properties":{"trackDirtyState":{"defined_on_line":35,"documentation":"<p>track dirty state will bind to change events\non all of the underlying fields, and set a\nflag whenever one of them changes</p>\n","default":"false"},"trackModelChanges":{"defined_on_line":38,"documentation":"<p>don&#39;t setup two way binding to the model</p>\n","default":"false"},"labelAlign":{"defined_on_line":42,"documentation":"<p>should the label display above, or to the\nside of the fields</p>\n","default":"undefined"},"fieldLayoutClass":{"defined_on_line":46,"documentation":"<p>specifying this class gives you the ability\nto layout the nested fields accordingly.</p>\n","default":"undefined"},"legend":{"defined_on_line":49,"documentation":"<p>should this form have a legend?</p>\n","default":"\"\""},"toolbar":{"defined_on_line":55,"documentation":"<p>available options are true, false, &quot;top&quot;, &quot;bottom&quot;, or &quot;both&quot;\nthe component configuration for the toolbar can be controlled\nby specifying a name of a property that contains a valid\ncomponent reference ( either hash w/ type reference )</p>\n","default":"true"},"toolbarConfig":{"defined_on_line":60,"documentation":"<p>the name of the property which contains the configuration\nfor the buttons that will go in this toolbar.  Specify\na string so it can be lazily evaluated at initialization.</p>\n","default":"undefined"},"defaultToolbar":{"defined_on_line":66,"documentation":"<p>the default toolbar definition that will be created if\nthe form is configured to have a toolbar on it.  this value\nwill be resolved at initialization, so pass a string identifying\nan object in memory.</p>\n","default":"\"Luca.components.FormView.defaultToolbar\""},"loadMask":{"defined_on_line":71,"documentation":"<p>if this form will be submitting values to a RESTful API and you\nwant to show a loading indicator or progress bar, configure the\n@loadMask property.</p>\n","default":"true"},"well":{"defined_on_line":75,"documentation":"<p>Applies the twitter bootstrap well class to this form.\n@$el.addClass(&#39;well&#39;) if @well</p>\n","default":"false"},"searchForm":{"defined_on_line":79,"documentation":"<p>Applies the twitter bootstrap form-search class to this form.\n@$el.addClass(&#39;form-search&#39;) if @searchForm</p>\n","default":"false"},"horizontalForm":{"defined_on_line":83,"documentation":"<p>Applies the twitter bootstrap horizontal form class to this form.\n@$el.addClass(&#39;form-horizontal&#39;) if @horizontalForm</p>\n","default":"false"},"inlineForm":{"defined_on_line":87,"documentation":"<p>Applies the twitter bootstrap inline form class to this form.\n@$el.addClass(&#39;form-inline&#39;) if @inlineForm</p>\n","default":"false"},"includeBlankValues":{"defined_on_line":91,"documentation":"<p>if we should always include blank values\nregardless of how the field is configured</p>\n","default":"undefined"},"tagName":{"defined_on_line":94,"documentation":"","default":"'form'"},"_inheritEvents":{"defined_on_line":99,"documentation":"<p>These events will get registered on the component\nbut still leave the @events property open to extend\nfor any component which inherits from us.</p>\n","default":null},"bodyClassName":{"defined_on_line":103,"documentation":"","default":"\"form-view-body\""},"stateful":{"defined_on_line":105,"documentation":"","default":null},"successFlashDelay":{"defined_on_line":380,"documentation":"","default":"1500"},"version":{"defined_on_line":420,"documentation":"","default":"2"}},"source_file_contents":"# The FormView component is a special container which provides functionality\n# around the components inside which extend from the Luca.core.Field class.\n#\n# The FormView component integrates well with Luca.Models and can control\n# the attributes on that model, respond to validations, and submit changes\n# to an API.\nformView = Luca.register        \"Luca.components.FormView\"\n\nformView.extends                \"Luca.Container\"\n\nformView.mixesIn                \"LoadMaskable\",\n                                \"FormModelBindings\"\n\nformView.triggers               \"before:submit\",\n                                \"before:reset\",\n                                \"before:load\",\n                                \"before:load:new\",\n                                \"before:load:existing\",\n                                \"after:submit\",\n                                \"after:reset\",\n                                \"after:load\",\n                                \"after:load:new\",\n                                \"after:load:existing\",\n                                \"after:submit:success\",\n                                \"after:submit:fatal_error\",\n                                \"after:submit:error\",\n                                \"state:change:dirty\"\n\n\n\nformView.publicConfiguration\n  # track dirty state will bind to change events\n  # on all of the underlying fields, and set a\n  # flag whenever one of them changes\n  trackDirtyState: false\n\n  # don't setup two way binding to the model\n  trackModelChanges: false\n\n  # should the label display above, or to the\n  # side of the fields\n  labelAlign: undefined\n\n  # specifying this class gives you the ability\n  # to layout the nested fields accordingly.\n  fieldLayoutClass: undefined\n\n  # should this form have a legend?\n  legend: \"\"\n\n  # available options are true, false, \"top\", \"bottom\", or \"both\"\n  # the component configuration for the toolbar can be controlled\n  # by specifying a name of a property that contains a valid\n  # component reference ( either hash w/ type reference )\n  toolbar: true\n\n  # the name of the property which contains the configuration\n  # for the buttons that will go in this toolbar.  Specify\n  # a string so it can be lazily evaluated at initialization.\n  toolbarConfig: undefined\n\n  # the default toolbar definition that will be created if\n  # the form is configured to have a toolbar on it.  this value\n  # will be resolved at initialization, so pass a string identifying\n  # an object in memory.\n  defaultToolbar: \"Luca.components.FormView.defaultToolbar\"\n\n  # if this form will be submitting values to a RESTful API and you\n  # want to show a loading indicator or progress bar, configure the\n  # @loadMask property.\n  loadMask: true\n\n  # Applies the twitter bootstrap well class to this form.\n  # @$el.addClass('well') if @well\n  well: false\n\n  # Applies the twitter bootstrap form-search class to this form.\n  # @$el.addClass('form-search') if @searchForm\n  searchForm: false\n\n  # Applies the twitter bootstrap horizontal form class to this form.\n  # @$el.addClass('form-horizontal') if @horizontalForm\n  horizontalForm: false\n\n  # Applies the twitter bootstrap inline form class to this form.\n  # @$el.addClass('form-inline') if @inlineForm\n  inlineForm: false\n\n  # if we should always include blank values\n  # regardless of how the field is configured\n  includeBlankValues: undefined\n\nformView.privateConfiguration\n  tagName: 'form'\n\n  # These events will get registered on the component\n  # but still leave the @events property open to extend\n  # for any component which inherits from us.\n  _inheritEvents:\n    \"click .submit-button\" : \"submitHandler\"\n    \"click .reset-button\" : \"resetHandler\"\n\n  bodyClassName: \"form-view-body\"\n\n  stateful:\n    dirty: false\n    currentModel: undefined\n\nformView.privateMethods\n  initialize: (@options={})->\n    form = @\n\n    @loadMask = Luca.config.enableBoostrap unless @loadMask?\n\n    Luca.Container::initialize.apply @, arguments\n\n    @components ||= @fields\n\n    _.bindAll @, \"submitHandler\", \"resetHandler\", \"renderToolbars\"\n\n    # have our events be internal to the view, and not\n    # part of the normal @events chain, so they can be inherited\n    for eventId, handler of @_inheritEvents\n      @registerEvent(eventId, handler)\n\n    if @trackDirtyState is true\n      @on \"after:components\", ()->\n        for field in @getFields()\n          field.on \"on:change\", @onFieldChange, form\n      , form\n\n    @setupHooks( @hooks )\n\n    @applyStyleClasses()\n\n    Luca.components.FormView.setupToolbar.call(@)\n\n  onFieldChange: (field, e)->\n    @trigger \"field:change\", field, e\n    @state.set('dirty', true)\n\n  getDefaultToolbar: ()->\n    config = @toolbarConfig || @defaultToolbar\n    Luca.util.resolve( Luca.util.read(config) )\n\n  applyStyleClasses: ()->\n    if Luca.config.enableBoostrap\n      @applyBootstrapStyleClasses()\n\n    @$el.addClass( \"label-align-#{ @labelAlign }\") if @labelAlign\n    @$el.addClass( @fieldLayoutClass ) if @fieldLayoutClass\n\n  applyBootstrapStyleClasses: ()->\n    @inlineForm = true if @labelAlign is \"left\"\n\n    @$el.addClass('well') if @well\n    @$el.addClass('form-search') if @searchForm\n    @$el.addClass('form-horizontal') if @horizontalForm\n    @$el.addClass('form-inline') if @inlineForm\n\n  resetHandler: (e)->\n    me = my = $( e?.target )\n    if @beforeReset?\n      result = @beforeReset()\n      return if result is false\n\n    @reset()\n    @trigger \"after:reset\", @\n\n  submitHandler: (e)->\n    if @beforeSubmit?\n      result = @beforeSubmit()\n      return if result is false\n    else\n      @trigger \"before:submit\", @\n\n    @trigger \"enable:loadmask\", @ if @loadMask is true\n    @submit() if @hasModel()\n\n  afterComponents: ()->\n    Luca.Container::afterComponents?.apply(@, arguments)\n\n    form = @\n    @eachField (field)->\n      field.getForm = ()=> form\n      field.getModel = ()=> form.currentModel()\n\n  eachField: (iterator)->\n    _( @getFields() ).map( iterator )\n\n  getField: (name)->\n    passOne = _( @getFields('name', name) ).first()\n    return passOne if passOne?\n\n    _( @getFields('input_name', name) ).first()\n\n  getFields: (attr,value)->\n    fields = @selectByAttribute(\"isField\", true, true)\n\n    if attr? and value?\n      fields = _(fields).select (field)->\n        property  = field[ attr ]\n        property  = property.call(field) if _.isFunction(property)\n        property is value\n\n    fields\n\n  loadModel: (model)->\n    form = @\n    fields = @getFields()\n\n    @state.set('dirty', false)\n\n    @trigger \"before:load\", @, model\n\n    if model\n      model.beforeFormLoad?.apply(model, @)\n      event = \"before:load:#{ (if model.isNew() then \"new\" else \"existing\")}\"\n      @trigger event, @, model\n\n    @state.set('currentModel', model)\n\n    @setValues(model || {}, silent: true)\n\n    @trigger \"after:load\", @, model\n\n    if model\n      @trigger \"after:load:#{ (if model.isNew() then \"new\" else \"existing\")}\", @, model\n\n  reset: ()->\n    @loadModel( @state.get('currentModel') )\n\n  clear: ()->\n    @state.set('currentModel', @defaultModel?() )\n\n    _( @getFields() ).each (field)=>\n      try\n        field.setValue('')\n      catch e\n        console.log \"Error Clearing\", @, field\n\n  isDirty: ()->\n    !!@state.get('dirty')\n\n  # set the values on the form\n  # without syncing\n  setValues: (source, options={})->\n    source ||= @currentModel()\n    fields = @getFields()\n\n    _( fields ).each (field) =>\n      field_name = field.input_name || field.name\n\n      if source?[field_name]\n        value = Luca.util.read( source[field_name] )\n\n      if !value and Luca.isBackboneModel(source)\n        value = source.get(field_name)\n\n      field?.setValue( value ) unless field.readOnly is true\n\n    @applyFormValuesToModel() unless options.silent? is true\n\n  # Public: returns a hash of values for the form fields in this view.\n  #\n  # options - An options Hash to control the behavior of values returned (default: {}):\n  #           reject_blank: don't include values which are blank (default: true)\n  #           skip_buttons: don't include button fields (default: true)\n  #           blanks: an inverse alias for reject_blank (default: false)\n  getValues: (options={})->\n    options.reject_blank = true unless options.reject_blank?\n    options.skip_buttons = true unless options.skip_buttons?\n    options.reject_blank = true if options.blanks is false\n\n    values = _( @getFields() ).inject (memo,field)=>\n      value   = field.getValue()\n      key     = field.input_name || field.name\n\n      valueIsBlank      = !!(_.str.isBlank( value ) || _.isUndefined( value ))\n\n      allowBlankValues  = not options.reject_blank and not field.send_blanks\n      allowBlankValues = true if field.includeBlank is true or @includeBlankValues is true\n\n\n      if options.debug\n        console.log \"#{ key } Options\", options, \"Value\", value, \"Value Is Blank?\", valueIsBlank, \"Allow Blanks?\", allowBlankValues\n\n      if options.skip_buttons and field.isButton\n        skip = true\n      else\n        if valueIsBlank and allowBlankValues is false\n          skip = true\n\n        if field.input_name is \"id\" and valueIsBlank is true\n          skip = true\n\n      if options.debug\n        console.log \"Skip is true on #{ key }\"\n\n      if skip isnt true\n        memo[ key ] = value\n\n      memo\n\n    , (options.defaults || {})\n\n    values\n\n  removeErrors: ()->\n    @$('.alert.alert-error').remove()\n    @$el.removeClass('error')\n\n    for field in @getFields()\n      field.clearErrors()\n\n  displayErrors: (errors)->\n    has_errors = false\n    for field in @getFields()\n      for field_name, field_errors of errors when field_name is field.input_name\n        field.displayErrors(field_errors)\n        has_errors = true\n\n    if has_errors\n      @$el.addClass('error')\n\n  displayValidationErrorsMessage: ()->\n    @errorMessage('Please fix the fields with errors')\n\n  submit_success_handler: (model, response, xhr)->\n    @trigger \"after:submit\", @, model, response\n    @trigger \"disable:loadmask\", @ if @loadMask is true\n\n    if response and response?.success is true\n      @trigger \"after:submit:success\", @, model, response\n    else\n      @trigger \"after:submit:error\", @, model, response\n\n  submit_fatal_error_handler: (model, response, xhr)->\n    @trigger \"after:submit\", @, model, response\n    @trigger \"after:submit:fatal_error\", @, model, response\n\n    try\n      json = $.parseJSON(response.responseText)\n      if !json.success && json.errors?\n        @displayValidationErrorsMessage()\n        @displayErrors(json.errors)\n\n  submit: (save=true, saveOptions={})->\n    _.bindAll @, \"submit_success_handler\", \"submit_fatal_error_handler\"\n\n    saveOptions.success ||= @submit_success_handler\n    saveOptions.error ||= @submit_fatal_error_handler\n\n    @removeErrors()\n    @applyFormValuesToModel()\n    return unless save\n    @currentModel()?.save( @currentModel().toJSON(), saveOptions )\n\n  hasModel: ()->\n    @currentModel()?\n\n  currentModel: (options={})->\n    if options is true or options?.refresh is true\n      @applyFormValuesToModel()\n\n    @state.get('currentModel')\n\n  applyFormValuesToModel: (options)->\n    @currentModel()?.set( @getValues(), options )\n\n  setLegend: (@legend)->\n    $('fieldset legend', @el).first().html(@legend)\n\n  flash: (message)->\n    if @$('.toolbar-container.top').length > 0\n      @$('.toolbar-container.top').after(message)\n    else\n      @$bodyEl().prepend(message)\n\n  successFlashDelay: 1500\n\n  successMessage: (message)->\n    @$('.alert.alert-success').remove()\n    @flash Luca.template(\"components/form_alert\", className:\"alert alert-success\", message: message)\n    _.delay ()=>\n      @$('.alert.alert-success').fadeOut()\n    , @successFlashDelay || 0\n\n  errorMessage: (message)->\n    @$('.alert.alert-error').remove()\n    @flash Luca.template(\"components/form_alert\", className:\"alert alert-error\", message: message)\n\nformView.classInterface\n  setupToolbar: ()->\n    if @toolbar isnt false and (not @topToolbar and not @bottomToolbar)\n      if @toolbar is \"both\" or @toolbar is \"top\"\n        @topToolbar = _.clone( @getDefaultToolbar() )\n\n      unless @toolbar is \"top\"\n        @bottomToolbar = _.clone( @getDefaultToolbar() )\n\n  defaultToolbar:\n    buttons:[\n      icon:\"remove-sign\"\n      label: \"Reset\"\n      eventId: \"click:reset\"\n      className:\"reset-button\"\n      align: 'right'\n    ,\n      icon:\"ok-sign\"\n      white: true\n      label: \"Save Changes\"\n      eventId: \"click:submit\"\n      color: \"success\"\n      className: 'submit-button'\n      align: 'right'\n    ]\n\nformView.defines\n  version: 2\n\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/grid_layout_view.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/grid_layout_view.coffee","type":"component_definition","starts_on_line":1,"class_name":"Luca.components.GridLayoutView","header_documentation":"","type_alias":"grid_layout_view","css_class_identifier":"luca-grid-layout-view","defines_methods":{"attributesForItem":{"defined_on_line":19,"documentation":"<p>adds the bootstrap span class to each collection-item,\nwhere span class is equal to the 12 column grid / @itemsPerRow.\nfor example, each item would receive a span4 class when @itemsPerRow = 3</p>\n","arguments":[]},"renderModels":{"defined_on_line":29,"documentation":"<p>wraps every N number of rows, where N = @itemsPerRow\nin a row-fluid wrapper, and appends it to the view</p>\n","arguments":[{"argument":"models","value":null}]}},"defines_properties":{"itemsPerRow":{"defined_on_line":8,"documentation":"<p>how many items do you wish to render per row?\nassuming a 12 column grid, each item will receive\nan equal amount of grid span/columns.</p>\n","default":"3"},"className":{"defined_on_line":11,"documentation":"","default":"\"grid-layout-view\""},"tagName":{"defined_on_line":12,"documentation":"","default":"\"div\""},"itemTagName":{"defined_on_line":13,"documentation":"","default":"\"div\""}},"source_file_contents":"gridView = Luca.register    \"Luca.components.GridLayoutView\"\ngridView.extends            \"Luca.CollectionView\"\n\ngridView.publicConfiguration\n  # how many items do you wish to render per row?\n  # assuming a 12 column grid, each item will receive\n  # an equal amount of grid span/columns.\n  itemsPerRow: 3\n\ngridView.privateConfiguration\n  className: \"grid-layout-view\"\n  tagName: \"div\"\n  itemTagName: \"div\"\n\ngridView.privateMethods\n  # adds the bootstrap span class to each collection-item,\n  # where span class is equal to the 12 column grid / @itemsPerRow.\n  # for example, each item would receive a span4 class when @itemsPerRow = 3\n  attributesForItem: ()->\n    base = Luca.CollectionView::attributesForItem.apply(@, arguments)\n    @itemsPerRow = 3 unless _.isNumber(@itemsPerRow) and @itemsPerRow > 1\n    columns = parseInt(12 / @itemsPerRow)\n    base.class += \" span#{ columns }\"\n\n    base\n\n  # wraps every N number of rows, where N = @itemsPerRow\n  # in a row-fluid wrapper, and appends it to the view\n  renderModels: (models)->\n    index = 0\n    rowIndex = 0\n\n    rows = for model in models\n      row = @make(\"div\", class:\"row-fluid\") if rowIndex++ is 0\n      $(row).append @makeItem(model,index++)\n      rowIndex = 0 if index > 0 and index % @itemsPerRow is 0\n      row\n\n    for row in rows\n      @$append(row) \n\ngridView.register()\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/load_mask.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/load_mask.coffee","type":"component_definition","starts_on_line":2,"class_name":"Luca.components.LoadMask","header_documentation":"<p>#_.def(&quot;Luca.components.LoadMask&quot;).extends(&quot;Luca.View&quot;).with</p>\n","type_alias":"load_mask","css_class_identifier":"luca-load-mask","defines_methods":{},"defines_properties":{"className":{"defined_on_line":7,"documentation":"","default":"\"luca-ui-load-mask\""},"bodyTemplate":{"defined_on_line":8,"documentation":"","default":"\"components/load_mask\""}},"source_file_contents":"#_.def(\"Luca.components.LoadMask\").extends(\"Luca.View\").with\nloadMask = Luca.register  \"Luca.components.LoadMask\"\n\nloadMask.extends          \"Luca.View\"\n\nloadMask.defines\n  className: \"luca-ui-load-mask\"\n  bodyTemplate:\"components/load_mask\"\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/multi_collection_view.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/multi_collection_view.coffee","type":"component_definition","starts_on_line":1,"class_name":"Luca.components.MultiCollectionView","header_documentation":"","type_alias":"multi_collection_view","css_class_identifier":"luca-multi-collection-view","defines_methods":{"initialize":{"defined_on_line":42,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"relayAfterRefresh":{"defined_on_line":54,"documentation":"","arguments":[{"argument":"models","value":null},{"argument":"query","value":null},{"argument":"options","value":null}]},"refresh":{"defined_on_line":57,"documentation":"","arguments":[]},"propagateCollectionComponents":{"defined_on_line":61,"documentation":"","arguments":[]},"validateComponent":{"defined_on_line":81,"documentation":"","arguments":[{"argument":"component","value":null}]}},"defines_properties":{"stateful":{"defined_on_line":39,"documentation":"","default":null},"version":{"defined_on_line":92,"documentation":"","default":"3"}},"source_file_contents":"multiView = Luca.register     \"Luca.components.MultiCollectionView\"\n\n# The CollectionMultiView is a collection view with multiple renderings\n# of the list.  ( e.g. Icons, Table, List ).  It works by maintaining\n# a current view, and rendering that view.  It refreshes the views\n# whenever they are activated. \n#\n# The MultiView allows you to share one collection, filter, pagination setup\n# but render multiple versions of a model.  To do this, you  are expected to\n# define one or more objects in the @views property of the component.\n\n# Example:\n#   multiView = new Luca.components.MultiCollectionView\n#     collection: \"my_collection\"\n#     paginatable:\n#       page: 1\n#       limit: 20\n#     views:[\n#       type:           \"table\"\n#       columns:[\n#         header: \"Header\"\n#         reader: \"attribute\"\n#       ]\n#     ]\nmultiView.extends           \"Luca.containers.CardView\"\n\nmultiView.mixesIn           \"QueryCollectionBindings\", \n                            \"LoadMaskable\",\n                            \"Filterable\",\n                            \"Paginatable\",\n                            \"Sortable\"\n\nmultiView.triggers          \"before:refresh\",\n                            \"after:refresh\",\n                            \"refresh\",\n                            \"empty:results\"\n\nmultiView.private\n  stateful:\n    activeView: 0\n\n  initialize: (@options={})->\n    @components ||= @views\n\n    for view in @components    \n      Luca.components.MultiCollectionView.validateComponent( view ) \n\n    Luca.containers.CardView::initialize.apply(@, arguments) \n\n    @on \"data:refresh\", @refresh, @\n    @on \"after:card:switch\", @refresh, @\n    @on \"after:components\", Luca.components.MultiCollectionView.propagateCollectionComponents, @\n\n  relayAfterRefresh: (models,query,options)->\n    @trigger \"after:refresh\", models, query, options\n\n  refresh: ()->\n    @activeComponent()?.refresh()\n\nmultiView.classMethods\n  propagateCollectionComponents: ()->\n    container = @\n\n    # in the multi view will share the same\n    # collection, filter state, pagination options, etc\n    for component in @components\n\n      component.on \"after:refresh\", (models,query,options)=> \n        @debug \"collection member after refresh\"\n        @trigger(\"after:refresh\",models,query,options)\n\n      _.extend component, \n        collection: container.getCollection() \n        getQuery: _.bind(container.getQuery, container)\n        getQueryOptions: _.bind(container.getQueryOptions, container)\n\n      if container.prepareQuery?\n        _.extend component,\n          prepareQuery: _.bind(container.prepareQuery, container)\n\n  validateComponent: (component)->\n    type = (component.type || component.ctype)\n\n    return if  type is \"collection\" or \n               type is \"collection_view\" or\n               type is \"table\" or\n               type is \"table_view\" \n\n    throw \"The MultiCollectionView expects to contain multiple collection views\" \n\nmultiView.defines\n  version: 3\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/nav_bar.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/nav_bar.coffee","type":"component_definition","starts_on_line":25,"class_name":"Luca.components.NavBar","header_documentation":"<p>A Twitter Bootstrap compatible navigation bar.  The Luca.Application\nand Luca.containers.Viewport class both have configuration options for\ncreating navbar components in the header and footer of the viewport.</p>\n\n<h4>Example of an Application with a Navbar</h4>\n\n<h5>Component Definition</h5>\n\n<pre><code>  # Navigation Component\n  navBar = Luca.register  &quot;App.views.TopNavigation&quot;\n  navBar.extends          &quot;Luca.components.NavBar&quot;\n  navBar.defines\n    brand: &quot;My App&quot;\n    # for white on black\n    inverse: true\n</code></pre>\n\n<p>We are able to reference the component we just defined in the\nconfiguration of the Application, simply by using it&#39;s \ntype alias <code>top_navigation</code>\n      # Application Component\n      app = Luca.register       &quot;App.Application&quot;\n      app.extends               &quot;Luca.Application&quot;\n      app.defines\n        topNav: &quot;top_navigation&quot;</p>\n","type_alias":"nav_bar","css_class_identifier":"luca-nav-bar","defines_methods":{"beforeRender":{"defined_on_line":54,"documentation":"","arguments":[]},"render":{"defined_on_line":70,"documentation":"","arguments":[]},"navContainer":{"defined_on_line":73,"documentation":"","arguments":[]},"content":{"defined_on_line":76,"documentation":"","arguments":[]}},"defines_properties":{"fixed":{"defined_on_line":31,"documentation":"<p>Specify whether the navbar is supposed to be fixed\nthe way Twitter bootstrap navbar can be.</p>\n","default":"true"},"position":{"defined_on_line":34,"documentation":"<p>Valid options are &#39;top&#39;, &#39;bottom&#39;.  Only valid when <code>@fixed is true</code></p>\n","default":"'top'"},"fluid":{"defined_on_line":38,"documentation":"<p>Specify whether the navbar should use the fluid grid.\nUsually the same as your Viewport setting.</p>\n","default":"undefined"},"brand":{"defined_on_line":42,"documentation":"<p>What content do you want to show in the logo area of the\nstandard bootstrap nav</p>\n","default":"\"Luca.js\""},"template":{"defined_on_line":47,"documentation":"<p>Specifies an optional template to use for the navigation menu\ncontent.  Whatever you specify will be rendered inside of the\ncollapsible container inside of the standard bootstrap nav.</p>\n","default":"undefined"},"className":{"defined_on_line":50,"documentation":"","default":"'navbar'"},"bodyTemplate":{"defined_on_line":51,"documentation":"","default":"'nav_bar'"},"bodyClassName":{"defined_on_line":52,"documentation":"","default":"'luca-ui-navbar-body'"}},"source_file_contents":"# A Twitter Bootstrap compatible navigation bar.  The Luca.Application\n# and Luca.containers.Viewport class both have configuration options for\n# creating navbar components in the header and footer of the viewport.\n#\n# #### Example of an Application with a Navbar\n# ##### Component Definition\n#       # Navigation Component\n#       navBar = Luca.register  \"App.views.TopNavigation\"\n#       navBar.extends          \"Luca.components.NavBar\"\n#       navBar.defines\n#         brand: \"My App\"\n#         # for white on black\n#         inverse: true\n#\n# We are able to reference the component we just defined in the\n# configuration of the Application, simply by using it's \n# type alias `top_navigation`\n#\n#       # Application Component\n#       app = Luca.register       \"App.Application\"\n#       app.extends               \"Luca.Application\"\n#       app.defines\n#         topNav: \"top_navigation\"\n#\nnavBar = Luca.register \"Luca.components.NavBar\"\nnavBar.extends         \"Luca.View\"\n\nnavBar.publicConfiguration\n  # Specify whether the navbar is supposed to be fixed\n  # the way Twitter bootstrap navbar can be.\n  fixed: true\n\n  # Valid options are 'top', 'bottom'.  Only valid when `@fixed is true`\n  position: 'top'\n\n  # Specify whether the navbar should use the fluid grid. \n  # Usually the same as your Viewport setting.\n  fluid: undefined\n\n  # What content do you want to show in the logo area of the\n  # standard bootstrap nav\n  brand: \"Luca.js\"\n\n  # Specifies an optional template to use for the navigation menu\n  # content.  Whatever you specify will be rendered inside of the \n  # collapsible container inside of the standard bootstrap nav.\n  template: undefined\n\nnavBar.privateConfiguration\n  className: 'navbar'\n  bodyTemplate: 'nav_bar'\n  bodyClassName: 'luca-ui-navbar-body'\n\n  beforeRender: ()->\n    @$el.addClass \"navbar-fixed-#{ @position }\" if @fixed\n    @$el.addClass \"navbar-inverse\" if @inverse is true\n\n    if @brand?\n      @$('.brand').attr('href', @homeLink || '#')\n      @$('.brand').html(@brand)\n\n    if @template\n      @navContainer().html Luca.template(@template, @)\n\n    if !!(@fluid || Luca.getApplication()?.fluid)\n      @content().addClass( Luca.config.fluidWrapperClass )\n    else\n      @content().addClass( Luca.config.wrapperClass )\n\n  render: ()->\n    @\n\n  navContainer: ()->\n    @$('.luca-ui-navbar-body .nav-collapse')\n\n  content: ()->\n    @$('.luca-ui-navbar-body').eq(0)\n\n\nnavBar.register()"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/page.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/page.coffee","type":"component_definition","starts_on_line":21,"class_name":"Luca.components.Page","header_documentation":"<p>The <code>Page</code> is a type of <code>Container</code> that has\nall of its subcomponents visible at one time, \nand assigned to various <code>@regions</code> that exist\nin the <code>@layout</code> template which provide its \ninternal dom structure.</p>\n\n<h4>Example Template (haml):</h4>\n\n<pre><code>  .page.layout.row-fluid{&quot;data-layout&quot;=&gt;&quot;layouts/left_nav_grid&quot;}\n    .span3.region{&quot;data-region&quot;=&gt;&quot;left&quot;}\n    .span9.region{&quot;data-region&quot;=&gt;&quot;right&quot;}\n</code></pre>\n\n<h3>Example Page Configuration</h3>\n\n<pre><code>page = new Luca.components.Page\n  layout: &quot;layouts/left_nav_grid&quot;\n  regions:\n    left: \n      type: &quot;navigation&quot;\n    right:\n      type: &quot;details&quot;\n</code></pre>\n","type_alias":"page","css_class_identifier":"luca-page","defines_methods":{"initialize":{"defined_on_line":26,"documentation":"<p><code>Page</code>s are typically instantiated by a <code>Luca.components.Controller</code></p>\n","arguments":[{"argument":"@options","value":"{}"}]},"assignComponentsToRegions":{"defined_on_line":34,"documentation":"<p>Takes the configuration specified in @regions\nand creates a components hash out of them.</p>\n","arguments":[]}},"defines_properties":{"layout":{"defined_on_line":54,"documentation":"","default":"undefined"},"regions":{"defined_on_line":68,"documentation":"<p>The @regions property assigns containers ( by their type alias )\nto DOM elements identified as regions within a layout template.</p>\n\n<h4>Example:</h4>\n\n<p>new Luca.components.Page\nregions:\nleft: &quot;my<em>component&quot;\nright:\ntype: &quot;my</em>other<em>component&quot;\nrole: &quot;component</em>role&quot;</p>\n\n<p>This will render an instance of MyComponent to this\npage&#39;s @$(&#39;[data-region-id=&quot;right&quot;]&#39;) DOM element.</p>\n","default":"{}"}},"source_file_contents":"# The `Page` is a type of `Container` that has\n# all of its subcomponents visible at one time, \n# and assigned to various `@regions` that exist\n# in the `@layout` template which provide its \n# internal dom structure.\n#\n# #### Example Template (haml):\n#       .page.layout.row-fluid{\"data-layout\"=>\"layouts/left_nav_grid\"}\n#         .span3.region{\"data-region\"=>\"left\"}\n#         .span9.region{\"data-region\"=>\"right\"}\n#\n# ### Example Page Configuration\n#     page = new Luca.components.Page\n#       layout: \"layouts/left_nav_grid\"\n#       regions:\n#         left: \n#           type: \"navigation\"\n#         right:\n#           type: \"details\"\n#\npage = Luca.register       \"Luca.components.Page\"\npage.extends               \"Luca.Container\"\n\npage.privateMethods\n  # `Page`s are typically instantiated by a `Luca.components.Controller`\n  initialize: (@options={})->\n    @assignComponentsToRegions()\n    @bodyTemplate = @options.layout || @layout\n    @bodyTemplate ||= @options.template || @template\n    Luca.Container::initialize.apply(@, arguments)\n\n  # Takes the configuration specified in @regions\n  # and creates a components hash out of them.\n  assignComponentsToRegions: ()->\n    @components ||= []\n\n    assigned = for regionId, regionAssignment of @regions\n      if _.isString(regionAssignment) and componentClass = Luca.registry.lookup( regionAssignment )\n        regionAssignment = \n          component: regionAssignment\n      else if _.isString(regionAssignment) and Luca.template(regionAssignment)\n        regionAssignment = \n          bodyTemplate: regionAssignment\n\n      _.extend(regionAssignment, container: \"[data-region='#{ regionId }']\")\n\n    @components = assigned\n\npage.publicConfiguration\n  # The `@layout` property is the equivalent to specifying @bodyTemplate\n  # but more semantic.  A `@layout` template is expected to contain DOM \n  # elements with a data attribute named `region` on it.  \n\n  layout: undefined\n  # The @regions property assigns containers ( by their type alias )\n  # to DOM elements identified as regions within a layout template.\n  #\n  # #### Example:\n  #     new Luca.components.Page\n  #       regions: \n  #         left: \"my_component\"\n  #         right: \n  #           type: \"my_other_component\"\n  #           role: \"component_role\"\n  #\n  #   This will render an instance of MyComponent to this\n  #   page's @$('[data-region-id=\"right\"]') DOM element.\n  regions: {}\n\npage.register()\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/pagination_control.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/pagination_control.coffee","type":"component_definition","starts_on_line":1,"class_name":"Luca.components.PaginationControl","header_documentation":"","type_alias":"pagination_control","css_class_identifier":"luca-pagination-control","defines_methods":{"onPageCountChange":{"defined_on_line":20,"documentation":"","arguments":[]},"limit":{"defined_on_line":23,"documentation":"","arguments":[]},"page":{"defined_on_line":26,"documentation":"","arguments":[]},"nextPage":{"defined_on_line":29,"documentation":"","arguments":[]},"previousPage":{"defined_on_line":33,"documentation":"","arguments":[]},"selectPage":{"defined_on_line":37,"documentation":"","arguments":[{"argument":"e","value":null}]},"setPage":{"defined_on_line":46,"documentation":"","arguments":[{"argument":"page","value":"1"},{"argument":"options","value":"{}"}]},"setLimit":{"defined_on_line":49,"documentation":"","arguments":[{"argument":"limit","value":"1"},{"argument":"options","value":"{}"}]},"pageButtonContainer":{"defined_on_line":52,"documentation":"","arguments":[]},"previousEnabled":{"defined_on_line":55,"documentation":"","arguments":[]},"nextEnabled":{"defined_on_line":58,"documentation":"","arguments":[]},"previousButton":{"defined_on_line":61,"documentation":"","arguments":[]},"nextButton":{"defined_on_line":64,"documentation":"","arguments":[]},"pageButtons":{"defined_on_line":67,"documentation":"","arguments":[]},"updateWithPageCount":{"defined_on_line":70,"documentation":"","arguments":[{"argument":"@pageCount","value":null},{"argument":"models","value":"[]"}]},"toggleNavigationButtons":{"defined_on_line":85,"documentation":"","arguments":[]},"selectActivePageButton":{"defined_on_line":90,"documentation":"","arguments":[]},"activePageButton":{"defined_on_line":93,"documentation":"","arguments":[]},"totalPages":{"defined_on_line":96,"documentation":"","arguments":[]},"totalItems":{"defined_on_line":99,"documentation":"","arguments":[]},"itemsPerPage":{"defined_on_line":102,"documentation":"","arguments":[{"argument":"value","value":null},{"argument":"options","value":"{}"}]}},"defines_properties":{"template":{"defined_on_line":6,"documentation":"","default":"\"components/pagination\""},"stateful":{"defined_on_line":8,"documentation":"","default":"true"},"stateChangeEvents":{"defined_on_line":10,"documentation":"","default":null},"autoBindEventHandlers":{"defined_on_line":13,"documentation":"","default":"true"},"events":{"defined_on_line":15,"documentation":"","default":null}},"source_file_contents":"paginationControl = Luca.register   \"Luca.components.PaginationControl\"\n\npaginationControl.extends           \"Luca.View\"\n\npaginationControl.defines\n  template: \"components/pagination\"\n\n  stateful: true\n\n  stateChangeEvents:\n    \"numberOfPages\" : \"onPageCountChange\"\n\n  autoBindEventHandlers: true\n\n  events:\n    \"click a[data-page-number]\" : \"selectPage\"\n    \"click a.next\"              : \"nextPage\"\n    \"click a.prev\"              : \"previousPage\"\n\n  onPageCountChange: ()->\n    @updateWithPageCount( @get('numberOfPages') )\n\n  limit: ()->\n    parseInt (@get('limit') || @collection?.length)\n\n  page: ()->\n    parseInt (@get('page') || 1)\n\n  nextPage: ()->\n    return unless @nextEnabled()\n    @set('page', @page() + 1 )\n\n  previousPage: ()->\n    return unless @previousEnabled()\n    @set('page', @page() - 1 )\n\n  selectPage: (e)->\n    me = my = @$( e.target )\n    me = my = my.closest('a.page') unless me.is('a.page')\n\n    my.siblings().removeClass('is-selected')\n    me.addClass('is-selected')\n\n    @setPage( my.data('page-number') )\n\n  setPage: (page=1,options={})->\n    @set('page', page, options)\n\n  setLimit: (limit=1,options={})->\n    @set('limit', limit, options)\n\n  pageButtonContainer: ()->\n    @$ '.group'\n\n  previousEnabled: ()->\n    @page() > 1\n\n  nextEnabled: ()->\n    @page() < @totalPages()\n\n  previousButton: ()->\n    @$ 'a.page.prev'\n\n  nextButton: ()->\n    @$ 'a.page.next'\n\n  pageButtons: ()->\n    @$ 'a[data-page-number]', @pageButtonContainer()\n\n  updateWithPageCount: (@pageCount, models=[])->\n    modelCount = models.length\n\n    @pageButtonContainer().empty()\n\n    _( @pageCount ).times (index)=>\n      page = index + 1\n      button = @make(\"a\",\"data-page-number\":page, class:\"page\", page )\n      @pageButtonContainer().append(button)\n\n    @toggleNavigationButtons()\n    @selectActivePageButton()\n\n    @\n\n  toggleNavigationButtons: ()->\n    @$('a.next, a.prev').addClass('disabled')\n    @nextButton().removeClass('disabled') if @nextEnabled()\n    @previousButton().removeClass('disabled') if @previousEnabled()\n\n  selectActivePageButton: ()->\n    @activePageButton().addClass('is-selected')\n\n  activePageButton: ()->\n    @pageButtons().filter(\"[data-page-number='#{ @page() }']\")\n\n  totalPages: ()->\n    @pageCount\n\n  totalItems: ()->\n    parseInt @collection?.length || 0\n\n  itemsPerPage: (value, options={})->\n    @set(\"limit\", value, options) if value?\n    parseInt @get(\"limit\")\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/router.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/router.coffee","type":"component_definition","starts_on_line":2,"class_name":"Luca.Router","header_documentation":"<p>#_.def(&quot;Luca.Router&quot;).extends(&quot;Backbone.Router&quot;).with</p>\n","type_alias":"router","css_class_identifier":"luca-router","defines_methods":{"initialize":{"defined_on_line":8,"documentation":"","arguments":[{"argument":"@options","value":null}]},"navigate":{"defined_on_line":26,"documentation":"<p>Intercept calls to Backbone.Router.navigate so that we can at least\nbuild a path from the route, even if we don&#39;t trigger the route handler</p>\n","arguments":[{"argument":"route","value":null},{"argument":"triggerRoute","value":"false"}]},"buildPathFrom":{"defined_on_line":34,"documentation":"<p>given a url fragment, construct an argument chain similar to what would be\nemitted from a normal route:#{ name } event that gets triggered\nwhen a route is actually fired.  This is used to trap route changes that happen\nthrough calls to @navigate()</p>\n","arguments":[{"argument":"matchedRoute","value":null}]}},"defines_properties":{"routes":{"defined_on_line":5,"documentation":"","default":null}},"source_file_contents":"#_.def(\"Luca.Router\").extends(\"Backbone.Router\").with\nrouter = Luca.register  \"Luca.Router\"\nrouter.extends          \"Backbone.Router\"\nrouter.defines\n  routes:\n    \"\" : \"default\"\n\n  initialize: (@options)->\n    _.extend @, @options\n\n    @routeHandlers = _( @routes ).values()\n\n    # when a route handler is fired, the route:route_name event is triggered by the router\n    # unfortunately this doesn't apply to calls to @navigate() so we override Backbone.Router.navigate\n    # and trigger an event separately.\n    _( @routeHandlers ).each (route_id) =>\n      @bind \"route:#{ route_id }\", ()=>\n        @trigger.apply @, [\"change:navigation\", route_id  ].concat( _( arguments ).flatten() )\n\n    Backbone.Router.initialize?.apply(@, arguments)\n\n  #### Router Functions\n\n  # Intercept calls to Backbone.Router.navigate so that we can at least\n  # build a path from the route, even if we don't trigger the route handler\n  navigate: (route, triggerRoute=false)->\n    Backbone.Router.prototype.navigate.apply @, arguments\n    @buildPathFrom( Backbone.history.getFragment() )\n\n  # given a url fragment, construct an argument chain similar to what would be\n  # emitted from a normal route:#{ name } event that gets triggered\n  # when a route is actually fired.  This is used to trap route changes that happen\n  # through calls to @navigate()\n  buildPathFrom: (matchedRoute)->\n    _(@routes).each (route_id, route)=>\n      regex = @_routeToRegExp(route)\n      if regex.test(matchedRoute)\n        args = @_extractParameters(regex, matchedRoute)\n        @trigger.apply @, [\"change:navigation\", route_id].concat( args )\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/simple_collection_view.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/simple_collection_view.coffee","type":"component_definition","starts_on_line":3,"class_name":"Luca.components.SimpleCollectionView","header_documentation":"<p>The SimpleCollectionView class is a CollectionView without any of the\nbells and whistles ( filtering, pagination, sorting, etc )</p>\n","type_alias":"simple_collection_view","css_class_identifier":"luca-simple-collection-view","defines_methods":{},"defines_properties":{"filterable":{"defined_on_line":7,"documentation":"","default":"false"},"paginatable":{"defined_on_line":8,"documentation":"","default":"false"},"sortable":{"defined_on_line":9,"documentation":"","default":"false"},"loadMask":{"defined_on_line":10,"documentation":"","default":"false"}},"source_file_contents":"# The SimpleCollectionView class is a CollectionView without any of the\n# bells and whistles ( filtering, pagination, sorting, etc )\nsimple = Luca.register    \"Luca.components.SimpleCollectionView\"\nsimple.extends            \"Luca.CollectionView\"\n\nsimple.defines\n  filterable: false\n  paginatable: false\n  sortable: false\n  loadMask: false"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/table_view.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/table_view.coffee","type":"component_definition","starts_on_line":1,"class_name":"Luca.components.TableView","header_documentation":"","type_alias":"table_view","css_class_identifier":"luca-table-view","defines_methods":{"lastColumn":{"defined_on_line":21,"documentation":"","arguments":[]},"eachColumn":{"defined_on_line":24,"documentation":"","arguments":[{"argument":"fn","value":null},{"argument":"scope","value":"@"}]},"itemRenderer":{"defined_on_line":29,"documentation":"","arguments":[{"argument":"item","value":null},{"argument":"model","value":null}]},"initialize":{"defined_on_line":32,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"rowRenderer":{"defined_on_line":80,"documentation":"","arguments":[{"argument":"item","value":null},{"argument":"model","value":null},{"argument":"index","value":null}]}},"defines_properties":{"widths":{"defined_on_line":5,"documentation":"","default":"[]"},"columns":{"defined_on_line":6,"documentation":"","default":"[]"},"emptyText":{"defined_on_line":7,"documentation":"","default":"\"There are no results to display\""},"additionalClassNames":{"defined_on_line":10,"documentation":"","default":"\"table\""},"tagName":{"defined_on_line":11,"documentation":"","default":"\"table\""},"bodyTemplate":{"defined_on_line":12,"documentation":"","default":"\"table_view\""},"bodyTagName":{"defined_on_line":13,"documentation":"","default":"\"tbody\""},"bodyClassName":{"defined_on_line":14,"documentation":"","default":"\"table-body\""},"stateful":{"defined_on_line":15,"documentation":"","default":"true"},"itemTagName":{"defined_on_line":16,"documentation":"","default":"\"tr\""},"observeChanges":{"defined_on_line":17,"documentation":"","default":"true"}},"source_file_contents":"tableView = Luca.register     \"Luca.components.TableView\"\ntableView.extends             \"Luca.CollectionView\"\n\ntableView.publicConfiguration\n  widths: []\n  columns:[]\n  emptyText: \"There are no results to display\"\n\ntableView.privateConfiguration\n  additionalClassNames: \"table\"\n  tagName: \"table\"\n  bodyTemplate: \"table_view\"\n  bodyTagName: \"tbody\"\n  bodyClassName: \"table-body\"\n  stateful: true\n  itemTagName: \"tr\"\n  observeChanges: true\n\ntableView.privateMethods\n\n  lastColumn: ()->\n    @columns[ @columns.length - 1 ]\n\n  eachColumn: (fn, scope=@)->\n    index = 0\n    for col in @columns  \n      fn.call(scope, col, index++, @)\n\n  itemRenderer: (item, model)->\n    Luca.components.TableView.rowRenderer.call(@, item, model)\n\n  initialize: (@options={})->\n    Luca.components.CollectionView::initialize.apply(@, arguments)\n\n    index = 0\n    @columns = for column in @columns\n      if width = @widths[ index ]\n        column.width = width\n\n      if _.isString(column)\n        column = reader: column\n\n      if !column.header?\n        column.header = _.str.titleize(_.str.humanize(column.reader))\n\n      index++\n      column\n\n    @defer ()=> \n      Luca.components.TableView.renderHeader.call(@, @columns, @$('thead') )\n    .until(\"after:render\")\n\ntableView.classMethods\n  renderHeader : (columns, targetElement)->\n    index = 0\n\n    @$( targetElement ).append(\"<tr></tr>\")\n\n    for column in columns\n      attrs = \"data-col-index\": index++\n\n      if column.sortable\n        attrs.class = \"sortable-toggle\"\n        attrs[\"data-sortable-sort-by\"] = column.sortBy || column.sortable\n        attrs[\"data-sortable-order\"] = column.order\n\n      content = column.header \n      content = \"<a class='link'>#{ column.header }</a>\" if column.sortable\n\n      @$(targetElement).find('tr').append( Luca.View::make \"th\", attrs, content )\n\n\n    index = 0\n\n    for column in columns when column.width?\n      th = @$(\"th[data-col-index='#{ index++ }']\",targetElement)\n      th.css('width', column.width)\n\n\n  rowRenderer: (item, model, index)->\n    colIndex = 0\n    for columnConfig in @columns\n      Luca.components.TableView.renderColumn.call(@, columnConfig, item, model, colIndex++) \n\n  renderColumn : (column, item, model, index)->\n    cellValue = model.read( column.reader )\n\n    if _.isFunction( column.renderer )\n      cellValue = column.renderer.call @, cellValue, model, column \n\n    Luca.View::make(\"td\", {\"data-col-index\":index}, cellValue)\n\ntableView.register()"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/table_view_scrollable.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/table_view_scrollable.coffee","type":"component_definition","starts_on_line":1,"class_name":"Luca.components.ScrollableTable","header_documentation":"","type_alias":"scrollable_table","css_class_identifier":"luca-scrollable-table","defines_methods":{"$scrollableWrapperEl":{"defined_on_line":11,"documentation":"","arguments":[]},"setMaxHeight":{"defined_on_line":14,"documentation":"","arguments":[]},"afterRender":{"defined_on_line":18,"documentation":"","arguments":[]}},"defines_properties":{"maxHeight":{"defined_on_line":8,"documentation":"","default":"undefined"},"version":{"defined_on_line":23,"documentation":"","default":"1"}},"source_file_contents":"scrollable = Luca.register      'Luca.components.ScrollableTable'\n\nscrollable.extends              'Luca.components.TableView'\n\nscrollable.replaces             'Luca.components.GridView'\n\nscrollable.publicConfiguration\n  maxHeight: undefined\n\nscrollable.privateMethods\n  $scrollableWrapperEl: ()->\n    @$el.parent('.scrollable-wrapper')\n\n  setMaxHeight: ()->\n    parent = @$scrollableWrapperEl()\n    parent.css('overflow':'auto', 'max-height': @maxHeight)\n\n  afterRender: ()->\n    @$wrap 'scrollable-wrapper'\n    @setMaxHeight()\n\nscrollable.defines\n  version: 1"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/card_view.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/card_view.coffee","type":"component_definition","starts_on_line":21,"class_name":"Luca.containers.CardView","header_documentation":"<p>The CardView is a type of Container which has many sub-views\nwhich are only going to be visible one at a time.  A CardView\nallows you to @activate() its cards, navigate through them using\n@next(), @previous(), @cycle()\nExample:\n  cardView = new Luca.containers.CardView\n    cards:[\n      getter: &quot;getCardOne&quot;\n      type: &quot;my<em>component&quot;\n      name: &quot;one&quot;\n    ,\n      getter: &quot;getCardTwo&quot;\n      type: &quot;my</em>component&quot;\n      name: &quot;two&quot;\n    ]\n  cardView.activeComponent().name # =&gt; &quot;one&quot;\n  cardView.activate(&#39;two&#39;)\n  cardView.activeComponent().name # =&gt; &quot;two&quot;</p>\n","type_alias":"card_view","css_class_identifier":"luca-containers-card-view","defines_methods":{"atFirst":{"defined_on_line":52,"documentation":"<p>Returns true if at the first</p>\n","arguments":[]},"atLast":{"defined_on_line":56,"documentation":"<p>Returns true if we&#39;re at the last card</p>\n","arguments":[]},"next":{"defined_on_line":60,"documentation":"<p>Activate the next component.  If at the last, do nothing.</p>\n","arguments":[]},"previous":{"defined_on_line":65,"documentation":"<p>Activate the previous component.  If at the first, do nothing.</p>\n","arguments":[]},"cycle":{"defined_on_line":71,"documentation":"<p>Activates the next component after the current one.\nIf at the last component, it will activate the first.</p>\n","arguments":[]},"find":{"defined_on_line":76,"documentation":"<p>Find a direct component on this card by its name.</p>\n","arguments":[{"argument":"name","value":null}]},"activate":{"defined_on_line":85,"documentation":"<p>Activates the component at the specified index.  You may optionally specify\nthe name of the component you wish to activate.  You can pass false as your second\nargument, to disable the event handling that occurs when you activate a card on this container.\nIf you pass a callback function to the activate method, that callback will be executed within\nthe context of the activated component.</p>\n","arguments":[{"argument":"index","value":null},{"argument":"silent","value":"false"},{"argument":"callback","value":null}]},"initialize":{"defined_on_line":136,"documentation":"","arguments":[{"argument":"@options","value":null}]},"simulateActivationEvent":{"defined_on_line":144,"documentation":"<p>Simulates the activation event being triggered on the\nactive component that gets rendered inside of this card view.</p>\n","arguments":[]},"prepareComponents":{"defined_on_line":153,"documentation":"","arguments":[]},"activeComponentElement":{"defined_on_line":158,"documentation":"","arguments":[]},"activeComponent":{"defined_on_line":161,"documentation":"","arguments":[]},"customizeContainerEl":{"defined_on_line":164,"documentation":"","arguments":[{"argument":"containerEl","value":null},{"argument":"panel","value":null},{"argument":"panelIndex","value":null}]},"firstActivation":{"defined_on_line":174,"documentation":"<p>The first time activate event is triggered on this component\nthe @firstActivation hook is responsible for relaying that event\nto our @activeComponent() so that it knows it has been activated.</p>\n","arguments":[]}},"defines_properties":{"activeCard":{"defined_on_line":25,"documentation":"","default":"0"},"components":{"defined_on_line":26,"documentation":"","default":"[]"},"activationContext":{"defined_on_line":33,"documentation":"<p>When the activate method is called and passed a callback\nwhat context should we run that callback in?  Default is\nto call the callback in the context of the component that\nis currently being activated</p>\n","default":"\"current\""},"hooks":{"defined_on_line":39,"documentation":"<p>Will automatically call beforeCardSwitch and afterCardSwitch\nmethods if they exist on this view.  These events will be triggered\nin response to a call to @activate()</p>\n","default":"["},"componentClass":{"defined_on_line":45,"documentation":"<p>Which css class should we apply to each of the cards</p>\n","default":"'luca-ui-card'"},"generateComponentElements":{"defined_on_line":48,"documentation":"<p>Should we generate elements to append each component?</p>\n","default":"true"}},"source_file_contents":"# The CardView is a type of Container which has many sub-views\n# which are only going to be visible one at a time.  A CardView\n# allows you to @activate() its cards, navigate through them using\n# @next(), @previous(), @cycle()\n#\n# Example:\n#   cardView = new Luca.containers.CardView\n#     cards:[\n#       getter: \"getCardOne\"\n#       type: \"my_component\"\n#       name: \"one\"\n#     ,\n#       getter: \"getCardTwo\"\n#       type: \"my_component\"\n#       name: \"two\"\n#     ]\n#\n#   cardView.activeComponent().name # => \"one\"\n#   cardView.activate('two')\n#   cardView.activeComponent().name # => \"two\"\ncomponent = Luca.register       \"Luca.containers.CardView\"\ncomponent.extends               \"Luca.Container\"\n\ncomponent.publicConfiguration\n  activeCard: 0\n  components: []\n\ncomponent.classInterface\n  # When the activate method is called and passed a callback\n  # what context should we run that callback in?  Default is\n  # to call the callback in the context of the component that\n  # is currently being activated\n  activationContext: \"current\"\n\ncomponent.privateConfiguration\n  # Will automatically call beforeCardSwitch and afterCardSwitch\n  # methods if they exist on this view.  These events will be triggered\n  # in response to a call to @activate()\n  hooks:[\n    'before:card:switch',\n    'after:card:switch'\n  ]\n\n  # Which css class should we apply to each of the cards\n  componentClass: 'luca-ui-card'\n\n  # Should we generate elements to append each component?\n  generateComponentElements: true\n\ncomponent.publicMethods\n  # Returns true if at the first \n  atFirst: ()->\n    @activeCard is 0\n\n  # Returns true if we're at the last card\n  atLast: ()->\n    @activeCard is @components.length - 1\n\n  # Activate the next component.  If at the last, do nothing.\n  next: ()->\n    return if @atLast()\n    @activate( @activeCard + 1)\n\n  # Activate the previous component.  If at the first, do nothing.\n  previous: ()->   \n    return if @atFirst()\n    @activate( @activeCard - 1)\n\n  # Activates the next component after the current one.\n  # If at the last component, it will activate the first.\n  cycle: ()->\n    nextIndex = if @atLast() then 0 else @activeCard + 1\n    @activate( nextIndex )\n\n  # Find a direct component on this card by its name.\n  find: (name)-> \n    _( @components ).detect (c)-> \n      c.name is name\n\n  # Activates the component at the specified index.  You may optionally specify\n  # the name of the component you wish to activate.  You can pass false as your second\n  # argument, to disable the event handling that occurs when you activate a card on this container.\n  # If you pass a callback function to the activate method, that callback will be executed within\n  # the context of the activated component. \n  activate: (index, silent=false, callback)->\n    if _.isFunction(silent)\n      silent = false\n      callback = silent\n\n    return if index is @activeCard\n\n    previous = @activeComponent()\n\n    current = @getComponent(index)\n\n    if !current?\n      index = @indexOf(index) \n      return unless current = @getComponent(index)\n\n    unless silent is true\n      @trigger \"before:card:switch\", previous, current\n      previous?.trigger \"before:deactivation\", @, previous, current\n      current?.trigger \"before:activation\", @, previous, current\n\n      _.defer ()=>\n        @$el.data( @activeAttribute || \"active-card\", current.name)\n\n    @componentElements().hide()\n\n    unless current.previously_activated is true\n      if current.rendered is true\n        current.trigger \"first:activation\"\n      else\n        current.once \"after:render\", ()->\n          current.rendered = true\n          current.trigger(\"first:activation\")\n      current.previously_activated = true\n\n    @activeCard = index \n    @activeComponentElement().show()\n\n    unless silent is true\n      @trigger \"after:card:switch\", previous, current\n      previous?.trigger \"deactivation\", @, previous, current\n      current?.trigger \"activation\", @, previous, current\n\n    activationContext = @\n\n    if Luca.containers.CardView.activationContext is \"current\"\n      activationContext = current\n\n    if _.isFunction(callback)\n      callback.apply activationContext, [@,previous,current]\n\ncomponent.privateMethods\n  initialize: (@options)->\n    @components ||= @pages ||= @cards \n    Luca.Container::initialize.apply @,arguments\n    @setupHooks(@hooks)\n    @defer( @simulateActivationEvent, @ ).until(\"after:render\")\n\n  # Simulates the activation event being triggered on the\n  # active component that gets rendered inside of this card view. \n  simulateActivationEvent: ()->\n    c = @activeComponent()\n\n    if c? and (@visible || @$el.is(\":visible\"))\n      c?.trigger \"activation\", @, c, c \n      if !c.previously_activated\n        c.trigger \"first:activation\"\n        c.previously_activated = true\n\n  prepareComponents: ()->\n    Luca.Container::prepareComponents?.apply(@, arguments)\n    @componentElements().hide()\n    @activeComponentElement().show()\n\n  activeComponentElement: ()->\n    @componentElements().eq( @activeCard )\n\n  activeComponent: ()->\n    @getComponent( @activeCard )\n\n  customizeContainerEl: (containerEl, panel, panelIndex)->\n    containerEl.style += if panelIndex is @activeCard then \"display:block;\" else \"display:none;\"\n\n    containerEl\n\n\n\n  # The first time activate event is triggered on this component\n  # the @firstActivation hook is responsible for relaying that event\n  # to our @activeComponent() so that it knows it has been activated.\n  firstActivation: ()->\n    if activeComponent = @activeComponent()\n      activeComponent.trigger \"first:activation\", @, @activeComponent()\n\ncomponent.register()\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/container.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/container.coffee","type":"component_definition","starts_on_line":146,"class_name":"Luca.Container","header_documentation":"<p>The Luca.Container is the heart and soul of the Luca framework \nand the component driven design philosophy.  The central idea\nis that every component should be designed as an isolated unit\nwhich completely encapsulates its features.  It should not know about\nother components outside of it.</p>\n\n<p>It is the responsibility of a <code>Luca.Container</code> to define its \nchild <code>@components</code>, render them, and broker communication between them\nin response to events which occur in the user interface.<br>\nA common use case for this would be a page which has a filter form, and\na grid of search results.  The fields in the filter form are used to \nfilter the table.  Neither the form or the table know about each other, \nsince both can be used in other contexts.  A <code>Luca.Container</code> would be used\nto relay events from the form to the table, and in doing so create a higher\nlevel component which can be extended and re-used. </p>\n\n<h4>Using a container to combine a Filter View and Results Table</h4>\n\n<pre><code>    form = Luca.register    &quot;App.views.FilterForm&quot;\n    form.extends            &quot;Luca.components.FormView&quot;\n    form.contains\n      type:   &quot;text&quot;\n      label:  &quot;Filter by&quot;\n      name:   &quot;filter_text&quot;\n    ,\n      type:   &quot;button&quot;\n      className: &quot;filter&quot;\n      value:  &quot;Filter&quot;          \n    form.defines\n      toolbar: false \n</code></pre>\n\n<p>Elsewhere, we have a table that lists records in a collection:</p>\n\n<pre><code>    table = Luca.register     &quot;App.views.ResultsTable&quot;\n    table.extends             &quot;Luca.components.TableView&quot;\n    table.defines \n      striped: true\n      collection: &quot;components&quot;\n      columns:[\n        header: &quot;Component Class&quot;\n        reader: &quot;class_name&quot;\n      ,\n        header: &quot;Component Type Alias&quot;\n        reader: &quot;type_alias&quot;\n      ]\n</code></pre>\n\n<p>We can join these two components together by declaring their relationship\nin a <code>Luca.Container</code>.  Remember the components we defined above are just\nprototypes.  We can override specific instance configuration and properties \nin our container.</p>\n\n<h4>Container Example</h4>\n\n<pre><code>    container = Luca.register     &quot;App.views.ComponentFinder&quot;\n    container.extends             &quot;Luca.Container&quot;\n\n  # This is the same as defining a components property on the component.\n  # The type alias is derived from the name of the component.  It is \n  # a short hand way of referencing a component you might reuse a lot.\n  container.contains\n    type: &quot;filter_form&quot;\n    role: &quot;filter&quot;\n  ,\n    type: &quot;results_table&quot;\n    # change the prototype&#39;s default \n    striped: false\n    role: &quot;results&quot;\n    filterable: true\n  # A Container will generally define some component event bindings\n  # and handler methods to handle the communication between its sub\n  # components.  By default a container is able to access events\n  # from all of its descendants in the hierarchy. \n  container.defines\n    # These will be applied to each of our components.\n    defaults:\n      attributes:\n        &quot;data-attribute&quot;: &quot;whatever&quot;\n    componentEvents:\n      # Any time any of our child components emit\n      # the on:change event, pass it to the filterTable method\n      &quot;* on:change&quot; : &quot;filterTable&quot;\n    # Communicates between the filter and the table&#39;s\n    # underlying collection.  NOtice the use of the @role\n    # property.  It automatically creates getter helpers for us.\n    filterTable: ()-&gt;\n      filter = @getFilter()\n      results = @getResults()\n      # filter.getValues() is a hash of each field and its value\n      results.applyFilter( filter.getValues() )\n</code></pre>\n\n<h3>DOM Layout Configuration</h3>\n\n<p>Another responsibility of the container is to structurally layout its\nchild components in the DOM.  There are a number of different \noptions available depending on how you need to do this.  By default,\na <code>Luca.Container</code> will simply append the @$el of all of its views\nto its own.\nThe <code>Luca.components.Controller</code> is a container which hides every page\nbut the active page.  Similarly, there is the <code>Luca.containers.TabView</code>\nwhich does the same thing, but renders a tab selector menu for you.  You\ncan create any type of interface you want using containers. \nTo make this easy for you, you can do a few different things:</p>\n\n<h4>Use the Twitter Bootstrap Fluid Grid</h4>\n\n<pre><code>    container = Luca.register &quot;App.views.ColumnLayout&quot; \n    container.extends         &quot;App.views.ComponentFinder&quot;\n    container.contains\n      span: 4\n      type: &quot;filter_form&quot;\n      role: &quot;filter&quot;\n    ,\n      span: 8\n      type: &quot;results_table&quot;\n      role: &quot;results&quot;\n    container.defines\n      rowFluid: true\n</code></pre>\n\n<h4>Using a layout template with CSS Selectors</h4>\n\n<p>If you find yourself needing a container view with a complicated\nvisual layout, you can provide your own DOM template as a <code>@bodyTemplate</code>\nand assign each child view in <code>@components</code> to its own specific CSS selector.\n        ... \n        container.contains\n          role: &quot;filter&quot;\n          container: &quot;#filter-wrapper-dom-selector&quot;\n        ,\n          role: &quot;results&quot;\n          container: &quot;#results-wrapper-dom-selector&quot;\n        ...\n        container.defines\n          # assumes the template will provide the CSS selectors used above \n          bodyTemplate: &quot;layouts/custom_template&quot;</p>\n","type_alias":"container","css_class_identifier":"luca-container","defines_methods":{"initialize":{"defined_on_line":248,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"remove":{"defined_on_line":268,"documentation":"<p>Removing a container will call remove on all of the nested components as well.</p>\n","arguments":[]},"beforeRender":{"defined_on_line":273,"documentation":"","arguments":[]},"customizeContainerEl":{"defined_on_line":282,"documentation":"<p>Components which inherit from Luca.Container can implement\ntheir own versions of this method, if they need to apply any sort\nof additional styling / configuration for the DOM elements that\nare created to wrap each container.</p>\n","arguments":[{"argument":"containerEl","value":null},{"argument":"panel","value":null},{"argument":"panelIndex","value":null}]},"prepareLayout":{"defined_on_line":285,"documentation":"","arguments":[]},"prepareComponents":{"defined_on_line":308,"documentation":"","arguments":[]},"createComponents":{"defined_on_line":351,"documentation":"<p>create components is responsible for turning the JSON syntax of the\ncontainer&#39;s definition into live objects against a given Luca Component\ntype.</p>\n\n<p>In addition to this, a container builds an index of the components\nwhich belong to it, so that they can easily be looked up by name</p>\n","arguments":[]},"renderComponents":{"defined_on_line":414,"documentation":"<p>Trigger the Rendering Pipeline process on all of the nested components</p>\n","arguments":[{"argument":"@debugMode","value":"\"\""}]},"firstActivation":{"defined_on_line":458,"documentation":"<p>When a container is first activated is a good time to perform\noperations which are not needed unless that component becomes\nvisible.  This first activation event should be relayed to all\nof the nested components.  Components which hide / display\nother components, such as a CardView or TabContainer\nwill trigger first:activation on the components as they become\ndisplayed.</p>\n","arguments":[]},"registerComponentEvents":{"defined_on_line":467,"documentation":"","arguments":[{"argument":"eventList","value":null},{"argument":"direction","value":"\"on\""}]},"_":{"defined_on_line":490,"documentation":"<p>Returns an underscore.js object that wraps the components array</p>\n","arguments":[{"argument":")-> _( @components","value":null}]},"pluck":{"defined_on_line":493,"documentation":"<p>Return the value of attribute of each component</p>\n","arguments":[{"argument":"attribute","value":null}]},"invoke":{"defined_on_line":497,"documentation":"<p>Invoke the passed method name on each component</p>\n","arguments":[{"argument":"method","value":null}]},"select":{"defined_on_line":501,"documentation":"<p>Select any component for which the passed iterator returns true</p>\n","arguments":[{"argument":"iterator","value":null}]},"detect":{"defined_on_line":505,"documentation":"<p>Find the first matching component for which the passed iterator returns true</p>\n","arguments":[{"argument":"iterator","value":null}]},"reject":{"defined_on_line":509,"documentation":"<p>Return a list of components without the components for which the passed iterator returns true</p>\n","arguments":[{"argument":"iterator","value":null}]},"map":{"defined_on_line":513,"documentation":"<p>Run the passed iterator over each component and return the result in an array</p>\n","arguments":[{"argument":"fn","value":null}]},"subContainers":{"defined_on_line":517,"documentation":"<p>Returns a list of nested components which are also containers</p>\n","arguments":[]},"roles":{"defined_on_line":521,"documentation":"","arguments":[]},"allChildren":{"defined_on_line":524,"documentation":"","arguments":[]},"find":{"defined_on_line":533,"documentation":"<p>Find a direct component on this card by its name.</p>\n","arguments":[{"argument":"name","value":null}]},"findComponentForEventBinding":{"defined_on_line":537,"documentation":"","arguments":[{"argument":"nameRoleOrGetter","value":null},{"argument":"deep","value":"true"}]},"findComponentByGetter":{"defined_on_line":540,"documentation":"","arguments":[{"argument":"getter","value":null},{"argument":"deep","value":"false"}]},"findComponentByRole":{"defined_on_line":544,"documentation":"","arguments":[{"argument":"role","value":null},{"argument":"deep","value":"false"}]},"findComponentByType":{"defined_on_line":548,"documentation":"","arguments":[{"argument":"desired","value":null},{"argument":"deep","value":"false"}]},"findComponentByName":{"defined_on_line":552,"documentation":"","arguments":[{"argument":"name","value":null},{"argument":"deep","value":"false"}]},"findComponentById":{"defined_on_line":556,"documentation":"","arguments":[{"argument":"id","value":null},{"argument":"deep","value":"false"}]},"findComponent":{"defined_on_line":559,"documentation":"","arguments":[{"argument":"needle","value":null},{"argument":"haystack","value":"\"name\""},{"argument":"deep","value":"false"}]},"each":{"defined_on_line":573,"documentation":"","arguments":[{"argument":"fn","value":null}]},"eachComponent":{"defined_on_line":579,"documentation":"<p>run a function for each component in this container\nand any nested containers in those components, recursively\npass false as the second argument to skip the deep recursion</p>\n","arguments":[{"argument":"fn","value":null},{"argument":"deep","value":"true"}]},"indexOfComponentName":{"defined_on_line":584,"documentation":"","arguments":[{"argument":"name","value":null}]},"indexOf":{"defined_on_line":588,"documentation":"","arguments":[{"argument":"nameOrComponent","value":null}]},"activeComponent":{"defined_on_line":595,"documentation":"","arguments":[]},"componentElements":{"defined_on_line":599,"documentation":"","arguments":[]},"getComponent":{"defined_on_line":602,"documentation":"","arguments":[{"argument":"needle","value":null}]},"isRootComponent":{"defined_on_line":605,"documentation":"","arguments":[]},"getRootComponent":{"defined_on_line":608,"documentation":"","arguments":[]},"selectByAttribute":{"defined_on_line":612,"documentation":"","arguments":[{"argument":"attribute","value":null},{"argument":"value","value":"undefined"},{"argument":"deep","value":"false"}]},"at":{"defined_on_line":704,"documentation":"","arguments":[{"argument":"index","value":null}]}},"defines_properties":{"components":{"defined_on_line":177,"documentation":"<p>@components should contain a list of object configurations for child view(s)\nof this container.  The values specified in the configuration object will override the\nvalues defined as properties and methods on your view prototypes.</p>\n\n<p>There are special properties you can define in your components configuration items\nthat will effect the container:</p>\n\n<ul>\n<li><p>role:       will create a camelized getter for you on the container.  e.g. when role is <code>my_custom_role</code>,\nthe container will have a method <code>getMyCustomRole()</code> that returns that child view.</p></li>\n<li><p>name:       a name for the child view.  this allows you to access the component by name using\nthe find() method on the container.</p></li>\n<li><p>type:       a type alias from the component registry.  type alias are underscore&#39;d strings\nmatching the component class name.  e.g. App.views.MyCustomView type alias is <code>my_custom_view</code></p></li>\n<li><p>component:  a convenience property for setting type, role, and name to be equal.</p></li>\n</ul>\n","default":"[]"},"defaults":{"defined_on_line":182,"documentation":"<p>The <code>@defaults</code> property is an object of configuration parameters which will be set\non each child component.  Values explicitly defines in the components config will\ntake precedence over the default.</p>\n","default":"{}"},"extensions":{"defined_on_line":194,"documentation":"<p>The <code>@extensions</code> property is useful when you are subclassing a container view\nwhich already defines an array of components, and you want to specifically override\nproperties and settings on the children. The <code>@extensions</code> property expects either:</p>\n\n<p>An object whose keys match the names of the <code>@role</code> property defined on the child components.\nThe value should be an object which will override any values defined on the parent class.</p>\n\n<p>or:</p>\n\n<p>An array of objects in the same array position / index as the target child view you wish to extend.</p>\n","default":"{}"},"componentEvents":{"defined_on_line":215,"documentation":"<p>@componentEvents provides declarative syntax for responding to events on\nthe components in this container.  the format of the syntax is very similar\nto the other event binding helpers:</p>\n\n<p><code>component_accessor component:trigger</code></p>\n\n<p>where component_accessor is either the name of the component, or a the role\nproperty on the component, component:trigger is the event that component fires.\nhandler is a method on the container which will respond to the child component event.\n<pre>\nmyContainer = new Luca.Container\ncomponentEvents:\n&quot;name component:trigger&quot;    : &quot;handler&quot;\n&quot;role component:trigger&quot;    : &quot;handler&quot;\n&quot;getter component:trigger&quot;  : &quot;handler&quot;\ncomponents:[\nname: &quot;name&quot;\n]\n</pre></p>\n","default":"{}"},"className":{"defined_on_line":218,"documentation":"","default":"'luca-ui-container'"},"isContainer":{"defined_on_line":222,"documentation":"<p>This is a convenience attribute for identifying\nviews which are luca containers</p>\n","default":"true"},"generateComponentElements":{"defined_on_line":228,"documentation":"<p>if set to true, we will generate DOM elements\nto wrap each of our components in.  This should\ngenerally be avoided IMO as it pollutes the DOM,\nbut is currently necessary for some container implementations</p>\n","default":"false"},"emptyContainerElements":{"defined_on_line":233,"documentation":"<p>if set to true, the DOM elements which wrap\nour components will be emptied prior to rendering\nthe component inside this container.</p>\n","default":"false"},"componentTag":{"defined_on_line":237,"documentation":"<p>if @generateComponentElements is true, which tag should this\ncontainer wrap our components in?</p>\n","default":"'div'"},"componentClass":{"defined_on_line":241,"documentation":"<p>if @generateComponentElements is true, which class should we\napply to the container elements which wrap our components?</p>\n","default":"'luca-ui-panel'"},"rendered":{"defined_on_line":243,"documentation":"","default":"false"},"@trigger \"before":{"defined_on_line":640,"documentation":"","default":"layout\", @"},"@trigger \"after":{"defined_on_line":642,"documentation":"","default":"layout\", @"},"style_declarations.push \"height":{"defined_on_line":647,"documentation":"","default":"#{ (if _.isNumber(panel.height) then panel.height + 'px' else panel.height ) }\" if panel.height?"},"style_declarations.push \"width":{"defined_on_line":648,"documentation":"","default":"#{ (if _.isNumber(panel.width) then panel.width + 'px' else panel.width ) }\" if panel.width?"},"style_declarations.push \"float":{"defined_on_line":649,"documentation":"","default":"#{ panel.float }\" if panel.float"}},"source_file_contents":"# The Luca.Container is the heart and soul of the Luca framework \n# and the component driven design philosophy.  The central idea\n# is that every component should be designed as an isolated unit\n# which completely encapsulates its features.  It should not know about\n# other components outside of it.\n# \n# It is the responsibility of a `Luca.Container` to define its \n# child `@components`, render them, and broker communication between them\n# in response to events which occur in the user interface.  \n#\n# A common use case for this would be a page which has a filter form, and\n# a grid of search results.  The fields in the filter form are used to \n# filter the table.  Neither the form or the table know about each other, \n# since both can be used in other contexts.  A `Luca.Container` would be used\n# to relay events from the form to the table, and in doing so create a higher\n# level component which can be extended and re-used. \n#\n# #### Using a container to combine a Filter View and Results Table \n#\n#         form = Luca.register    \"App.views.FilterForm\"\n#         form.extends            \"Luca.components.FormView\"\n#\n#         form.contains\n#           type:   \"text\"\n#           label:  \"Filter by\"\n#           name:   \"filter_text\"\n#         ,\n#           type:   \"button\"\n#           className: \"filter\"\n#           value:  \"Filter\"          \n#\n#\n#         form.defines\n#           toolbar: false \n# \n# Elsewhere, we have a table that lists records in a collection:\n#         \n#         table = Luca.register     \"App.views.ResultsTable\"\n#         table.extends             \"Luca.components.TableView\"\n#         table.defines \n#           striped: true\n#           collection: \"components\"\n#           columns:[\n#             header: \"Component Class\"\n#             reader: \"class_name\"\n#           ,\n#             header: \"Component Type Alias\"\n#             reader: \"type_alias\"\n#           ]\n#\n# We can join these two components together by declaring their relationship\n# in a `Luca.Container`.  Remember the components we defined above are just\n# prototypes.  We can override specific instance configuration and properties \n# in our container.\n#\n# #### Container Example\n#\n#         container = Luca.register     \"App.views.ComponentFinder\"\n#         container.extends             \"Luca.Container\"\n#       \n#       # This is the same as defining a components property on the component.\n#       # The type alias is derived from the name of the component.  It is \n#       # a short hand way of referencing a component you might reuse a lot.\n#       container.contains\n#         type: \"filter_form\"\n#         role: \"filter\"\n#       ,\n#         type: \"results_table\"\n#         # change the prototype's default \n#         striped: false\n#         role: \"results\"\n#         filterable: true\n#\n#       # A Container will generally define some component event bindings\n#       # and handler methods to handle the communication between its sub\n#       # components.  By default a container is able to access events\n#       # from all of its descendants in the hierarchy. \n#       container.defines\n#         # These will be applied to each of our components.\n#         defaults:\n#           attributes:\n#             \"data-attribute\": \"whatever\"\n#\n#         componentEvents:\n#           # Any time any of our child components emit\n#           # the on:change event, pass it to the filterTable method\n#           \"* on:change\" : \"filterTable\"\n#\n#         # Communicates between the filter and the table's\n#         # underlying collection.  NOtice the use of the @role\n#         # property.  It automatically creates getter helpers for us.\n#         filterTable: ()->\n#           filter = @getFilter()\n#           results = @getResults()\n#           # filter.getValues() is a hash of each field and its value\n#           results.applyFilter( filter.getValues() )\n#         \n# ### DOM Layout Configuration\n#\n# Another responsibility of the container is to structurally layout its\n# child components in the DOM.  There are a number of different \n# options available depending on how you need to do this.  By default,\n# a `Luca.Container` will simply append the @$el of all of its views\n# to its own.\n#\n# The `Luca.components.Controller` is a container which hides every page\n# but the active page.  Similarly, there is the `Luca.containers.TabView`\n# which does the same thing, but renders a tab selector menu for you.  You\n# can create any type of interface you want using containers. \n#\n# To make this easy for you, you can do a few different things:\n#\n# #### Use the Twitter Bootstrap Fluid Grid\n#\n#         container = Luca.register \"App.views.ColumnLayout\" \n#         container.extends         \"App.views.ComponentFinder\"\n#\n#         container.contains\n#           span: 4\n#           type: \"filter_form\"\n#           role: \"filter\"\n#         ,\n#           span: 8\n#           type: \"results_table\"\n#           role: \"results\"\n#\n#         container.defines\n#           rowFluid: true\n#\n# #### Using a layout template with CSS Selectors\n# If you find yourself needing a container view with a complicated\n# visual layout, you can provide your own DOM template as a `@bodyTemplate`\n# and assign each child view in `@components` to its own specific CSS selector.\n#\n#         ... \n#         container.contains\n#           role: \"filter\"\n#           container: \"#filter-wrapper-dom-selector\"\n#         ,\n#           role: \"results\"\n#           container: \"#results-wrapper-dom-selector\"\n#         ...\n#         container.defines\n#           # assumes the template will provide the CSS selectors used above \n#           bodyTemplate: \"layouts/custom_template\"\ncontainer = Luca.register         \"Luca.Container\"\n\ncontainer.extends                 \"Luca.Panel\"\n\ncontainer.triggers                \"before:components\",\n                                  \"before:render:components\",\n                                  \"before:layout\",\n                                  \"after:components\",\n                                  \"after:layout\",\n                                  \"first:activation\"\n\ncontainer.replaces                \"Luca.Container\"\n\ncontainer.publicConfiguration\n  # @components should contain a list of object configurations for child view(s)\n  # of this container.  The values specified in the configuration object will override the \n  # values defined as properties and methods on your view prototypes.\n  #\n  # There are special properties you can define in your components configuration items \n  # that will effect the container:\n  #\n  # - role:       will create a camelized getter for you on the container.  e.g. when role is `my_custom_role`, \n  #               the container will have a method `getMyCustomRole()` that returns that child view.\n  #\n  # - name:       a name for the child view.  this allows you to access the component by name using \n  #               the find() method on the container.\n  #\n  # - type:       a type alias from the component registry.  type alias are underscore'd strings \n  #               matching the component class name.  e.g. App.views.MyCustomView type alias is `my_custom_view`\n  #\n  # - component:  a convenience property for setting type, role, and name to be equal. \n  components:[]\n\n  # The `@defaults` property is an object of configuration parameters which will be set\n  # on each child component.  Values explicitly defines in the components config will \n  # take precedence over the default.\n  defaults: {}\n\n  # The `@extensions` property is useful when you are subclassing a container view\n  # which already defines an array of components, and you want to specifically override\n  # properties and settings on the children. The `@extensions` property expects either: \n  #\n  # An object whose keys match the names of the `@role` property defined on the child components.\n  # The value should be an object which will override any values defined on the parent class.\n  #\n  # or:\n  # \n  # An array of objects in the same array position / index as the target child view you wish to extend.\n  extensions: {}\n\n  # @componentEvents provides declarative syntax for responding to events on\n  # the components in this container.  the format of the syntax is very similar\n  # to the other event binding helpers:\n  #\n  # `component_accessor component:trigger`\n  #\n  # where component_accessor is either the name of the component, or a the role \n  # property on the component, component:trigger is the event that component fires.\n  # handler is a method on the container which will respond to the child component event.\n  # <pre>\n  #       myContainer = new Luca.Container\n  #         componentEvents:\n  #           \"name component:trigger\"    : \"handler\"\n  #           \"role component:trigger\"    : \"handler\"\n  #           \"getter component:trigger\"  : \"handler\"\n  #         components:[\n  #           name: \"name\"\n  #         ]\n  # </pre>\n  componentEvents: {}\n\ncontainer.privateConfiguration\n  className: 'luca-ui-container'\n\n  # This is a convenience attribute for identifying\n  # views which are luca containers\n  isContainer: true\n\n  # if set to true, we will generate DOM elements\n  # to wrap each of our components in.  This should \n  # generally be avoided IMO as it pollutes the DOM, \n  # but is currently necessary for some container implementations\n  generateComponentElements: false\n\n  # if set to true, the DOM elements which wrap\n  # our components will be emptied prior to rendering\n  # the component inside this container.\n  emptyContainerElements: false\n\n  # if @generateComponentElements is true, which tag should this \n  # container wrap our components in?\n  componentTag: 'div'\n\n  # if @generateComponentElements is true, which class should we \n  # apply to the container elements which wrap our components?\n  componentClass: 'luca-ui-panel'\n\n  rendered: false\n\n\n\ncontainer.privateMethods\n  initialize: (@options={})->\n    _.extend @, @options\n\n    # aliases for the components property\n    @components ||= @fields ||= @pages ||= @cards ||= @views\n    \n    # accept components as an array of strings representing\n    # the luca component type\n    for component in @components when _.isString(component)\n      component = (type: component, role: component, name: component)\n\n    _.bindAll(@, \"beforeRender\")\n\n    @setupHooks( Luca.Container::hooks )\n\n    validateContainerConfiguration(@)\n\n    Luca.View::initialize.apply @, arguments\n\n  # Removing a container will call remove on all of the nested components as well.\n  remove: ()->\n    Luca.View::remove.apply(@, arguments)\n    @eachComponent (component)->\n      component.remove?()\n      \n  beforeRender: ()->\n    doLayout.call(@)\n    doComponents.call(@)\n    Luca.Panel::beforeRender?.apply(@, arguments)\n\n  # Components which inherit from Luca.Container can implement\n  # their own versions of this method, if they need to apply any sort\n  # of additional styling / configuration for the DOM elements that\n  # are created to wrap each container.\n  customizeContainerEl: (containerEl, panel, panelIndex)->\n    containerEl\n\n  prepareLayout: ()->\n    container = @\n    @componentContainers = _( @components ).map (component, index)->\n      applyDOMConfig.call(container, component, index)\n\n    componentsWithClassBasedAssignment = @_().select (component)->\n      _.isString(component.container) and component.container?.match(/^\\./) and container.$( component.container ).length > 0\n\n    # TEMP / HACK / Workaround\n    #\n    # Containers with components assigned to .class-based-containers\n    # seem to get double rendered in the renderComponents() method.\n    #\n    # So here I am uniquely identifying the containers in a way that is not possible\n    # in the templates ( since we want to be able to inherit templates and component assignments )\n    if componentsWithClassBasedAssignment.length > 0\n      for specialComponent in componentsWithClassBasedAssignment\n        containerAssignment = _.uniqueId('container')\n        targetEl = container.$( specialComponent.container )\n        if targetEl.length > 0\n          $(targetEl).attr('data-container-assignment', containerAssignment)\n          specialComponent.container += \"[data-container-assignment='#{ containerAssignment }']\"\n\n  prepareComponents: ()->\n    container = @\n\n    _( @components ).each (component, index)=>\n      ce = componentContainerElement = @componentContainers?[index]\n\n      # support a variety of the bad naming conventions\n      ce.class = ce.class || ce.className || ce.classes\n\n      if @generateComponentElements\n        panel = @make(@componentTag, componentContainerElement, '')\n        @$append( panel )\n\n      # if the container defines a @defaults property\n      # then we should make sure our child components inherit\n      # these values unless specifically defined\n      if container.defaults?\n        component = _.defaults(component, (container.defaults || {}))\n\n      # if the container defines an @extensions property as an array of\n      # configuration objects, then we will extend the component config with\n      # the object in the matching position of the @extensions array.\n      if _.isArray(container.extensions) and _.isObject(container.extensions?[ index ])\n        componentExtension = container.extensions[index]\n        component = _.extend(component, componentExtension)\n\n      # if the container defines an @extensions property as an object of nested hashes,\n      # then extensions is a key/value pair whose key represents the role of the component\n      # that we wish to extend / customize \n      if component.role? and _.isObject(container.extensions) and _.isObject(container.extensions[component.role])\n        componentExtension = container.extensions[component.role]\n        component = _.extend(component, componentExtension)\n        \n      unless component.container?\n        component.container = \"##{ componentContainerElement.id }\" if @generateComponentElements\n        component.container ||= @$bodyEl()\n\n  # create components is responsible for turning the JSON syntax of the\n  # container's definition into live objects against a given Luca Component\n  # type.\n  #\n  # In addition to this, a container builds an index of the components\n  # which belong to it, so that they can easily be looked up by name\n  createComponents: ()->\n    return if @componentsCreated is true\n\n    map = @componentIndex =\n      name_index: {}\n      cid_index: {}\n      role_index: {}\n\n    container   = @\n\n    @components = _( @components ).map (object, index)=>\n\n      # you can include normal backbone views as components\n      # you will want to make sure your render method handles\n      # adding the views @$el to the appropriate @container.\n\n      # you can also just pass a string representing the component_type\n      component = if Luca.isComponent( object )\n        object\n      else\n        # if a component is tagged with a @component property\n        # we assume this is the kind of singleton component\n        # and set the type, role and name to the same value (if they're blank)\n        if object.component? and not (object.type || object.ctype)\n          object.type = object.component\n          object.name ||= object.component\n          object.role ||= object.component\n\n        object.type ||= object.ctype\n\n        # guess the type based on the properties\n        if !object.type?\n          # TODO\n          # Add support for all of the various components property aliases\n          if object.components?\n            object.type = object.ctype = 'container'\n          else\n            object.type = object.ctype = Luca.defaultComponentType\n\n        object._parentCid ||= container.cid\n        created = Luca.util.lazyComponent( object )\n\n      # if we're using base backbone views, then they don't extend themselves\n      # with their passed options, so this is a workaround to get them to\n      # pick up the container config property\n      if !component.container and component.options?.container\n        component.container = component.options.container\n\n      component.getParent ||= ()-> Luca( component._parentCid )\n\n      if not component.container?\n        console.log component,index,@\n        console.error \"could not assign container property to component on container #{ @name || @cid }\"\n\n      indexComponent( component ).at(index).in( @componentIndex )\n\n      component\n\n    @componentsCreated = true\n\n    map\n\n  # Trigger the Rendering Pipeline process on all of the nested components\n  renderComponents: (@debugMode=\"\")->\n    @debug \"container render components\"\n\n    container = @\n\n    _(@components).each (component)->\n      try\n        component.trigger \"before:attach\"\n\n        containerElement = container.$(component.container)\n\n        if containerElement.length is 0\n          if _.isString( component.container )\n            # the container trying to assign this component to is not in the dom\n            1\n\n          # try in the window context.  this is almost always certainly a bug\n          # so look into wtf is going on and which components are problematic\n          containerElement = @$( component.container ).eq(0) if containerElement.length is 0\n\n        if @emptyContainerElements is true\n          containerElement.empty()\n\n        containerElement.append( component.el )\n\n        component.trigger \"after:attach\"\n        component.render()\n        component.rendered = true\n      catch e\n        console.log \"Error Rendering Component #{ component.name || component.cid }\", component\n\n        if _.isObject(e)\n          console.log e.message\n          console.log e.stack\n\n        throw e unless Luca.silenceRenderErrors? is true\n\n  # When a container is first activated is a good time to perform\n  # operations which are not needed unless that component becomes\n  # visible.  This first activation event should be relayed to all\n  # of the nested components.  Components which hide / display\n  # other components, such as a CardView or TabContainer\n  # will trigger first:activation on the components as they become\n  # displayed.\n  firstActivation: ()->\n    activator = @\n    @each (component, index)->\n      # apply the first:activation trigger on the component, in the context of the component\n      # passing as arguments the component itself, and the component doing the activation\n      unless component?.previously_activated is true\n        component?.trigger?.call component, \"first:activation\", component, activator\n        component.previously_activated = true\n\n  registerComponentEvents: (eventList, direction=\"on\")->\n    container = @\n\n    for listener, handler of (eventList || @componentEvents||{})\n      [componentNameOrRole,eventId] = listener.split(' ')\n\n      unless _.isFunction( @[handler] )\n        console.log \"Error registering component event\", listener, componentNameOrRole, eventId\n        throw \"Invalid component event definition #{ listener }. Specified handler is not a method on the container\"\n\n      if componentNameOrRole is \"*\"\n        @eachComponent (component)=> component.on(eventId, @[handler], container)\n      else\n        component = @findComponentForEventBinding( componentNameOrRole )\n\n        unless component? and Luca.isComponent(component)\n          console.log \"Error registering component event\", listener, componentNameOrRole, eventId\n          throw \"Invalid component event definition: #{ componentNameOrRole }\"\n\n        component[direction](eventId, @[handler], container)\n\ncontainer.publicMethods\n  # Returns an underscore.js object that wraps the components array\n  _: ()-> _( @components )\n\n  # Return the value of attribute of each component \n  pluck: (attribute)->\n    @_().pluck(attribute)\n\n  # Invoke the passed method name on each component\n  invoke: (method)->\n    @_().invoke(method)\n\n  # Select any component for which the passed iterator returns true\n  select: (iterator)->\n    @_().select(iterator)\n\n  # Find the first matching component for which the passed iterator returns true\n  detect: (iterator)->\n    @_().detect(iterator)\n\n  # Return a list of components without the components for which the passed iterator returns true \n  reject: (iterator)->\n    @_().reject(iterator)\n\n  # Run the passed iterator over each component and return the result in an array\n  map: (fn)->\n    @_().map(fn)\n\n  # Returns a list of nested components which are also containers\n  subContainers: ()->\n    @select (component)->\n      component.isContainer is true\n\n  roles: ()->\n    _( @allChildren() ).chain().pluck('role').compact().value()\n\n  allChildren: ()->\n    children = @components\n\n    grandchildren = _( @subContainers() ).map (component)->\n      component?.allChildren?()\n\n    _([children,grandchildren]).chain().compact().flatten().value()\n\n  # Find a direct component on this card by its name.\n  find: (name)-> \n    _( @components ).detect (c)-> \n      c.name is name    \n\n  findComponentForEventBinding: (nameRoleOrGetter, deep=true)->\n    @findComponentByName(nameRoleOrGetter, deep) || @findComponentByGetter( nameRoleOrGetter, deep ) || @findComponentByRole( nameRoleOrGetter, deep )\n\n  findComponentByGetter: (getter, deep=false)->\n    _( @allChildren() ).detect (component)->\n      component?.getter is getter\n\n  findComponentByRole: (role,deep=false)->\n    _( @allChildren() ).detect (component)->\n      component?.role is role or component?.type is role or component?.ctype is role\n\n  findComponentByType: (desired,deep=false)->\n    _( @allChildren() ).detect (component)->\n      desired is (component.type || component.ctype)\n\n  findComponentByName: (name, deep=false)->\n    _( @allChildren() ).detect (component)->\n      component.name is name\n\n  findComponentById: (id, deep=false)->\n    @findComponent(id, \"cid_index\", deep)\n\n  findComponent: (needle, haystack=\"name\", deep=false)->\n    @createComponents() unless @componentsCreated is true\n\n    position = @componentIndex?[ haystack ][ needle ]\n    component = @components[ position ]\n\n    return component if component\n\n    if deep is true\n      sub_container = _( @components ).detect (component)->\n        component?.findComponent?(needle, haystack, true)\n\n      sub_container?.findComponent?(needle, haystack, true)\n\n  each: (fn)->\n    @eachComponent(fn, false)\n\n  # run a function for each component in this container\n  # and any nested containers in those components, recursively\n  # pass false as the second argument to skip the deep recursion\n  eachComponent: (fn, deep=true)->\n    _( @components ).each (component, index)=>\n      fn.call component, component, index\n      component?.eachComponent?.apply component, [fn,deep] if deep\n\n  indexOfComponentName: (name)->\n    names = _( @components ).pluck('name')\n    _( names ).indexOf(name)\n\n  indexOf: (nameOrComponent)->\n    if _.isString(nameOrComponent)\n      return @indexOfComponentName(nameOrComponent)\n\n    if _.isObject(nameOrComponent)\n      _( @components ).indexOf( nameOrComponent )\n\n  activeComponent: ()->\n    return @ unless @activeItem\n    return @components[ @activeItem ]\n\n  componentElements: ()->\n    @$(\"[data-luca-parent='#{ @name || @cid }']\")\n\n  getComponent: (needle)->\n    @components[ needle ]\n\n  isRootComponent:()->\n    @rootComponent is true || !@getParent?\n\n  getRootComponent: ()->\n    if @isRootComponent() then @ else @getParent().getRootComponent()\n\n\n  selectByAttribute: (attribute, value=undefined, deep=false)->\n    components = _( @components ).map (component)->\n      matches = []\n      test = component[ attribute ]\n\n      matches.push( component ) if test is value or (not value? and test?)\n\n      # recursively traverse our components\n      matches.push component.selectByAttribute?(attribute, value, true) if deep is true\n\n      _.compact matches\n\n    _.flatten( components )\n\n\ncontainer.register()\n\n# This is the method by which a container injects the rendered child views\n# into the DOM.  It will get passed the container object, and the component\n# that is being rendered.\nLuca.Container.componentRenderer = (container, component)->\n  attachMethod = $( component.container )[ component.attachWith || \"append\" ]\n  attachMethod( component.render().el )\n\n\n#### Private Helpers\n\ndoLayout = ()->\n  @trigger \"before:layout\", @\n  @prepareLayout()\n  @trigger \"after:layout\", @\n\napplyDOMConfig = (panel, panelIndex)->\n  style_declarations = []\n\n  style_declarations.push \"height: #{ (if _.isNumber(panel.height) then panel.height + 'px' else panel.height ) }\" if panel.height?\n  style_declarations.push \"width: #{ (if _.isNumber(panel.width) then panel.width + 'px' else panel.width ) }\" if panel.width?\n  style_declarations.push \"float: #{ panel.float }\" if panel.float\n\n  config =\n    class: panel?.classes || @componentClass\n    id: \"#{ @cid }-#{ panelIndex }\"\n    style: style_declarations.join(';')\n    \"data-luca-parent\" : @name || @cid\n\n  if @customizeContainerEl?\n   config = @customizeContainerEl( config, panel, panelIndex )\n\n  config\n\n\n\ncreateGetterMethods = ()->\n  container = @\n\n  childrenWithGetter = _( @allChildren() ).select (component)->\n    component?.getter?\n\n  _( childrenWithGetter ).each (component)->\n    container[ component.getter ] ||= ()-> component\n\ncreateMethodsToGetComponentsByRole = ()->\n  container = @\n\n  childrenWithRole = _( @allChildren() ).select (component)->\n    component?.role?\n\n  _( childrenWithRole ).each (component)->\n    getter = _.str.camelize( \"get_\" + component.role )\n    getterFn = ()-> component\n    container[ getter ] ||= _.bind(getterFn, container) \n\ndoComponents = ()->\n  @trigger \"before:components\", @, @components\n  @prepareComponents()\n  @trigger \"before:create:components\", @, @components\n  @createComponents()\n  @trigger \"before:render:components\", @, @components\n  @renderComponents()\n  @trigger \"after:components\", @, @components\n\n  unless @skipGetterMethods is true\n    createGetterMethods.call(@)\n    createMethodsToGetComponentsByRole.call(@)\n\n  @registerComponentEvents()\n\nvalidateContainerConfiguration = ()->\n  true\n\n# indexComponent( component ).at( index ).in( componentsInternalIndexMap )\nindexComponent = (component)->\n  at: (index)->\n    in: (map)->\n      if component.cid?\n        map.cid_index[ component.cid ] = index\n      if component.role?\n        map.role_index[ component.role ] = index\n      if component.name?\n        map.name_index[ component.name ] = index\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/modal_view.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/modal_view.coffee","type":"component_definition","starts_on_line":1,"class_name":"Luca.containers.ModalView","header_documentation":"","type_alias":"modal_view","css_class_identifier":"luca-containers-modal-view","defines_methods":{"container":{"defined_on_line":11,"documentation":"","arguments":[]},"toggle":{"defined_on_line":14,"documentation":"","arguments":[]},"show":{"defined_on_line":17,"documentation":"","arguments":[]},"hide":{"defined_on_line":20,"documentation":"","arguments":[]},"render":{"defined_on_line":23,"documentation":"","arguments":[]}},"defines_properties":{"closeOnEscape":{"defined_on_line":5,"documentation":"","default":"true"},"showOnInitialize":{"defined_on_line":6,"documentation":"","default":"false"},"backdrop":{"defined_on_line":7,"documentation":"","default":"false"},"className":{"defined_on_line":8,"documentation":"","default":"\"modal\""}},"source_file_contents":"view = Luca.register      \"Luca.containers.ModalView\"\nview.extends              \"Luca.Container\"\n\nview.publicConfiguration\n  closeOnEscape: true\n  showOnInitialize: false\n  backdrop: false\n  className: \"modal\"\n\nview.publicMethods\n  container: ()->\n    $('body')\n\n  toggle: ()->\n    @$el.modal('toggle')\n\n  show: ()->\n    @$el.modal('show')\n\n  hide: ()->\n    @$el.modal('hide')\n\n  render: ()->\n    @$el.addClass 'modal'\n    @$el.addClass 'fade' if @fade is true\n\n    $('body').append( @$el )\n    \n    @$el.modal\n      backdrop: !!(@backdrop is true)\n      keyboard: !!(@closeOnEscape is true)\n      show: !!(@showOnInitialize is true)\n\n    @\n\nview.register()\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/page_controller.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/page_controller.coffee","type":"component_definition","starts_on_line":13,"class_name":"Luca.containers.PageController","header_documentation":"<p>The PageController container is a special type of container whose components or pages\nwill always monopolize the entire element&#39;s display and where only one page or component\nwill be visible at a time.  The PageController is typically going to be at the very root\nof every application, and will be directly integrated with the application&#39;s router. \nA typical application hierarchy will be an abstract <code>Viewport</code> with a single top level\n<code>PageController</code> named &#39;main_controller&#39;. \n      - Viewport / Application\n        - Router. ( maps urls to named pages on the controller )\n        - Main Page Controller\n          - Pages\n            - Named views / containers</p>\n","type_alias":"page_controller","css_class_identifier":"luca-containers-page-controller","defines_methods":{"initialize":{"defined_on_line":17,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]}},"defines_properties":{},"source_file_contents":"# The PageController container is a special type of container whose components or pages\n# will always monopolize the entire element's display and where only one page or component\n# will be visible at a time.  The PageController is typically going to be at the very root\n# of every application, and will be directly integrated with the application's router. \n# A typical application hierarchy will be an abstract `Viewport` with a single top level\n# `PageController` named 'main_controller'. \n#\n#       - Viewport / Application\n#         - Router. ( maps urls to named pages on the controller )\n#         - Main Page Controller\n#           - Pages\n#             - Named views / containers\nview = Luca.register    \"Luca.containers.PageController\"\nview.extends            \"Luca.Container\"\n\nview.privateMethods\n  initialize: (@options={})->\n    @components ||= @pages || @options.pages\n    for component in @components\n      component.components ||= component.pages\n\n    Luca.Container::initialize.apply(@, arguments)\n\nview.register()  \n\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/panel_toolbar.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/panel_toolbar.coffee","type":"component_definition","starts_on_line":1,"class_name":"Luca.PanelToolbar","header_documentation":"<p>The Panel Toolbar is a collection of buttons and / or dropdowns</p>\n","type_alias":"panel_toolbar","css_class_identifier":"luca-panel-toolbar","defines_methods":{"initialize":{"defined_on_line":29,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"clickHandler":{"defined_on_line":43,"documentation":"<p>The Toolbar behaves by triggering events on the components which they\nbelong to. Combined with Luca.View::setupHooks it is a clean way\nto organize actions</p>\n","arguments":[{"argument":"e","value":null}]},"beforeRender":{"defined_on_line":61,"documentation":"","arguments":[]},"render":{"defined_on_line":72,"documentation":"","arguments":[]}},"defines_properties":{"buttons":{"defined_on_line":20,"documentation":"<p>@buttons is an array of button config objects\nbutton config accepts the following paramters:</p>\n\n<p>label       what should the button say\neventId     what event should the button trigger\ndropdown    an array of arrays: [eventId, label]\ngroup       an array of button configs\nwrapper     a css class, in addition to btn-group\nicon        which icon do you want to use on this button?\nwhite       true or false: is it a white colored text?\ncolor       options are primary, info, success, warning, danger, inverse</p>\n","default":"[]"},"orientation":{"defined_on_line":22,"documentation":"","default":"'top'"},"autoBindEventHandlers":{"defined_on_line":24,"documentation":"","default":"true"},"events":{"defined_on_line":26,"documentation":"","default":null}},"source_file_contents":"panelToolbar = Luca.register        \"Luca.PanelToolbar\"\n# The Panel Toolbar is a collection of buttons and / or dropdowns\n# which are automatically created by BasicPanel classes, or can be\n# added to any other view component.\npanelToolbar.extends                \"Luca.View\"\n\n\npanelToolbar.defines\n  # @buttons is an array of button config objects\n  # button config accepts the following paramters:\n  #\n  # label       what should the button say\n  # eventId     what event should the button trigger\n  # dropdown    an array of arrays: [eventId, label]\n  # group       an array of button configs\n  # wrapper     a css class, in addition to btn-group\n  # icon        which icon do you want to use on this button?\n  # white       true or false: is it a white colored text?\n  # color       options are primary, info, success, warning, danger, inverse\n  buttons:[]\n\n  orientation: 'top'\n\n  autoBindEventHandlers: true\n\n  events:\n    \"click a.btn, click .dropdown-menu li\" : \"clickHandler\"\n\n  initialize: (@options={})->\n    @_super(\"initialize\", @, arguments)\n\n    # if the toolbar consists of a single button group\n    # don't make the developer specify buttons = {buttons:[group:true, buttons:[...]]}\n    if @group is true and @buttons?.length >= 0\n      @buttons = [\n        group: true\n        buttons: @buttons\n      ]\n\n  # The Toolbar behaves by triggering events on the components which they\n  # belong to. Combined with Luca.View::setupHooks it is a clean way\n  # to organize actions\n  clickHandler: (e)->\n    me = my = $( e.target )\n    me = my = $( e.target ).parent() if me.is('i')\n\n    if @selectable is true\n      my.siblings().removeClass(\"is-selected\")\n      me.addClass('is-selected')\n\n    return unless eventId = my.data('eventid')\n\n    hook = Luca.util.hook( eventId )\n\n    source = @parent || @\n    if _.isFunction( source[hook] )\n      source[ hook ].call(@, me, e)\n    else\n      source.trigger(eventId, me, e)\n\n  beforeRender:()->\n    @_super(\"beforeRender\", @, arguments)\n\n    if @well is true\n      @$el.addClass 'well'\n\n    @$el.addClass 'btn-selectable' if @selectable is true\n    @$el.addClass \"toolbar-#{ @orientation }\"\n    @$el.addClass \"pull-right\" if @align is \"right\"\n    @$el.addClass \"pull-left\" if @align is \"left\"\n\n  render: ()->\n    @$el.empty()\n    @$el.append( element ) for element in prepareButtons(@buttons)\n    @\n\n\nmake = Luca.View::make\n\nbuildButton = (config, wrap=true)->\n  if config.ctype? or config.type?\n    config.className ||= \"\"\n    config.className += 'toolbar-component'\n\n    object = Luca(config).render()\n\n    if Luca.isBackboneView(object)\n      return object.$el\n\n  if config.spacer\n    return make \"div\", class: \"spacer #{ config.spacer }\"\n\n  if config.text\n    return make \"div\", {class: \"toolbar-text\"}, config.text\n\n  wrapper = 'btn-group'\n  wrapper += \"#{ config.wrapper }\" if config.wrapper?\n  wrapper += \"pull-#{ config.align } align-#{ config.align }\" if config.align?\n  wrapper += 'btn-selectable' if config.selectable is true\n\n  # if we're passed a group, then we need to just\n  # wrap the contents of the buttons property in that group\n  # skipping the btn-group wrapping that takes place for\n  # individual buttons\n  if config.group? and config.buttons?\n    buttons = prepareButtons( config.buttons, false )\n    return make \"div\", class: wrapper, buttons\n\n  # if it is a normal button, and not a button group\n  else\n    label = config.label ||= \"\"\n\n    config.eventId ||= _.string.dasherize( config.label.toLowerCase() )\n\n    if config.icon\n      label = \" \" if _.string.isBlank( label )\n      white = \"icon-white\" if config.white\n      label = \"<i class='#{ white || \"\" } icon-#{ config.icon }' /> #{ label }\"\n\n    buttonAttributes =\n      class: _.compact([\"btn\",config.classes,config.className]).join(\" \")\n      \"data-eventId\" : config.eventId\n      title: config.title || config.description\n\n    buttonAttributes[\"class\"] += \" btn-#{ config.color }\" if config.color?\n    buttonAttributes[\"class\"] += \" is-selected\" if config.selected?\n\n    if config.dropdown\n      label = \"#{ label } <span class='caret'></span>\"\n      buttonAttributes[\"class\"] += \" dropdown-toggle\"\n      buttonAttributes[\"data-toggle\"] = \"dropdown\"\n\n      dropdownItems = for dropdownItem in config.dropdown\n        if _.isObject(dropdownItem)\n          dropdownItem = _.values(dropdownItem).reverse()\n\n        link = make \"a\", {}, dropdownItem[1]\n        make \"li\", {\"data-eventId\": dropdownItem[0]}, link\n\n      dropdownEl = make \"ul\", {class:\"dropdown-menu\"}, dropdownItems\n\n    buttonEl = make \"a\", buttonAttributes, label\n\n    # needs to be wrapped for proper rendering, but not\n    # if it already is part of a group\n    autoWrapClass = \"btn-group\"\n    autoWrapClass += \" align-#{ config.align }\" if config.align?\n\n    if wrap is true\n      return make \"div\", {class: autoWrapClass}, [buttonEl,dropdownEl]\n    else\n      # for buttons which are already part f a group\n      buttonEl\n\nprepareButtons = (buttons=[], wrap=true)->\n  buildButton(button, wrap) for  button in buttons\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/tab_view.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/tab_view.coffee","type":"component_definition","starts_on_line":1,"class_name":"Luca.containers.TabView","header_documentation":"","type_alias":"tab_view","css_class_identifier":"luca-containers-tab-view","defines_methods":{"initialize":{"defined_on_line":19,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"activeTabSelector":{"defined_on_line":30,"documentation":"","arguments":[]},"beforeLayout":{"defined_on_line":33,"documentation":"","arguments":[]},"afterRender":{"defined_on_line":41,"documentation":"","arguments":[]},"createTabSelectors":{"defined_on_line":50,"documentation":"","arguments":[]},"highlightSelectedTab":{"defined_on_line":63,"documentation":"","arguments":[]},"tabSelectClickHandler":{"defined_on_line":67,"documentation":"","arguments":[{"argument":"e","value":null}]},"select":{"defined_on_line":75,"documentation":"","arguments":[{"argument":"tabName","value":"0"}]},"componentElements":{"defined_on_line":80,"documentation":"","arguments":[]},"tabContentWrapper":{"defined_on_line":83,"documentation":"","arguments":[]},"tabContainerWrapper":{"defined_on_line":86,"documentation":"","arguments":[]},"tabContainer":{"defined_on_line":89,"documentation":"","arguments":[]},"tabSelectors":{"defined_on_line":92,"documentation":"","arguments":[]},"bodyTemplateVars":{"defined_on_line":95,"documentation":"","arguments":[]}},"defines_properties":{"tab_position":{"defined_on_line":8,"documentation":"","default":"'top'"},"tabVerticalOffset":{"defined_on_line":9,"documentation":"","default":"'50px'"},"additionalClassNames":{"defined_on_line":12,"documentation":"","default":"'tabbable'"},"navClass":{"defined_on_line":13,"documentation":"","default":"\"nav-tabs\""},"bodyTemplate":{"defined_on_line":14,"documentation":"","default":"\"containers/tab_view\""},"bodyClassName":{"defined_on_line":15,"documentation":"","default":"\"tab-content\""},"skipGetterMethods":{"defined_on_line":16,"documentation":"","default":"true"}},"source_file_contents":"tabView = Luca.register       \"Luca.containers.TabView\"\ntabView.extends               \"Luca.containers.CardView\"\n\ntabView.triggers              \"before:select\",\n                              \"after:select\"\n\ntabView.publicConfiguration\n  tab_position: 'top'\n  tabVerticalOffset: '50px'\n\ntabView.privateConfiguration\n  additionalClassNames: 'tabbable'\n  navClass: \"nav-tabs\"\n  bodyTemplate: \"containers/tab_view\"\n  bodyClassName: \"tab-content\"\n  skipGetterMethods: true\n\ntabView.defines\n  initialize: (@options={})->\n    @navClass = \"nav-list\"if @navStyle is \"list\"\n\n    Luca.containers.CardView::initialize.apply @, arguments\n\n    _.bindAll @, \"select\", \"highlightSelectedTab\"\n\n    @setupHooks( @hooks )\n\n    @bind \"after:card:switch\", @highlightSelectedTab\n\n  activeTabSelector: ()->\n    @tabSelectors().eq( @activeCard || @activeTab || @activeItem )\n\n  beforeLayout: ()->\n    @$el.addClass(\"tabs-#{ @tab_position }\")\n    @activeTabSelector().addClass 'active'\n\n    @createTabSelectors()\n\n    Luca.containers.CardView::beforeLayout?.apply @, arguments\n\n  afterRender: ()->\n    Luca.containers.CardView::afterRender?.apply @, arguments\n    tabContainerId = @tabContainer().attr(\"id\")\n    @registerEvent(\"click ##{ tabContainerId } li a\", \"tabSelectClickHandler\")\n\n    if Luca.config.enableBootstrap and (@tab_position is \"left\" or @tab_position is \"right\")\n      @tabContainerWrapper().addClass(\"span2\")\n      @tabContentWrapper().addClass(\"span9\")\n\n  createTabSelectors: ()->\n    tabView = @\n    @each (component,index)->\n      icon = \"<i class='icon-#{ component.tabIcon }'></i>\" if component.tabIcon\n      link = \"<a href='#'>#{ icon || ''} #{ component.title }</a>\"\n      selector = tabView.make(\"li\",{class:\"tab-selector\",\"data-target\":index}, link)\n      tabView.tabContainer().append(selector)\n\n      if component.navHeading? and not tabView.navHeadings?[ component.navHeading ]\n        $( selector ).before( tabView.make('li',{class:\"nav-header\"}, component.navHeading))\n        tabView.navHeadings ||= {}\n        tabView.navHeadings[ component.navHeading ] = true\n\n  highlightSelectedTab: ()->\n    @tabSelectors().removeClass('active')\n    @activeTabSelector().addClass('active')\n\n  tabSelectClickHandler: (e)->\n    e?.preventDefault()\n    me = my = $( e.target )\n    me = my ||= @tabSelectors()[0]\n    tabName = my.parent().data('target')\n\n    @select(tabName)\n\n  select: (tabName=0)->\n    @trigger \"before:select\", @\n    @activate(tabName)\n    @trigger \"after:select\", @\n\n  componentElements: ()->\n    @$(\">.tab-content >.#{ @componentClass }\")\n\n  tabContentWrapper: ()->\n    $(\"##{ @cid }-tab-view-content\")\n\n  tabContainerWrapper: ()->\n    $(\"##{ @cid }-tabs-selector\")\n\n  tabContainer: ()->\n    @$(\"ul.#{ @navClass }\", @tabContainerWrapper() )\n\n  tabSelectors: ()->\n    @$( 'li.tab-selector', @tabContainer() )\n\n  bodyTemplateVars: ()->\n    cid: @cid  \n    navClass: @navClass"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/viewport.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/viewport.coffee","type":"component_definition","starts_on_line":1,"class_name":"Luca.containers.Viewport","header_documentation":"","type_alias":"viewport","css_class_identifier":"luca-containers-viewport","defines_methods":{"initialize":{"defined_on_line":10,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"enableFluid":{"defined_on_line":21,"documentation":"","arguments":[{"argument":")-> @enableWrapper(","value":null}]},"disableFluid":{"defined_on_line":23,"documentation":"","arguments":[{"argument":")-> @disableWrapper(","value":null}]},"enableWrapper":{"defined_on_line":25,"documentation":"","arguments":[]},"disableWrapper":{"defined_on_line":29,"documentation":"","arguments":[]},"enableFullscreen":{"defined_on_line":33,"documentation":"","arguments":[]},"disableFullscreen":{"defined_on_line":37,"documentation":"","arguments":[]},"beforeRender":{"defined_on_line":41,"documentation":"","arguments":[]},"height":{"defined_on_line":47,"documentation":"","arguments":[]},"width":{"defined_on_line":50,"documentation":"","arguments":[]},"afterRender":{"defined_on_line":53,"documentation":"","arguments":[]},"renderTopNavigation":{"defined_on_line":59,"documentation":"","arguments":[]},"renderBottomNavigation":{"defined_on_line":74,"documentation":"","arguments":[]}},"defines_properties":{"fullscreen":{"defined_on_line":5,"documentation":"","default":"true"},"fluid":{"defined_on_line":6,"documentation":"","default":"false"},"applyWrapper":{"defined_on_line":8,"documentation":"","default":"true"}},"source_file_contents":"viewport = Luca.register    \"Luca.containers.Viewport\"\nviewport.extends            \"Luca.Container\"\n\nviewport.defines\n  fullscreen: true\n  fluid: false\n\n  applyWrapper: true\n\n  initialize: (@options={})->\n    _.extend @, @options\n\n    if Luca.config.enableBoostrap is true and @applyWrapper is true\n      @wrapperClass = if @fluid is true then Luca.config.fluidWrapperClass else Luca.config.wrapperClass\n\n    Luca.Container::initialize.apply(@, arguments)\n\n    if @fullscreen is true\n      @enableFullscreen() \n\n  enableFluid: ()-> @enableWrapper()\n\n  disableFluid: ()-> @disableWrapper()\n   \n  enableWrapper: ()->\n    if @wrapperClass?\n      @$el.parent().addClass( @wrapperClass ) \n\n  disableWrapper: ()->\n    if @wrapperClass?\n      @$el.parent().removeClass( @wrapperClass ) \n\n  enableFullscreen: ()->\n    $('html,body').addClass('luca-ui-fullscreen')\n    @$el.addClass('fullscreen-enabled')\n\n  disableFullscreen: ()->\n    $('html,body').removeClass('luca-ui-fullscreen')\n    @$el.removeClass('fullscreen-enabled')\n\n  beforeRender: ()->\n    Luca.Container::beforeRender?.apply(@, arguments)\n\n    @renderTopNavigation() if @topNav?\n    @renderBottomNavigation() if @bottomNav?\n\n  height: ()->\n    @$el.height()\n\n  width: ()->\n    @$el.width()\n\n  afterRender: ()->\n    Luca.Container::afterRender?.apply(@, arguments)\n\n    if Luca.config.enableBoostrap is true and @containerClassName\n      @$el.children().wrap('<div class=\"#{ containerClassName }\" />')\n\n  renderTopNavigation: ()->\n    return unless @topNav?\n\n    if _.isString( @topNav )\n      @topNav = Luca.util.lazyComponent(@topNav)\n\n    if _.isObject( @topNav )\n      @topNav.ctype ||= @topNav.type || \"nav_bar\"\n      unless Luca.isBackboneView(@topNav)\n        @topNav = Luca.util.lazyComponent( @topNav )\n\n    @topNav.app = @\n\n    $('body').prepend( @topNav.render().el )\n\n  renderBottomNavigation: ()->\n    # IMPLEMENT\n\n\nLuca.containers.Viewport.defaultWrapperClass  = Luca.config.wrapperClass || 'container'\nLuca.containers.Viewport.fluidWrapperClass    = Luca.config.fluidWrapperClass || 'container-fluid'\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/application.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/application.coffee","type":"component_definition","starts_on_line":63,"class_name":"Luca.Application","header_documentation":"<p>The <code>Luca.Application</code> is the main entry point into your Application.\nIt acts as a global state machine, page controller, and router, in addition\nto providing access to other singletons such as the CollectionManager, and SocketManager.</p>\n\n<p>The structure of a common <code>Luca.Application</code> is that it contains one or many <code>Pages</code> which\nthemselves are made up of the components of your application.  One <code>Page</code> is visible at a time\nand which page is displayed is managed by an instance of the <code>Luca.components.Controller</code> class.</p>\n\n<h3>Example Configuration</h3>\n\n<pre><code>application = Luca.register     &quot;App.Application&quot;\napplication.extends             &quot;Luca.Application&quot;\napplication.defines\n  name: &quot;MyApplication&quot;\n  routes: \n    &quot;&quot; : &quot;home&quot;\n    &quot;standard/backbone/style/:route&quot; : &quot;name_of_page#name_of_method&quot;\n  components:[\n    name: &quot;home&quot;\n  ,\n    type: &quot;your_view&quot;\n    name: &quot;name_of_page&quot;\n    name_of_method: (routeParam)-&gt;\n      @doSomethignToSetupYourPageWithThePassed(routeParam)  \n  ]\n</code></pre>\n\n<p>App.onReady ()-&gt;\n    window.MyApp = new App.Application();\n    window.MyApp.boot() </p>\n\n<h4>@routes and pages</h4>\n\n<p>In the above example, our application contains two pages, one with the name &#39;home&#39;\nand one with the name &#39;name<em>of</em>page&#39;.  It also specifies a <code>@routes</code> property which\nis identical to the configuration you would see in a standard <code>Backbone.Router</code>.\nWhenever the route matches &#39;standard/backbone/style/route&#39; the <code>App.Application</code> instance\nwill send an instruction to the <code>Luca.components.Controller</code> to <code>activate</code> the page whose name\nis passed in the <code>@routes</code> config.</p>\n\n<p>If that page defines a method called <code>@routeHandler</code> it will be called with the parameters\nfrom the route.  In the <code>@routes</code> config you can specify your own route handler method\nby using the rails style <code>page_name#action</code> and it will call the <code>@action</code> method instead\non the view named <code>page_name</code>.\nThe <code>App.Application</code> instance, also accessible by <code>window.MyApp</code>, or through the helper <code>App()</code>\nor <code>Luca.getApplication()</code> maintains the state of which page is active.  You can access this\nin your code by calling <code>App().activePage()</code>.</p>\n\n<h4>Controllers</h4>\n\n<p>The <code>Luca.components.Controller</code> is a special type of component which contains \nother views, or <code>Pages</code> which only one will be visible at any given time.  It expects\nthat each page will have its own unique <code>@name</code> property.  A <code>Luca.components.Controller</code> can\ncontain other controllers, providing you with a way of structuring your application layout\nin an organized, hierarchal fashion. \nBy default, any <code>Luca.Application</code> will have one <code>Luca.components.Controller</code> automatically\ncreated named &#39;main_controller&#39; which is accessible by <code>MyApp.getMainController()</code>.  Any\ncomponents you define on the <code>Luca.Application</code> instance will be wrapped by the main controller\nautomatically unless you specify <code>@useController = false</code> in your Application component definition.</p>\n","type_alias":"application","css_class_identifier":"luca-application","defines_methods":{"initialize":{"defined_on_line":161,"documentation":"<p>Creating your Application and all of its components and pages is\ngenerally as simple as creating an instance of your Application class:\nLuca.onReady ()-&gt;\nwindow.MyApp = new Luca.Application()\nwindow.MyApp.boot()</p>\n","arguments":[{"argument":"@options","value":"{}"}]},"activeView":{"defined_on_line":231,"documentation":"<p>@activeView() returns a reference to the instance of the view\nwhich is currently monopolizing the viewport.  In an application\nwhich uses a controller hierarchy, it will be the last controller\nhas activated one of its pages.</p>\n","arguments":[]},"activeSection":{"defined_on_line":238,"documentation":"<p>Returns the name of the active component on the main controller</p>\n","arguments":[]},"activeSubSection":{"defined_on_line":244,"documentation":"<p>Returns the name of the active component on the nested controllers\non the main controller, if there is one.  These get set on the\nstate machine in response to card switch events on the controller component</p>\n","arguments":[]},"activePages":{"defined_on_line":247,"documentation":"","arguments":[]},"boot":{"defined_on_line":259,"documentation":"<p>boot should trigger the ready event, which will call the initial call\nto render() your application, which will have a cascading effect on every\nsubcomponent in the view, recursively rendering everything which is set\nto automatically render (i.e. any non-deferrable components ).</p>\n\n<p>you should use boot to fire up any dependent collections, manager, any\nsort of data processing, whatever your application requires to run outside\nof the views</p>\n","arguments":[]},"collection":{"defined_on_line":266,"documentation":"<p>delegate to the collection manager&#39;s get or create function.\nuse App.collection() to create or access existing collections</p>\n","arguments":[]},"get":{"defined_on_line":270,"documentation":"<p>Get an attribute from our internal state machine</p>\n","arguments":[{"argument":"attribute","value":null}]},"set":{"defined_on_line":274,"documentation":"<p>Set an attribute on our internal state machine</p>\n","arguments":[{"argument":"attribute","value":null},{"argument":"value","value":null},{"argument":"options","value":null}]},"view":{"defined_on_line":278,"documentation":"<p>Access a named view by its @name property.</p>\n","arguments":[{"argument":"name","value":null}]},"navigate_to":{"defined_on_line":286,"documentation":"<p>delegate to the main controller so that we can switch the active section\neasily directly from the application.  If passed a callback, this function\nwill get called in the context of the activated component.  This method is useful\ninside of custom route handlers if you are manually defining them on a <code>Backbone.Router</code>\ninstead of using the built in <code>@routes</code> helper.</p>\n","arguments":[{"argument":"component_name","value":null},{"argument":"callback","value":null}]},"setupControllerBindings":{"defined_on_line":294,"documentation":"<p>Any time the Application&#39;s main controller changes its active page\nwe track the name of that page ( aka section ) on our state machine.\nIf the active page on the main controller is another controller component,\nthen we will track that controller&#39;s active component as our active sub section.</p>\n","arguments":[]},"setupMainController":{"defined_on_line":317,"documentation":"<p>A typical structure for a Luca.Application is that it will act as a <code>Viewport</code> which\nmonopolizes the entire top level element in your dom ( either the body tag, or a top\nlevel element just underneath it)  This <code>Viewport</code> is an abstract element where we can\nsetup global event bindings, like keyBindings and such.  The <code>Viewport</code> will generally\ncontain a <code>Luca.components.Controller</code> instance called &quot;main_controller&quot; that is responsible\nfor displaying the active page for a given route.</p>\n","arguments":[]},"setupCollectionManager":{"defined_on_line":336,"documentation":"","arguments":[]},"setupSocketManager":{"defined_on_line":373,"documentation":"<p>If our application is configured with a <code>@socketManagerOptions</code> property,\nit will create a socket manager instance for us automatically.  It won&#39;t\nstart the socket manager process until the <code>@boot()</code> method is called on the application.</p>\n","arguments":[]},"setupRouter":{"defined_on_line":382,"documentation":"<p>Sets up an instance of the Backbone.Router, and sets up the\ncall to start the history tracking API once the appropriate\napplication events have been fired.</p>\n","arguments":[]},"setupKeyHandler":{"defined_on_line":415,"documentation":"<p>The default implementation of setupKeyHandler is kept around for backward\ncompatibility purposes.  In Luca 1.0 we will be using keymaster.js for our\nkey binding setup.</p>\n","arguments":[]},"pageHierarchy":{"defined_on_line":434,"documentation":"<p>An application inspection helper, it describes the structure of this application&#39;s\ncontrolled components.  For an application that consists of multiple nested controllers\nit will recursively walk each controller and build a tree of the various pages / controlers.</p>\n","arguments":[]},"registerInstance":{"defined_on_line":453,"documentation":"<p>Registers this instance of the Luca.Appliction\nso that it is available via the Luca() helper, or through\na call to Luca.Application.get().</p>\n","arguments":[{"argument":"app","value":null}]},"checkForKeymaster":{"defined_on_line":459,"documentation":"<p>If the keymaster library is present, swap out the\nsetupKeyHandler method with something which will enable\nkeymaster support instead of our legacy system.</p>\n","arguments":[]},"routeTo":{"defined_on_line":473,"documentation":"<p>This is used internally by the Application as it sets up\nthe @routes property and uses it to configure the Luca.Router\ninstance for your app.  It allows you to specify the page you want\nto monopolize the viewport in your application by name, and regardless\nof how deeply nested that page may be among your controllers, it will know\nwhat to do.</p>\n","arguments":[{"argument":"pages...","value":null}]},"startHistory":{"defined_on_line":520,"documentation":"<p>Public: you can override Luca.Application.startHistory to\nmodify how Backbone.history.start is called.  This will get called\nby the Application instance in response to the @autoStartHistory property.</p>\n","arguments":[]}},"defines_properties":{"name":{"defined_on_line":70,"documentation":"","default":"\"MyApp\""},"stateful":{"defined_on_line":77,"documentation":"<p>The Application uses a Backbone.Model as a state machine, which\nallows you to get / set attributes, persist them somewhere, and\nmost importantly to bind to change events of certain attributes.</p>\n\n<p>the @defaultState property will be the default attributes</p>\n","default":"{}"},"autoBoot":{"defined_on_line":81,"documentation":"<p>if autoBoot is set to true, the application will\nattempt to boot on document ready.</p>\n","default":"false"},"autoStartHistory":{"defined_on_line":87,"documentation":"<p>automatically starts the @router if it exists,\nonce the components for the application have\nbeen created.  Pass the event name you want to\nlisten for on this component before you start history</p>\n","default":"\"before"},"pushState":{"defined_on_line":90,"documentation":"<p>use Backbone.history push state?</p>\n","default":"false"},"startHistorySilently":{"defined_on_line":94,"documentation":"<p>If the server renders the entire page\nfirst, then we should start history silently.</p>\n","default":"false"},"rootUrl":{"defined_on_line":99,"documentation":"<p>In cases where we use pushState, we need to tell\nthe application what the actual root url of our app\nis, since everything after would otherwise be a hashbang</p>\n","default":"undefined"},"useCollectionManager":{"defined_on_line":103,"documentation":"<p>we will create a collection manager singleton\nby default unless otherwise specified.</p>\n","default":"true"},"collectionManager":{"defined_on_line":107,"documentation":"<p>to pass options to the collection manager, set the @collectionManager\nhash which will get passed once the collection manager is created</p>\n","default":"{}"},"collectionManagerClass":{"defined_on_line":112,"documentation":"<p>by default we will use the standard collection manager which ships with\nLuca.  If you would like to use your own extension of the collection manager\njust pass a reference to the class you would like to use.</p>\n","default":"\"Luca.CollectionManager\""},"plugin":{"defined_on_line":117,"documentation":"<p>Luca plugin apps are apps which mount onto existing\nluca apps, and will not have the behavior of a main\napp which acts as a singleton</p>\n","default":"false"},"useController":{"defined_on_line":123,"documentation":"<p>by default, the application will use a controller\ncomponent, which is a card view container which shows\none view at a time.  this is useful for having an application\nwith several &#39;pages&#39; so to speak</p>\n","default":"true"},"mainControllerContainer":{"defined_on_line":128,"documentation":"<p>If your Application does not behave as a Viewport that monopolizes\nits entire element, but instead you wish to render the application\ncontroller to a specific element,  you can specify the css selector of that element.</p>\n","default":"undefined"},"keyEvents":{"defined_on_line":145,"documentation":"<p>keyEvents understands the following modifiers:\n- <code>\u21e7</code>, <code>shift</code>, <code>option</code>, <code>\u2325</code>, <code>alt</code>, <code>ctrl</code>, <code>control</code>, <code>command</code>, and <code>\u2318</code>.\nThe following special keys can be used for shortcuts:\n<code>backspace</code>, <code>tab</code>, <code>clear</code>, <code>enter</code>, <code>return</code>, <code>esc</code>, <code>escape</code>, <code>space</code>,\n<code>up</code>, <code>down</code>, <code>left</code>, <code>right</code>, <code>home</code>, <code>end</code>, <code>pageup</code>, <code>pagedown</code>, <code>del</code>, <code>delete</code>\nand <code>f1</code> through <code>f19</code>.</p>\n\n<p><strong>Note</strong>: This requires the keymaster.js library to be loaded.  This library is included\nwith the bundled dependencies that ship with Luca.</p>\n\n<p>Example:\napplication.configuration\nkeyEvents:\n&#39;\u2318+r, ctrl+r&#39;: &quot;keyHandlerFunction&quot;\nkeyHandlerFunction: -&gt; alert &#39;something + r was pressed&#39;</p>\n","default":"{}"},"createRoleBasedGetters":{"defined_on_line":148,"documentation":"<p>create getter methods for the various roles in the application&#39;s components on the application itself.</p>\n","default":"false"},"useSocketManager":{"defined_on_line":152,"documentation":"<p>create an instance of Luca.SocketManager which is a Backbone.Events style abstraction that\nsits on top of services like faye, or socket.io</p>\n","default":"false"},"socketManagerOptions":{"defined_on_line":153,"documentation":"","default":"{}"},"instances":{"defined_on_line":429,"documentation":"","default":"{}"}},"source_file_contents":"# The `Luca.Application` is the main entry point into your Application.\n# It acts as a global state machine, page controller, and router, in addition\n# to providing access to other singletons such as the CollectionManager, and SocketManager.\n# \n# The structure of a common `Luca.Application` is that it contains one or many `Pages` which\n# themselves are made up of the components of your application.  One `Page` is visible at a time\n# and which page is displayed is managed by an instance of the `Luca.components.Controller` class.\n#\n# ### Example Configuration  \n#     application = Luca.register     \"App.Application\"\n#     application.extends             \"Luca.Application\"\n#\n#     application.defines\n#       name: \"MyApplication\"\n#       routes: \n#         \"\" : \"home\"\n#         \"standard/backbone/style/:route\" : \"name_of_page#name_of_method\"\n#\n#       components:[\n#         name: \"home\"\n#       ,\n#         type: \"your_view\"\n#         name: \"name_of_page\"\n#         name_of_method: (routeParam)->\n#           @doSomethignToSetupYourPageWithThePassed(routeParam)  \n#       ]\n#\n#   App.onReady ()->\n#     window.MyApp = new App.Application();\n#     window.MyApp.boot() \n#\n# #### @routes and pages\n#\n# In the above example, our application contains two pages, one with the name 'home'\n# and one with the name 'name_of_page'.  It also specifies a `@routes` property which\n# is identical to the configuration you would see in a standard `Backbone.Router`.\n#\n# Whenever the route matches 'standard/backbone/style/route' the `App.Application` instance\n# will send an instruction to the `Luca.components.Controller` to `activate` the page whose name\n# is passed in the `@routes` config.\n# \n# If that page defines a method called `@routeHandler` it will be called with the parameters\n# from the route.  In the `@routes` config you can specify your own route handler method\n# by using the rails style `page_name#action` and it will call the `@action` method instead\n# on the view named `page_name`.\n#\n# The `App.Application` instance, also accessible by `window.MyApp`, or through the helper `App()`\n# or `Luca.getApplication()` maintains the state of which page is active.  You can access this\n# in your code by calling `App().activePage()`.\n#\n# #### Controllers\n# \n# The `Luca.components.Controller` is a special type of component which contains \n# other views, or `Pages` which only one will be visible at any given time.  It expects\n# that each page will have its own unique `@name` property.  A `Luca.components.Controller` can\n# contain other controllers, providing you with a way of structuring your application layout\n# in an organized, hierarchal fashion. \n#\n# By default, any `Luca.Application` will have one `Luca.components.Controller` automatically\n# created named 'main_controller' which is accessible by `MyApp.getMainController()`.  Any\n# components you define on the `Luca.Application` instance will be wrapped by the main controller\n# automatically unless you specify `@useController = false` in your Application component definition.\napplication = Luca.register       \"Luca.Application\"\napplication.extends               \"Luca.containers.Viewport\"\n\napplication.triggers              \"controller:change\",\n                                  \"action:change\"\n\napplication.publicConfiguration\n  name: \"MyApp\"\n\n  # The Application uses a Backbone.Model as a state machine, which\n  # allows you to get / set attributes, persist them somewhere, and\n  # most importantly to bind to change events of certain attributes.\n  #\n  # the @defaultState property will be the default attributes\n  stateful: {}\n\n  # if autoBoot is set to true, the application will\n  # attempt to boot on document ready.\n  autoBoot: false\n\n  # automatically starts the @router if it exists,\n  # once the components for the application have\n  # been created.  Pass the event name you want to\n  # listen for on this component before you start history\n  autoStartHistory: \"before:render\"\n\n  # use Backbone.history push state?\n  pushState: false\n\n  # If the server renders the entire page\n  # first, then we should start history silently.\n  startHistorySilently: false\n\n  # In cases where we use pushState, we need to tell\n  # the application what the actual root url of our app\n  # is, since everything after would otherwise be a hashbang \n  rootUrl: undefined\n  \n  # we will create a collection manager singleton\n  # by default unless otherwise specified.\n  useCollectionManager: true\n\n  # to pass options to the collection manager, set the @collectionManager\n  # hash which will get passed once the collection manager is created\n  collectionManager: {}\n\n  # by default we will use the standard collection manager which ships with\n  # Luca.  If you would like to use your own extension of the collection manager\n  # just pass a reference to the class you would like to use.\n  collectionManagerClass: \"Luca.CollectionManager\"\n\n  # Luca plugin apps are apps which mount onto existing\n  # luca apps, and will not have the behavior of a main\n  # app which acts as a singleton\n  plugin: false\n\n  # by default, the application will use a controller\n  # component, which is a card view container which shows\n  # one view at a time.  this is useful for having an application\n  # with several 'pages' so to speak\n  useController: true\n\n  # If your Application does not behave as a Viewport that monopolizes\n  # its entire element, but instead you wish to render the application\n  # controller to a specific element,  you can specify the css selector of that element.\n  mainControllerContainer: undefined\n\n  # keyEvents understands the following modifiers:\n  # - `\u21e7`, `shift`, `option`, `\u2325`, `alt`, `ctrl`, `control`, `command`, and `\u2318`.\n  # The following special keys can be used for shortcuts:\n  # `backspace`, `tab`, `clear`, `enter`, `return`, `esc`, `escape`, `space`,\n  # `up`, `down`, `left`, `right`, `home`, `end`, `pageup`, `pagedown`, `del`, `delete`\n  # and `f1` through `f19`.\n  #\n  # **Note**: This requires the keymaster.js library to be loaded.  This library is included\n  # with the bundled dependencies that ship with Luca.\n  #\n  # Example:\n  #       application.configuration\n  #         keyEvents:\n  #           '\u2318+r, ctrl+r': \"keyHandlerFunction\"\n  #         keyHandlerFunction: -> alert 'something + r was pressed'\n  keyEvents: {}\n\n  # create getter methods for the various roles in the application's components on the application itself.\n  createRoleBasedGetters: false\n\n  # create an instance of Luca.SocketManager which is a Backbone.Events style abstraction that\n  # sits on top of services like faye, or socket.io \n  useSocketManager: false\n  socketManagerOptions: {}\n\napplication.publicMethods\n  # Creating your Application and all of its components and pages is \n  # generally as simple as creating an instance of your Application class:\n  #       Luca.onReady ()->\n  #         window.MyApp = new Luca.Application() \n  #         window.MyApp.boot()\n  initialize: (@options={})->\n    app             = @\n    appName         = @name\n    alreadyRunning  = Luca.getApplication?()\n\n    Luca.Application.registerInstance(@)\n\n    Luca.concerns.StateModel.__initializer.call(@)\n\n    # The Collection Manager is responsible for managing instances \n    # of collections, usually to guarantee only a single collection is\n    # instantiated for a given resource, to maintain 'authoritative' \n    # representations of models.\n    @setupCollectionManager()\n\n    # Socket Manager provides a bridge between remote pub/sub providers and \n    # the backbone.events interface on various components in the system.\n    @setupSocketManager()\n\n    Luca.containers.Viewport::initialize.apply @, arguments\n\n    # The Controller is the piece of the application that handles showing\n    # and hiding 'pages' of the app.  The Application has a navigate_to\n    # method which delegates to the controller, and allows you to navigate\n    # to a given page, or component, by its name.  The controller integrates\n    # with the state machine of the application\n    @setupMainController() if @useController is true \n\n    # we will render when all of the various components\n    # which handle our data dependencies determine that\n    # we are ready\n    @defer(()-> app.render()).until(@, \"ready\")\n\n    # Set up the Backbone Router\n    @setupRouter()\n\n    # the keyHandler allows us to specify\n    # keyEvents on our application with an API very similar\n    # to the DOM events API for Backbone.View\n    #\n    # Example:\n    #\n    # keyEvents:\n    #   meta:\n    #     forwardslash: \"altSlashHandler\"\n    if (@useKeyHandler is true or @useKeyRouter is true) and @keyEvents?\n      @setupKeyHandler() \n\n    # if the application is a plugin designed to modify the behavior\n    # of another app, then don't claim ownership.  otherwise the most common\n    # use-case is that there will be one application instance\n    unless @plugin is true or alreadyRunning\n      Luca.getApplication = (name)=>\n        return app unless name?\n        Luca.Application.instances[ name ]\n\n    if @autoBoot\n      if Luca.util.resolve(@name)\n        throw \"Attempting to override window.#{ @name } when it already exists\"\n\n      $ ->\n        window[ appName ] = app\n        app.boot()\n\n    Luca.trigger \"application:available\", @\n\n  # @activeView() returns a reference to the instance of the view\n  # which is currently monopolizing the viewport.  In an application\n  # which uses a controller hierarchy, it will be the last controller\n  # has activated one of its pages.\n  activeView: ()->\n    if active = @activeSubSection()\n      @view( active )\n    else\n      @view( @activeSection() )\n\n  # Returns the name of the active component on the main controller\n  activeSection: ()->\n    @get(\"active_section\")\n\n  # Returns the name of the active component on the nested controllers\n  # on the main controller, if there is one.  These get set on the\n  # state machine in response to card switch events on the controller component\n  activeSubSection: ()->\n    @get(\"active_sub_section\")\n\n  activePages: ()->\n    console.log \"This method will be getting removed in Luca 1.0\"\n    @$('.luca-controller').map (index,element)=> $(element).data('active-section')\n\n  # boot should trigger the ready event, which will call the initial call\n  # to render() your application, which will have a cascading effect on every\n  # subcomponent in the view, recursively rendering everything which is set\n  # to automatically render (i.e. any non-deferrable components ).\n  #\n  # you should use boot to fire up any dependent collections, manager, any\n  # sort of data processing, whatever your application requires to run outside\n  # of the views\n  boot: ()->\n    @trigger \"ready\"\n    for service in [@collectionManager, @socket, @router]\n      service?.trigger(\"ready\")\n\n  # delegate to the collection manager's get or create function.\n  # use App.collection() to create or access existing collections\n  collection: ()->\n    @collectionManager.getOrCreate.apply(@collectionManager, arguments)\n\n  # Get an attribute from our internal state machine\n  get: (attribute)->\n    @state.get(attribute)\n\n  # Set an attribute on our internal state machine\n  set: (attribute, value, options)->\n    @state.set.apply(@state, arguments)\n\n  # Access a named view by its @name property. \n  view: (name)->\n    Luca.cache(name)\n\n  # delegate to the main controller so that we can switch the active section\n  # easily directly from the application.  If passed a callback, this function\n  # will get called in the context of the activated component.  This method is useful\n  # inside of custom route handlers if you are manually defining them on a `Backbone.Router`\n  # instead of using the built in `@routes` helper.\n  navigate_to: (component_name, callback)->\n    @getMainController().navigate_to(component_name, callback)\n\napplication.privateMethods\n  # Any time the Application's main controller changes its active page\n  # we track the name of that page ( aka section ) on our state machine.\n  # If the active page on the main controller is another controller component,\n  # then we will track that controller's active component as our active sub section.\n  setupControllerBindings: ()->\n    app = @\n    # any time the main controller card switches we should track\n    # the active card on the global state chart\n    @getMainController()?.bind \"after:card:switch\", (previous,current)=>\n      @state.set(active_section:current.name)\n      app.trigger \"controller:change\", previous.name, current.name\n\n    # any time the card switches on one of the sub controllers\n    # then we should track the active sub section on the global state chart\n    @getMainController()?.each (component)=>\n      type = component.type || component.ctype\n      if type.match(/controller$/)\n        component.bind \"after:card:switch\", (previous,current)=>\n          @state.set(active_sub_section:current.name)\n          app.trigger \"action:change\", previous.name, current.name\n\n  # A typical structure for a Luca.Application is that it will act as a `Viewport` which\n  # monopolizes the entire top level element in your dom ( either the body tag, or a top \n  # level element just underneath it)  This `Viewport` is an abstract element where we can\n  # setup global event bindings, like keyBindings and such.  The `Viewport` will generally\n  # contain a `Luca.components.Controller` instance called \"main_controller\" that is responsible\n  # for displaying the active page for a given route. \n  setupMainController: ()->\n    if @useController is true\n      definedComponents = @components || []\n      base =  \n        type: 'controller'\n        name: \"main_controller\"\n        role: \"main_controller\"\n        components: definedComponents\n\n      if @mainControllerContainer?\n        _.extend(base, container: @mainControllerContainer)\n\n      @components = [base]\n    \n    @getMainController = ()=> \n      @findComponentByRole('main_controller')\n\n    @defer( @setupControllerBindings, false ).until(\"after:components\")\n\n  setupCollectionManager: ()->\n    return unless @useCollectionManager is true\n\n    return if @collectionManager? and @collectionManager?.get?\n\n    if _.isString( @collectionManagerClass )\n      @collectionManagerClass = Luca.util.resolve( @collectionManagerClass )\n\n    collectionManagerOptions = @collectionManagerOptions || {}\n\n    # if the collectionManager property is present, and it\n    # isn't a reference to a collection manager instance, then\n    # it is being used as a configuration hash for when we do create\n    # the collection manager. so let's stash it.\n    if _.isObject(@collectionManager) and not _.isFunction( @collectionManager?.get )\n      collectionManagerOptions = @collectionManager\n      @collectionManager = undefined\n\n    # if the collection manager property is a string, then it is a\n    # reference to a name of a collection manager to use.  so let's\n    # stash it\n    if _.isString(@collectionManager)\n      collectionManagerOptions =\n        name: @collectionManager\n\n\n    # let's try and get the collection manager by name if we can\n    @collectionManager = Luca.CollectionManager.get?( collectionManagerOptions.name )\n\n    # if we can't, then we will have to create one ourselves\n    unless _.isFunction(@collectionManager?.get)\n      collectionManagerOptions.autoStart = false\n      @collectionManager = new @collectionManagerClass( collectionManagerOptions )\n\n  # If our application is configured with a `@socketManagerOptions` property,\n  # it will create a socket manager instance for us automatically.  It won't\n  # start the socket manager process until the `@boot()` method is called on the application. \n  setupSocketManager: ()->\n    return if _.isEmpty(@socketManagerOptions)\n    _.extend(@socketManagerOptions, autoStart: false)\n\n    @socket = new Luca.SocketManager(@socketManagerOptions) \n \n  # Sets up an instance of the Backbone.Router, and sets up the\n  # call to start the history tracking API once the appropriate\n  # application events have been fired. \n  setupRouter: ()->\n    return if not @router? and not @routes?\n\n    routerClass = Luca.Router\n    routerClass = Luca.util.resolve(@router) if _.isString(@router)\n\n    routerConfig = routerClass.prototype\n    routerConfig.routes ||= {}\n    routerConfig.app = @\n\n    if _.isObject( @routes )\n      for routePattern, endpoint of @routes\n        if endpoint.match(/\\ /)\n          [page, action] = endpoint.split(' ')\n        else if endpoint.match(/\\#/)\n          [page, action] = endpoint.split('#')\n\n        fn = _.uniqueId(page)\n        routerConfig[fn] = Luca.Application.routeTo(page).action(action)\n        routerConfig.routes[ routePattern ] = fn\n\n    @router = new routerClass(routerConfig) \n\n    # if this application has a router associated with it\n    # then we need to start backbone history on a certain event.\n    # you can control which by setting the @startHistoryOn property\n    if @router and @autoStartHistory\n      @autoStartHistory = \"before:render\" if @autoStartHistory is true\n      @defer( Luca.Application.startHistory, false).until(@, @autoStartHistory)\n\n  # The default implementation of setupKeyHandler is kept around for backward\n  # compatibility purposes.  In Luca 1.0 we will be using keymaster.js for our\n  # key binding setup. \n  setupKeyHandler: ()->\n    return unless @keyEvents\n\n    @keyEvents.control_meta ||= {}\n\n    # allow for both meta_control, control_meta for the combo\n    _.extend(@keyEvents.control_meta, @keyEvents.meta_control) if @keyEvents.meta_control\n\n    handler = _.bind(@keyHandler, @)\n\n    for keyEvent in (@keypressEvents || [\"keydown\"])\n      $( document ).on( keyEvent, handler )\n\napplication.classMethods\n  instances:{}\n\n  # An application inspection helper, it describes the structure of this application's\n  # controlled components.  For an application that consists of multiple nested controllers\n  # it will recursively walk each controller and build a tree of the various pages / controlers.\n  pageHierarchy: ()->\n    app             = Luca()\n    mainController  = app.getMainController()\n\n    getTree = (node)->  \n      return {} unless node.components? or node.pages?\n\n      # recursively walks the pages on a controller\n      _( node.components || node.pages ).reduce (memo, page)->\n        memo[ page.name ] = page.name\n        memo[ page.name ] = getTree(page) if page.navigate_to?\n        memo\n      , {}\n\n    getTree( mainController )\n\n  # Registers this instance of the Luca.Appliction\n  # so that it is available via the Luca() helper, or through\n  # a call to Luca.Application.get().\n  registerInstance: (app)->\n    Luca.Application.instances[ app.name ] = app\n\n  # If the keymaster library is present, swap out the \n  # setupKeyHandler method with something which will enable \n  # keymaster support instead of our legacy system.\n  checkForKeymaster: ()->\n    if window?.key?.noConflict\n      Luca.key = window.key.noConflict()\n\n      Luca.Application::setupKeyHandler = ()->\n        return unless @keyEvents\n        Luca.util.setupKeymaster(@keyEvents, \"all\").on(@)\n\n  # This is used internally by the Application as it sets up\n  # the @routes property and uses it to configure the Luca.Router\n  # instance for your app.  It allows you to specify the page you want\n  # to monopolize the viewport in your application by name, and regardless\n  # of how deeply nested that page may be among your controllers, it will know \n  # what to do.  \n  routeTo: (pages...)->\n    last = _( pages ).last()\n    first = _( pages ).first()\n\n    callback = undefined    \n    specifiedAction = undefined\n\n    routeHelper = (args...)->\n      path = @app || Luca()\n      index = 0\n\n      # we can specify a page by name, and not have to know its full path.\n      if pages.length is 1 and target = Luca(first)\n        pages = target.controllerPath()\n\n      # when we do know the full path\n      for page in pages when _.isString(page)\n        nextItem = pages[++index]\n        target = Luca(page)\n\n        if page is last \n          if specifiedAction? and not target[specifiedAction]? and not target.routeHandler?\n            console.log \"You specified a component action to call when a route matches, but it does not exist on the component\"\n\n          callback = if specifiedAction? and target[ specifiedAction ]?\n            _.bind(target[ specifiedAction ], target)\n          else if target.routeHandler?\n            target.routeHandler  \n\n        callback ||= if _.isFunction(nextItem)\n          _.bind(nextItem, target)\n        else if _.isObject(nextItem) \n          if action = nextItem.action and target[action]?\n            _.bind(target[action], target)\n\n        path = path.navigate_to page, ()->\n          callback?.apply(target, args)\n\n    routeHelper.action = (action)->\n      specifiedAction = action\n      routeHelper\n\n    routeHelper\n\n  # Public: you can override Luca.Application.startHistory to \n  # modify how Backbone.history.start is called.  This will get called\n  # by the Application instance in response to the @autoStartHistory property.\n  startHistory: ()->\n    Backbone.history.start\n      pushState: @pushState\n      rootUrl: @rootUrl\n      silent: @startHistorySilently\n\napplication.afterDefinition ()->\n  Luca.routeHelper = Luca.Application.routeTo\n  Luca.Application.checkForKeymaster()\n\napplication.register()"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/collection_loader_view.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/collection_loader_view.coffee","type":"component_definition","starts_on_line":6,"class_name":"Luca.components.CollectionLoaderView","header_documentation":"<p>Collection Loader View is a simple modal view\nYou can provide your own template for the collection loader modal\nif you want to. Default implementation uses twitter bootstrap modal and\nprogress bar (<a href=\"http://twitter.github.com/bootstrap/\">http://twitter.github.com/bootstrap/</a>). You template\nshould contain <code>progress</code>, <code>bar</code> and <code>message</code> classes</p>\n","type_alias":"collection_loader_view","css_class_identifier":"luca-collection-loader-view","defines_methods":{"initialize":{"defined_on_line":14,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"modalContainer":{"defined_on_line":22,"documentation":"","arguments":[]},"setupBindings":{"defined_on_line":25,"documentation":"","arguments":[]}},"defines_properties":{"className":{"defined_on_line":10,"documentation":"","default":"'luca-ui-collection-loader-view'"},"template":{"defined_on_line":12,"documentation":"","default":"\"components/collection_loader_view\""}},"source_file_contents":"# Collection Loader View is a simple modal view\n# You can provide your own template for the collection loader modal\n# if you want to. Default implementation uses twitter bootstrap modal and\n# progress bar (http://twitter.github.com/bootstrap/). You template\n# should contain `progress`, `bar` and `message` classes\nloaderView = Luca.register        \"Luca.components.CollectionLoaderView\"\nloaderView.extends                \"Luca.View\"\n\nloaderView.defines\n  className: 'luca-ui-collection-loader-view'\n\n  template: \"components/collection_loader_view\"\n\n  initialize: (@options={})->\n    Luca.components.Template::initialize.apply @,arguments\n\n    @container ||= $('body')\n    @manager   ||= Luca.CollectionManager.get()\n\n    @setupBindings()\n\n  modalContainer: ()->\n    $(\"#progress-modal\", @el)\n\n  setupBindings: ()->\n    @manager.bind \"collection_loaded\", (name)=>\n      loaded   = @manager.loadedCollectionsCount()\n      total    = @manager.totalCollectionsCount()\n      progress = parseInt((loaded / total) * 100)\n      collectionName = _.string.titleize( _.string.humanize( name ) )\n\n      @modalContainer().find('.progress .bar').attr(\"style\", \"width: #{progress}%;\")\n      @modalContainer().find('.message').html(\"Loaded #{ collectionName }...\")\n\n    @manager.bind \"all_collections_loaded\", ()=>\n      @modalContainer().find('.message').html(\"All done!\")\n      _.delay ()=>\n        @modalContainer().modal('hide')\n      , 400"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/collection_view.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/collection_view.coffee","type":"component_definition","starts_on_line":43,"class_name":"Luca.CollectionView","header_documentation":"<p>The <code>Luca.CollectionView</code> renders models from a <code>Luca.Collection</code> into multiple\nelements, and provides methods for filtering, paginating, sorting the underlying\ncollection and re-rendering the contents of its <code>@el</code> accordingly.</p>\n\n<h4>Basic Example</h4>\n\n<pre><code>collectionView = Luca.register  &quot;App.views.Books&quot;\ncollectionView.extends          &quot;Luca.CollectionView&quot;\ncollectionView.defines\n  itemProperty: &quot;author&quot;\n  collection: new Luca.Collection([\n    author: &quot;George Orwell&quot;\n    title:  &quot;Animal Farm&quot;\n  ,\n    author: &quot;Noam Chomsky&quot;\n    title: &quot;Manufacturing Consent&quot;\n  ])\nview = new App.views.Books()\n</code></pre>\n\n<h4>Extending it to make it Filterable and Paginatable</h4>\n\n<pre><code>filterable = Luca.register    &quot;App.views.FilterableBooks&quot;\nfilterable.extends            &quot;App.views.Books&quot;\nfilterable.defines\n  collection: &quot;books&quot; \n  paginatable: 12\n  filterable:\n    query:\n      author: &quot;George Orwell&quot;\n\n view = new App.views.FilterableBooks()\n</code></pre>\n\n<h4>Filterable Collections</h4>\n\n<p>The <code>Luca.CollectionView</code> will attempt to perform a local query against its\ncollection which behaves like a <code>Backbone.QueryCollection</code>.  It will do this\nby default without making a remote request to the API.  </p>\n\n<p>If you do not want this behavior, you can configure the <code>Luca.CollectionView</code> to \nbehave as if the filtering was happen remotely in your REST API.<br>\n      filterable:\n        options:\n          remote: true</p>\n","type_alias":"collection_view","css_class_identifier":"luca-collection-view","defines_methods":{"initialize":{"defined_on_line":96,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"locateItemElement":{"defined_on_line":135,"documentation":"<p>Given the id of a model, find the underlying DOM element which was rendered by this collection.\nAssumes that the data-model-id attribute is set, which it is by default by @attributesForItem.</p>\n","arguments":[{"argument":"id","value":null}]},"refresh":{"defined_on_line":142,"documentation":"<p>Refresh is responsible for applying any filtering, pagination, or sorting options that may be set\nfrom the various Luca.concerns mixed in by <code>Luca.CollectionView</code> and making a query to the underlying\ncollection.  It will then take the set of models returned by <code>@getModels</code> and pass them through the\nitem rendering pipeline.</p>\n","arguments":[]},"renderModels":{"defined_on_line":162,"documentation":"","arguments":[{"argument":"models","value":null},{"argument":"query","value":null},{"argument":"options","value":null}]},"attributesForItem":{"defined_on_line":168,"documentation":"<p>Determines which attributes should be set on the item DOM element.</p>\n","arguments":[{"argument":"item","value":null},{"argument":"model","value":null}]},"contentForItem":{"defined_on_line":173,"documentation":"<p>Determines the content for the item DOM element.  Will use the appropriate options\nspecified by <code>@itemTemplate</code>, <code>@itemRenderer</code>, or <code>@itemProperty</code></p>\n","arguments":[{"argument":"item","value":"{}"}]},"makeItem":{"defined_on_line":186,"documentation":"<p>Uses the various options passed to the <code>CollectionView</code> to assemble a call to <code>Luca.View::make</code>.</p>\n","arguments":[{"argument":"model","value":null},{"argument":"index","value":null}]},"refreshModel":{"defined_on_line":197,"documentation":"<p>Given a model, attempt to re-render the contents of its item in this view&#39;s DOM contents.</p>\n","arguments":[{"argument":"model","value":null}]},"registerEvent":{"defined_on_line":203,"documentation":"","arguments":[{"argument":"domEvent","value":null},{"argument":"selector","value":null},{"argument":"handler","value":null}]}},"defines_properties":{"collection":{"defined_on_line":64,"documentation":"<p>Specify which collection will be used to supply the models to be rendered.\nAccepts either a string alias for the Collection class, or an instance of\nany class which inherits from Backbone.Collection</p>\n","default":"undefined"},"tagName":{"defined_on_line":67,"documentation":"<p>By default the CollectionView will be rendered inside of an OL tag.</p>\n","default":"\"ol\""},"bodyClassName":{"defined_on_line":72,"documentation":"<p>The CollectionView behaves as a Luca.Panel which means it has an area for\ntop and bottom toolbars.  The actual content that gets rendered from the\ncollection will be rendered inside an element with the specified class.</p>\n","default":"\"collection-ui-panel\""},"itemTagName":{"defined_on_line":75,"documentation":"<p>Each item from the collection will be rendered inside of an element specified by @itemTagName</p>\n","default":"'li'"},"itemClassName":{"defined_on_line":78,"documentation":"<p>Each item element will be assigned a CSS class specified by @itemClassName</p>\n","default":"'collection-item'"},"itemTemplate":{"defined_on_line":83,"documentation":"<p>Specify which template should be used to render each item in the collection.\nAccepts a string which will be passed to Luca.template(@itemTemplate).  Your template\ncan expect to be passed an object with the <code>model</code> and <code>index</code> properties on it.</p>\n","default":"undefined"},"itemRenderer":{"defined_on_line":87,"documentation":"<p>Accepts a reference to a function, which will be called with an object with the <code>model</code> and <code>index</code>\nproperties on it.  This function should return a String which will be injected into the item DOM element.</p>\n","default":"undefined"},"itemProperty":{"defined_on_line":90,"documentation":"<p>Plucks the specified property from the model and inserts it into the item DOM element.</p>\n","default":"undefined"},"observeChanges":{"defined_on_line":93,"documentation":"<p>If @observeChanges is set to true, any change in an underlying model will automatically be re-rendered.</p>\n","default":"false"}},"source_file_contents":"# The `Luca.CollectionView` renders models from a `Luca.Collection` into multiple\n# elements, and provides methods for filtering, paginating, sorting the underlying\n# collection and re-rendering the contents of its `@el` accordingly.\n#\n# #### Basic Example\n#     collectionView = Luca.register  \"App.views.Books\"\n#     collectionView.extends          \"Luca.CollectionView\"\n#\n#     collectionView.defines\n#       itemProperty: \"author\"\n#       collection: new Luca.Collection([\n#         author: \"George Orwell\"\n#         title:  \"Animal Farm\"\n#       ,\n#         author: \"Noam Chomsky\"\n#         title: \"Manufacturing Consent\"\n#       ])\n#\n#     view = new App.views.Books()\n# #### Extending it to make it Filterable and Paginatable\n#     filterable = Luca.register    \"App.views.FilterableBooks\"\n#     filterable.extends            \"App.views.Books\"\n#     filterable.defines\n#       collection: \"books\" \n#       paginatable: 12\n#       filterable:\n#         query:\n#           author: \"George Orwell\"\n#    \n#      view = new App.views.FilterableBooks()\n# #### Filterable Collections\n#\n# The `Luca.CollectionView` will attempt to perform a local query against its\n# collection which behaves like a `Backbone.QueryCollection`.  It will do this\n# by default without making a remote request to the API.  \n# \n# If you do not want this behavior, you can configure the `Luca.CollectionView` to \n# behave as if the filtering was happen remotely in your REST API.  \n#\n#       filterable:\n#         options:\n#           remote: true\ncollectionView = Luca.register      \"Luca.CollectionView\"\n\ncollectionView.extends            \"Luca.Panel\"\n\ncollectionView.replaces           \"Luca.components.CollectionView\"\n\ncollectionView.mixesIn            \"QueryCollectionBindings\", \n                                  \"LoadMaskable\", \n                                  \"Filterable\", \n                                  \"Paginatable\",\n                                  \"Sortable\"\n\ncollectionView.triggers           \"before:refresh\",\n                                  \"after:refresh\",\n                                  \"refresh\",\n                                  \"empty:results\"\n\ncollectionView.publicConfiguration\n  # Specify which collection will be used to supply the models to be rendered.\n  # Accepts either a string alias for the Collection class, or an instance of\n  # any class which inherits from Backbone.Collection\n  collection: undefined\n\n  # By default the CollectionView will be rendered inside of an OL tag.\n  tagName: \"ol\"\n\n  # The CollectionView behaves as a Luca.Panel which means it has an area for\n  # top and bottom toolbars.  The actual content that gets rendered from the \n  # collection will be rendered inside an element with the specified class.\n  bodyClassName: \"collection-ui-panel\"\n\n  # Each item from the collection will be rendered inside of an element specified by @itemTagName\n  itemTagName: 'li'\n\n  # Each item element will be assigned a CSS class specified by @itemClassName \n  itemClassName: 'collection-item'\n\n  # Specify which template should be used to render each item in the collection.  \n  # Accepts a string which will be passed to Luca.template(@itemTemplate).  Your template\n  # can expect to be passed an object with the `model` and `index` properties on it.\n  itemTemplate: undefined\n\n  # Accepts a reference to a function, which will be called with an object with the `model` and `index`\n  # properties on it.  This function should return a String which will be injected into the item DOM element.\n  itemRenderer: undefined\n\n  # Plucks the specified property from the model and inserts it into the item DOM element.\n  itemProperty: undefined\n\n  # If @observeChanges is set to true, any change in an underlying model will automatically be re-rendered.\n  observeChanges: false\n\ncollectionView.publicMethods\n  initialize: (@options={})->\n    _.extend(@, @options)\n    _.bindAll @, \"refresh\"\n\n    unless @collection? or @options.collection\n      console.log \"Error on initialize of collection view\", @\n      throw \"Collection Views must specify a collection\"\n\n    unless @itemTemplate? || @itemRenderer? || @itemProperty?\n      throw \"Collection Views must specify an item template or item renderer function\"\n\n    if _.isString(@collection) \n      if Luca.CollectionManager.get()\n        @collection = Luca.CollectionManager.get().getOrCreate(@collection)\n      else\n        console.log \"String Collection but no collection manager\"\n\n    unless Luca.isBackboneCollection(@collection)\n      console.log \"Missing Collection on #{ @name || @cid }\", @, @collection\n      throw \"Collection Views must have a valid backbone collection\"\n\n    # INVESTIGATE THIS BEING DOUBLE WORK\n    @on \"data:refresh\", @refresh, @\n    @on \"collection:reset\", @refresh, @\n\n    @on \"collection:remove\", @refresh, @\n    @on \"collection:add\", @refresh, @\n    @on \"collection:change\", @refreshModel, @ if @observeChanges is true\n\n    Luca.Panel::initialize.apply(@, arguments)\n\n    view = @\n    if @getCollection()?.length > 0\n      @on \"after:render\", ()->\n        view.refresh()\n        view.unbind \"after:render\", @\n\n  # Given the id of a model, find the underlying DOM element which was rendered by this collection.\n  # Assumes that the data-model-id attribute is set, which it is by default by @attributesForItem.\n  locateItemElement: (id)->\n    @$(\".#{ @itemClassName }[data-model-id='#{ id }']\")\n\n  # Refresh is responsible for applying any filtering, pagination, or sorting options that may be set\n  # from the various Luca.concerns mixed in by `Luca.CollectionView` and making a query to the underlying\n  # collection.  It will then take the set of models returned by `@getModels` and pass them through the\n  # item rendering pipeline.\n  refresh: ()->\n    query = @getLocalQuery()\n    options = @getQueryOptions()\n    models  = @getModels(query, options)\n\n    @$bodyEl().empty()\n\n    @trigger(\"before:refresh\", models, query, options)\n\n    if models.length is 0\n      @trigger(\"empty:results\", query, options)\n\n    @renderModels(models, query, options)\n\n    @trigger(\"after:refresh\", models, query, options)\n\n    @\n\n\ncollectionView.privateMethods\n  renderModels: (models, query, options)->\n    index = 0\n    for model in models\n      @$append @makeItem(model, index++)\n\n  # Determines which attributes should be set on the item DOM element. \n  attributesForItem: (item, model)->\n    _.extend {}, class: @itemClassName, \"data-index\": item.index, \"data-model-id\": item.model.get('id')\n\n  # Determines the content for the item DOM element.  Will use the appropriate options\n  # specified by `@itemTemplate`, `@itemRenderer`, or `@itemProperty`\n  contentForItem: (item={})->\n    if @itemTemplate? and templateFn = Luca.template(@itemTemplate)\n      return content = templateFn.call(@, item)\n\n    if @itemRenderer? and _.isFunction( @itemRenderer )\n      return content = @itemRenderer.call(@, item, item.model, item.index)\n\n    if @itemProperty and item.model?\n      return content = item.model.read( @itemProperty )\n\n    \"\"\n\n  # Uses the various options passed to the `CollectionView` to assemble a call to `Luca.View::make`.\n  makeItem: (model, index)->\n    item = if @prepareItem? then @prepareItem.call(@, model, index) else (model:model, index: index)\n    attributes = @attributesForItem(item, model) \n    content = @contentForItem(item)\n\n    try\n      Luca.View::make(@itemTagName, attributes, content)\n    catch e\n      console.log \"Error generating DOM element for CollectionView\", @, model, index\n\n  # Given a model, attempt to re-render the contents of its item in this view's DOM contents.\n  refreshModel: (model)->\n    index = @collection.indexOf( model )\n    @locateItemElement(model.get('id')).empty().append( @contentForItem({model,index}, model) )\n    @trigger(\"model:refreshed\", index, model)\n\n\n  registerEvent: (domEvent, selector, handler)->\n    if !handler? and _.isFunction(selector)\n      handler = selector\n      selector = undefined\n\n    eventTrigger = _([domEvent,\"#{ @itemTagName }.#{ @itemClassName }\", selector]).compact().join(\" \")\n    Luca.View::registerEvent(eventTrigger,handler)\n\ncollectionView.register()\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/controller.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/controller.coffee","type":"component_definition","starts_on_line":25,"class_name":"Luca.components.Controller","header_documentation":"<p>The Controller is a special type of CardView that is used to provide structure to a Luca.Application.  Each\ncomponent in the controller is expected to have a unique <code>@name</code> property.  The Application&#39;s router configuration\nwill map URL / Hashbangs to the <code>@name</code>s of components that belong to the Application controller.<br>\nApplications which structure their &#39;pages&#39; in controllers, or sections, will have the names of which\nsection or page is active inside of its state model.  One example / common application structure we see:\n      application:\n        main<em>controller:\n          controller / section</em>one:\n            page<em>one\n            page</em>two\n            page<em>three\n          controller / section</em>two\n            page<em>alpha\n            page</em>bravo\nIn the above example, the Application would attempt to route to page<em>one, and the state \nof the application may look like:\n      application.activeSection() #=&gt; &#39;section</em>one&#39;\n      application.activeSubSection() # =&gt; &#39;page<em>one&#39;\n      application.activePage() # =&gt; page</em>one</p>\n","type_alias":"controller","css_class_identifier":"luca-controller","defines_methods":{"default":{"defined_on_line":45,"documentation":"<p>Navigate to the default ( or first ) component on this controller.\nThis will automatically get called upon rendering, so that it sets up\nthe proper state tracking, event binding, etc.</p>\n","arguments":[{"argument":"callback","value":null}]},"activePage":{"defined_on_line":50,"documentation":"<p>Returns the name of the component which is currently active\non this controller.</p>\n","arguments":[]},"navigate_to":{"defined_on_line":55,"documentation":"<p>Navigate to a page on this controller by name.  If passed an optional\ncallback, the callback will be called within the context of the activated page.</p>\n","arguments":[{"argument":"page","value":null},{"argument":"callback","value":null}]},"setupComponentKeyEvents":{"defined_on_line":84,"documentation":"<p>For each component we control, if there is a keyEvents property defined\nthen we will define a keymaster scope for that component&#39;s name, and setup\nbindings as directed.  This is important because each time a controller\nactivates a component, that component will attempt to change the scope of\nthe keymaster so that components becomes responsible for handling detected key events.</p>\n","arguments":[]},"controllerPath":{"defined_on_line":106,"documentation":"<p>The Controller Path is an array of the names of the controllers\na given component belongs to.  This method will get patched on to each\ncomponent that belongs to a controller.  It will always be bound to the instance\nof the component itself.  Example:</p>\n\n<p>application.contains\nname: &quot;main<em>controller&quot;\ncomponents: [\nname: &quot;sub</em>controller&quot;\ncomponents:[\nname: &quot;page&quot;\n]\n]</p>\n\n<p>The @controllerPath() method for the component named page would be [&#39;sub_controller&#39;,&#39;page&#39;].\nThis will be used internally by the Application route builder, so that each of page&#39;s parent\ncontrollers are activated in the proper order needed to make page visible.</p>\n","arguments":[]},"initialize":{"defined_on_line":124,"documentation":"","arguments":[{"argument":"@options","value":null}]},"each":{"defined_on_line":143,"documentation":"","arguments":[{"argument":"fn","value":null}]},"activeSection":{"defined_on_line":146,"documentation":"","arguments":[]},"pageControllers":{"defined_on_line":149,"documentation":"","arguments":[{"argument":"deep","value":"false"}]},"controllers":{"defined_on_line":152,"documentation":"","arguments":[{"argument":"deep","value":"false"}]},"availablePages":{"defined_on_line":157,"documentation":"","arguments":[]},"availableSections":{"defined_on_line":160,"documentation":"","arguments":[]},"pageNames":{"defined_on_line":170,"documentation":"","arguments":[]},"sectionNames":{"defined_on_line":173,"documentation":"","arguments":[{"argument":"deep","value":"false"}]}},"defines_properties":{"tracker":{"defined_on_line":32,"documentation":"<p>If there is an active application, we will attempt to\nset the name of our currently activated page on the application&#39;s\nstate machine.  The attribute we will set can be configured by setting this value.</p>\n","default":"\"page\""},"activeAttribute":{"defined_on_line":36,"documentation":"<p>We will set the name of the active page / section on our DOM element\nThe attribute we will set can be configured by setting this.</p>\n","default":"\"active-section\""},"stateful":{"defined_on_line":37,"documentation":"","default":"true"},"defaultPage":{"defined_on_line":38,"documentation":"","default":"undefined"},"defaultCard":{"defined_on_line":39,"documentation":"","default":"0"},"Luca.View":{"defined_on_line":120,"documentation":"","default":""}},"source_file_contents":"# The Controller is a special type of CardView that is used to provide structure to a Luca.Application.  Each\n# component in the controller is expected to have a unique `@name` property.  The Application's router configuration\n# will map URL / Hashbangs to the `@name`s of components that belong to the Application controller.  \n#\n# Applications which structure their 'pages' in controllers, or sections, will have the names of which\n# section or page is active inside of its state model.  One example / common application structure we see:\n#\n#       application:\n#         main_controller:\n#           controller / section_one:\n#             page_one\n#             page_two\n#             page_three\n#           controller / section_two\n#             page_alpha\n#             page_bravo\n#\n# In the above example, the Application would attempt to route to page_one, and the state \n# of the application may look like:\n#\n#       application.activeSection() #=> 'section_one'\n#       application.activeSubSection() # => 'page_one'\n#       application.activePage() # => page_one\n#\ncontroller = Luca.register        \"Luca.components.Controller\"\ncontroller.extends                \"Luca.containers.CardView\"\n\ncontroller.publicConfiguration\n  # If there is an active application, we will attempt to \n  # set the name of our currently activated page on the application's\n  # state machine.  The attribute we will set can be configured by setting this value.\n  tracker: \"page\"\n\n  # We will set the name of the active page / section on our DOM element\n  # The attribute we will set can be configured by setting this.\n  activeAttribute: \"active-section\"\n  stateful: true\n  defaultPage: undefined\n  defaultCard: 0\n\ncontroller.publicMethods  \n  # Navigate to the default ( or first ) component on this controller.\n  # This will automatically get called upon rendering, so that it sets up\n  # the proper state tracking, event binding, etc.\n  default: (callback)->\n    @navigate_to(@defaultPage || @defaultCard, callback)\n\n  # Returns the name of the component which is currently active\n  # on this controller.\n  activePage: ()-> \n    @activeSection()\n\n  # Navigate to a page on this controller by name.  If passed an optional\n  # callback, the callback will be called within the context of the activated page.\n  navigate_to: (page, callback)->\n    page ||= @defaultCard\n\n    @activate page, false, (activator, previous,current)=>\n      if current.activatedByController is true\n        current.trigger(\"on:controller:reactivation\")\n      else\n        current.trigger(\"on:controller:activation\")\n        current.activatedByController = true\n\n      @state.set(active_section: current.name )\n\n      if @tracker? and app = @app || Luca.getApplication?()\n        app.state.set(@tracker, current.name)\n\n      Luca.key?.setScope( current.name )\n\n      if _.isFunction( callback )\n        callback.call(current)\n\n    # return the component we are navigating to\n    @find(page)\n\ncontroller.classMethods\n  # For each component we control, if there is a keyEvents property defined\n  # then we will define a keymaster scope for that component's name, and setup\n  # bindings as directed.  This is important because each time a controller \n  # activates a component, that component will attempt to change the scope of\n  # the keymaster so that components becomes responsible for handling detected key events.\n  setupComponentKeyEvents: ()->\n    @_().each (component)->    \n      if _.isObject(component.keyEvents) and component.name?\n        Luca.util.setupKeymaster(component.keyEvents, component.name).on(component)    \n\n  # The Controller Path is an array of the names of the controllers\n  # a given component belongs to.  This method will get patched on to each\n  # component that belongs to a controller.  It will always be bound to the instance\n  # of the component itself.  Example:\n  # \n  #       application.contains\n  #         name: \"main_controller\"\n  #         components: [\n  #           name: \"sub_controller\"\n  #           components:[\n  #             name: \"page\"\n  #           ]\n  #         ]\n  #\n  # The @controllerPath() method for the component named page would be ['sub_controller','page'].\n  # This will be used internally by the Application route builder, so that each of page's parent\n  # controllers are activated in the proper order needed to make page visible.\n  controllerPath: ()->\n    component = @\n    \n    list = [component.name]\n    atBase = false\n\n    while component and not atBase\n      component = component.getParent?()\n      atBase = true if component?.role is \"main_controller\"\n      list.push( component.name ) if component? and not atBase\n\n    list.reverse()\n\ncontroller.afterDefinition ()->\n  Luca.View::hooks.push \"on:controller:activation\"\n\ncontroller.defines\n\n  initialize: (@options)->\n    # let's phase out the 'card' terminology \n    # and 'section' while we're at it.  page is the word.\n    @defaultCard ||= @defaultPage ||= @components[0]?.name || 0\n    @defaultPage ||= @defaultCard \n\n    @defaultState ||= \n      active_section: @defaultPage\n\n    Luca.containers.CardView::initialize.apply @, arguments\n\n    throw \"Controllers must specify a defaultCard property and/or the first component must have a name\" unless @defaultCard?\n\n    @_().each (component)->\n      component.controllerPath = Luca.components.Controller.controllerPath\n\n    @on \"after:render\", @default, @\n    @on \"before:render\", Luca.components.Controller.setupComponentKeyEvents, @\n\n  each: (fn)->\n    _( @components ).each (component)=> fn.call(@,component)\n\n  activeSection: ()->\n    @get(\"active_section\")\n\n  pageControllers: (deep=false)->\n    @controllers.apply(@, arguments)\n\n  controllers:(deep=false)->\n    @select (component)->\n      type = (component.type || component.ctype) \n      type is \"controller\" or type is \"page_controller\"\n\n  availablePages: ()->\n    @availableSections.apply(@, arguments)    \n\n  availableSections: ()->\n    console.log \"The availableSections()/availablePages() method will be removed in 1.0\"\n    base = {}\n    base[ @name ] = @sectionNames()\n\n    _( @controllers() ).reduce (memo,controller)=>\n      memo[ controller.name ] = controller.sectionNames()  \n      memo\n    , base \n\n  pageNames: ()->\n    @sectionNames()\n\n  sectionNames: (deep=false)->\n    @pluck('name')\n\n\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/base.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/base.coffee","type":"component_definition","starts_on_line":7,"class_name":"Luca.core.Field","header_documentation":"<p>The <code>Luca.core.Field</code> is an abstract base class for field components\nwhich are used in the <code>Luca.components.FormView</code>.  They provide common\nfunctionality like getValue, setValue, change and validation event bindings. \nAdditionally, the field component provides common Twitter Bootstrap styling\nhooks, such as error, warning, and success status flagging.</p>\n","type_alias":"field","css_class_identifier":"luca-core-field","defines_methods":{"disable":{"defined_on_line":57,"documentation":"<p>Disable this field</p>\n","arguments":[]},"enable":{"defined_on_line":61,"documentation":"<p>Enable this field</p>\n","arguments":[]},"getValue":{"defined_on_line":65,"documentation":"<p>Gets the value from the input element in this field control</p>\n","arguments":[]},"setValue":{"defined_on_line":70,"documentation":"<p>Sets the value on the input element inside this field control</p>\n","arguments":[{"argument":"value","value":null}]},"updateState":{"defined_on_line":75,"documentation":"<p>Update the state of this field.  Valid options are defined on\nthis fields <code>@statuses</code> property</p>\n","arguments":[{"argument":"state","value":null}]},"clearErrors":{"defined_on_line":82,"documentation":"<p>Remove any visual error indications from this field control</p>\n","arguments":[]},"displayErrors":{"defined_on_line":86,"documentation":"<p>Display a visual error state on this field</p>\n","arguments":[{"argument":"errors","value":null}]},"getParsedValue":{"defined_on_line":93,"documentation":"<p>Runs the value from the underlying input element\nthrough a type conversion process configured by\nthe <code>@valueType</code> field</p>\n","arguments":[{"argument":"raw","value":null}]},"initialize":{"defined_on_line":108,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"beforeRender":{"defined_on_line":132,"documentation":"","arguments":[]},"change_handler":{"defined_on_line":138,"documentation":"","arguments":[{"argument":"e","value":null}]},"getInputElement":{"defined_on_line":141,"documentation":"","arguments":[]}},"defines_properties":{"className":{"defined_on_line":16,"documentation":"","default":"'luca-ui-field'"},"disabled":{"defined_on_line":19,"documentation":"<p>Controls whether or not this field is rendered in a disabled state</p>\n","default":"undefined"},"helperText":{"defined_on_line":22,"documentation":"<p>Controls the bootstrap helperText value for this field control</p>\n","default":"undefined"},"label":{"defined_on_line":25,"documentation":"<p>Text value for the label element that goes along with this field control</p>\n","default":"undefined"},"labelAlign":{"defined_on_line":30,"documentation":"<p>Controls the positioning of the label element.  Valid options are\n&#39;top&#39;, &#39;left&#39;.  For any other custom display you can control this\non your own by specifying a template</p>\n","default":"'top'"},"placeHolder":{"defined_on_line":34,"documentation":"<p>Controls the value displayed in this field when it is in an untouched state\nby the user.  Uses the html5 placeholder attribute</p>\n","default":"undefined"},"required":{"defined_on_line":38,"documentation":"<p>Controls whether or not we want to display visual indicator\nthat this field is required.</p>\n","default":"undefined"},"statuses":{"defined_on_line":42,"documentation":"<p>Which statuses can be applied to this field? Valid options are taken\nfrom bootstrap state styling.</p>\n","default":"["},"valueType":{"defined_on_line":51,"documentation":"<p>What is the type of value that this field\nshould have? You can use this to coerce the <code>getValue()</code> type\ninto an integer, string, or float.</p>\n","default":"\"string\""},"isField":{"defined_on_line":104,"documentation":"<p>A convenience method for identifying field components</p>\n","default":"true"},"template":{"defined_on_line":105,"documentation":"","default":"'fields/text_field'"}},"source_file_contents":"# The `Luca.core.Field` is an abstract base class for field components\n# which are used in the `Luca.components.FormView`.  They provide common\n# functionality like getValue, setValue, change and validation event bindings. \n#\n# Additionally, the field component provides common Twitter Bootstrap styling\n# hooks, such as error, warning, and success status flagging.\nfield = Luca.register         \"Luca.core.Field\"\n\nfield.extends                 \"Luca.View\"\n\nfield.triggers                \"before:validation\",\n                              \"after:validation\",\n                              \"on:change\"\n\nfield.publicConfiguration\n  className: 'luca-ui-field'\n\n  # Controls whether or not this field is rendered in a disabled state\n  disabled: undefined\n\n  # Controls the bootstrap helperText value for this field control\n  helperText: undefined\n\n  # Text value for the label element that goes along with this field control\n  label: undefined\n\n  # Controls the positioning of the label element.  Valid options are\n  # 'top', 'left'.  For any other custom display you can control this\n  # on your own by specifying a template\n  labelAlign: 'top'\n\n  # Controls the value displayed in this field when it is in an untouched state\n  # by the user.  Uses the html5 placeholder attribute\n  placeHolder: undefined\n\n  # Controls whether or not we want to display visual indicator\n  # that this field is required. \n  required: undefined\n\n  # Which statuses can be applied to this field? Valid options are taken\n  # from bootstrap state styling.\n  statuses: [\n    \"warning\"\n    \"error\"\n    \"success\"\n  ]\n\n  # What is the type of value that this field\n  # should have? You can use this to coerce the `getValue()` type\n  # into an integer, string, or float.\n  valueType: \"string\"\n\n\n\nfield.publicMethods\n  # Disable this field\n  disable: ()->\n    @getInputElement().attr('disabled', true)\n\n  # Enable this field\n  enable: ()->\n    @getInputElement().attr('disabled', false)\n\n  # Gets the value from the input element in this field control\n  getValue: ()->\n    raw = @getInputElement()?.val()\n    @getParsedValue(raw)\n\n  # Sets the value on the input element inside this field control\n  setValue: (value)->\n    @getInputElement()?.val(value)\n\n  # Update the state of this field.  Valid options are defined on\n  # this fields `@statuses` property\n  updateState: (state)->\n    for cssClass in @statuses\n      @$el.removeClass(cssClass)\n\n    @$el.addClass(state)\n\n  # Remove any visual error indications from this field control\n  clearErrors: ()->\n    @$el.removeClass('error')\n\n  # Display a visual error state on this field\n  displayErrors: (errors)->\n    @updateState('error')\n\nfield.privateMethods\n  # Runs the value from the underlying input element\n  # through a type conversion process configured by\n  # the `@valueType` field\n  getParsedValue: (raw)->\n    return raw if _.str.isBlank( raw )\n\n    switch @valueType\n      when \"integer\" then parseInt(raw)\n      when \"string\" then \"#{ raw }\"\n      when \"float\" then parseFloat(raw)\n      else raw\n\nfield.privateConfiguration\n  # A convenience method for identifying field components\n  isField: true\n  template: 'fields/text_field'\n\nfield.privateMethods\n  initialize: (@options={})->\n    _.extend @, @options\n\n    @input_id ||= _.uniqueId('field')\n    @input_name ||= @name\n    @input_class ||= \"\"\n    @input_type ||= \"\"\n    @helperText ||= \"\"\n    @label = @name if not @label? or @label.length is 0\n    @label ||= \"*#{ @label }\" if @required and not @label?.match(/^\\*/)\n    @inputStyles ||= \"\"\n    @input_value ||= @value || \"\"\n\n    @disable() if @disabled\n\n    @updateState( @state )\n    @placeHolder ||= \"\"\n\n    # In order to support using Luca.View template properties everywhere.\n\n    # Will need to work around how the field classes\n    # apply templates to themselves.\n    Luca.View::initialize.apply(@, arguments)\n\n  beforeRender: ()->\n    if Luca.config.enableBoostrap\n      @$el.addClass('control-group')\n\n    @$el.addClass('required') if @required\n\n  change_handler: (e)->\n    @trigger \"on:change\", @, e\n\n  getInputElement: ()->\n    @input ||= @$('input').eq(0)\n\nfield.register()\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/button_field.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/button_field.coffee","type":"component_definition","starts_on_line":7,"class_name":"Luca.fields.ButtonField","header_documentation":"<p>The <code>Luca.fields.ButtonField</code> provides an easy way to generate\na button element, with an optional icon.  Supports all of the\navailable bootstrap icons, and color states.<br>\nThe <code>Luca.fields.ButtonField</code> component will typically be used as \npart of a <code>Luca.components.FormView</code> or a <code>Luca.components.PanelToolbar</code>.</p>\n","type_alias":"button_field","css_class_identifier":"luca-fields-button-field","defines_methods":{"clickHandler":{"defined_on_line":64,"documentation":"","arguments":[{"argument":"e","value":null}]},"initialize":{"defined_on_line":68,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"afterInitialize":{"defined_on_line":75,"documentation":"","arguments":[]},"setValue":{"defined_on_line":88,"documentation":"","arguments":[]}},"defines_properties":{"buttonSize":{"defined_on_line":19,"documentation":"<p>Which size should this button be? Valid options are:\n- none ( default )\n- large\n- mini\n- small</p>\n","default":"undefined"},"class":{"defined_on_line":32,"documentation":"<p>Which bootstrap color class should we apply to this button?\nValid options are any css button class, or the defaults which\nship with bootstrap:</p>\n\n<ul>\n<li>btn-primary</li>\n<li>btn-info</li>\n<li>btn-success</li>\n<li>btn-warning</li>\n<li>btn-danger</li>\n<li>btn-inverse</li>\n<li>btn-link</li>\n</ul>\n","default":"undefined"},"icon_class":{"defined_on_line":36,"documentation":"<p>specifies the bootstrap icon class you want to use for this button\nyou can use &#39;icon-ok-sign&#39; or just &#39;ok-sign&#39;</p>\n","default":"undefined"},"label":{"defined_on_line":39,"documentation":"<p>specifies the text value of the button</p>\n","default":"undefined"},"text":{"defined_on_line":43,"documentation":"<p>an alias for label, or input_value.  controls which text\ndisplays inside of the button</p>\n","default":"undefined"},"white":{"defined_on_line":46,"documentation":"<p>should we render the white icon?</p>\n","default":"false"},"readOnly":{"defined_on_line":49,"documentation":"","default":"true"},"input_value":{"defined_on_line":50,"documentation":"","default":"undefined"},"input_type":{"defined_on_line":51,"documentation":"","default":"\"button\""},"input_name":{"defined_on_line":53,"documentation":"","default":"undefined"},"buttonClasses":{"defined_on_line":54,"documentation":"","default":"\"\""},"isButton":{"defined_on_line":57,"documentation":"","default":"true"},"autoBindEventHandlers":{"defined_on_line":58,"documentation":"","default":"true"},"template":{"defined_on_line":59,"documentation":"","default":"\"fields/button_field\""},"events":{"defined_on_line":60,"documentation":"","default":null}},"source_file_contents":"# The `Luca.fields.ButtonField` provides an easy way to generate\n# a button element, with an optional icon.  Supports all of the\n# available bootstrap icons, and color states.  \n#\n# The `Luca.fields.ButtonField` component will typically be used as \n# part of a `Luca.components.FormView` or a `Luca.components.PanelToolbar`.\nbuttonField = Luca.register         \"Luca.fields.ButtonField\"\n\nbuttonField.extends                 \"Luca.core.Field\"\n\nbuttonField.triggers                \"button:click\"\n\nbuttonField.publicConfiguration\n  # Which size should this button be? Valid options are:\n  # - none ( default )\n  # - large\n  # - mini\n  # - small\n  buttonSize: undefined\n\n  # Which bootstrap color class should we apply to this button?\n  # Valid options are any css button class, or the defaults which\n  # ship with bootstrap: \n  #\n  # - btn-primary\n  # - btn-info\n  # - btn-success\n  # - btn-warning\n  # - btn-danger\n  # - btn-inverse\n  # - btn-link\n  class: undefined \n\n  # specifies the bootstrap icon class you want to use for this button \n  # you can use 'icon-ok-sign' or just 'ok-sign'\n  icon_class: undefined\n\n  # specifies the text value of the button\n  label: undefined    \n\n  # an alias for label, or input_value.  controls which text \n  # displays inside of the button\n  text: undefined\n\n  # should we render the white icon? \n  white: false\n\nbuttonField.privateConfiguration\n  readOnly:       true\n  input_value:    undefined \n  input_type:     \"button\" \n  icon_class:     undefined\n  input_name:     undefined\n  buttonClasses:  \"\" \n\nbuttonField.privateConfiguration\n  isButton: true\n  autoBindEventHandlers: true\n  template: \"fields/button_field\"\n  events:\n    \"click input\" : \"clickHandler\"\n\nbuttonField.privateMethods\n  clickHandler: (e)->\n    me = my = $( e.currentTarget )\n    @trigger \"button:click\"\n\n  initialize: (@options={})->\n    _.extend @, @options\n\n    Luca.core.Field::initialize.apply @, arguments\n\n    @template = \"fields/button_field_link\" if @icon_class?.length\n\n  afterInitialize: ()->\n    @input_id ||= _.uniqueId('button')\n    @input_name ||= @name ||= @input_id\n    @input_value ||= @label ||= @text\n    @input_class ||= @class ||= @buttonClasses\n\n    if @buttonSize?.length > 0\n      @input_class += \" #{ buttonSize.replace(/btn-/,'') }\"\n\n    @icon_class ||= \"\"\n    @icon_class = \"icon-#{ @icon_class }\" if @icon_class.length and !@icon_class.match(/^icon-/)\n    @icon_class += \" icon-white\" if @white\n\n  setValue: ()-> \n    true\n\nbuttonField.register()\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/checkbox_array.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/checkbox_array.coffee","type":"component_definition","starts_on_line":4,"class_name":"Luca.fields.CheckboxArray","header_documentation":"<p>The <code>Luca.fields.CheckboxArray</code> renders an array of values \ninto checkbox controls.  This is for fields which can have\na list of values associated with them.</p>\n","type_alias":"checkbox_array","css_class_identifier":"luca-fields-checkbox-array","defines_methods":{"initialize":{"defined_on_line":18,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"afterInitialize":{"defined_on_line":31,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"clickHandler":{"defined_on_line":47,"documentation":"","arguments":[{"argument":"event","value":null}]},"controls":{"defined_on_line":56,"documentation":"","arguments":[]},"renderCheckboxes":{"defined_on_line":59,"documentation":"","arguments":[]},"uncheckAll":{"defined_on_line":77,"documentation":"","arguments":[]},"allFields":{"defined_on_line":80,"documentation":"","arguments":[]},"checkSelected":{"defined_on_line":86,"documentation":"<p>Check the selected items.  Expects an array of values\nfor boxes you would like to see checked.</p>\n","arguments":[{"argument":"items","value":null}]},"getValue":{"defined_on_line":99,"documentation":"<p>Gets an array of values for the checkboxes in this array\nwhich are checked.</p>\n","arguments":[]},"setValue":{"defined_on_line":102,"documentation":"","arguments":[{"argument":"items","value":null}]},"getValues":{"defined_on_line":113,"documentation":"","arguments":[]},"setValues":{"defined_on_line":116,"documentation":"","arguments":[{"argument":"items","value":null}]}},"defines_properties":{"template":{"defined_on_line":8,"documentation":"","default":"\"fields/checkbox_array\""},"className":{"defined_on_line":10,"documentation":"","default":"\"luca-ui-checkbox-array\""},"events":{"defined_on_line":12,"documentation":"","default":null},"selectedItems":{"defined_on_line":15,"documentation":"","default":"[]"}},"source_file_contents":"# The `Luca.fields.CheckboxArray` renders an array of values \n# into checkbox controls.  This is for fields which can have\n# a list of values associated with them.\ncheckboxArray = Luca.register     \"Luca.fields.CheckboxArray\"\ncheckboxArray.extends             \"Luca.core.Field\"\n\ncheckboxArray.privateConfiguration\n  template: \"fields/checkbox_array\"\n\n  className: \"luca-ui-checkbox-array\"\n\n  events:\n    \"click input\" : \"clickHandler\"\n\n  selectedItems: []\n\ncheckboxArray.privateMethods\n  initialize: (@options={})->\n    _.extend @, @options\n    _.extend @, Luca.concerns.Deferrable\n    _.bindAll @, \"renderCheckboxes\", \"clickHandler\", \"checkSelected\"\n\n    Luca.core.Field::initialize.apply @, arguments\n\n    @input_id ||= _.uniqueId('field')\n    @input_name ||= @name\n    @label ||= @name\n    @valueField ||= \"id\"\n    @displayField ||= \"name\"\n\n  afterInitialize: (@options={})->\n    try\n      @configure_collection()\n    catch e\n      console.log \"Error Configuring Collection\", @, e.message\n\n    cbArray = @\n\n    unless Luca.isBackboneCollection(@collection)\n      throw \"Checkbox Array Fields must specify a @collection property\"\n      \n    if @collection.length > 0\n      @renderCheckboxes()\n    else\n      @defer(\"renderCheckboxes\").until(@collection,\"reset\")\n\n  clickHandler: (event)->\n    checkbox = $(event.target)\n\n    if checkbox.prop('checked')\n      @selectedItems.push( checkbox.val() )\n    else\n      if _( @selectedItems ).include( checkbox.val() )\n        @selectedItems = _( @selectedItems ).without( checkbox.val() )\n\n  controls: ()->\n    @$('.controls')\n\n  renderCheckboxes: ()->\n    @controls().empty()\n    @selectedItems = []\n\n    @collection.each (model)=>\n      value = model.get(@valueField)\n      label = model.get(@displayField)\n      input_id = _.uniqueId(\"#{ @cid }_checkbox\")\n\n      inputElement = @make(\"input\",type:\"checkbox\",class:\"array-checkbox\",name:@input_name,value:value,id: input_id)\n      element = @make(\"label\", {for:input_id}, inputElement)\n\n      $( element ).append(\" #{ label }\")\n      @controls().append( element )\n\n    @trigger(\"checkboxes:rendered\", @checkboxesRendered = true)\n    @\n\n  uncheckAll: ()->\n    @allFields().prop('checked', false)\n\n  allFields: ()->\n    @controls().find(\"input[type='checkbox']\")\n\ncheckboxArray.publicMethods\n  # Check the selected items.  Expects an array of values \n  # for boxes you would like to see checked.\n  checkSelected: (items)->\n    @selectedItems = items if items?\n\n    @uncheckAll()\n\n    for value in @selectedItems\n      checkbox = @controls().find(\"input[value='#{ value }']\")\n      checkbox.prop('checked', true)\n\n    @selectedItems\n\n  # Gets an array of values for the checkboxes in this array\n  # which are checked.\n  getValue: ()->\n    @$(field).val() for field in @allFields() when @$(field).prop('checked')\n\n  setValue: (items)->\n    @selectedItems = items\n\n    if @checkboxesRendered is true\n      @checkSelected(items)\n    else\n      cbArray = @\n      @defer ()->\n        cbArray.checkSelected(items)\n      .until(\"checkboxes:rendered\")\n\n  getValues: ()->\n    @getValue()\n\n  setValues: (items)->\n    @setValue(items)"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/checkbox_field.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/checkbox_field.coffee","type":"component_definition","starts_on_line":1,"class_name":"Luca.fields.CheckboxField","header_documentation":"","type_alias":"checkbox_field","css_class_identifier":"luca-fields-checkbox-field","defines_methods":{"change_handler":{"defined_on_line":18,"documentation":"","arguments":[{"argument":"e","value":null}]},"initialize":{"defined_on_line":28,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"setValue":{"defined_on_line":39,"documentation":"","arguments":[{"argument":"checked","value":null}]},"getValue":{"defined_on_line":42,"documentation":"","arguments":[]}},"defines_properties":{"send_blanks":{"defined_on_line":9,"documentation":"","default":"true"},"input_value":{"defined_on_line":10,"documentation":"","default":"1"},"template":{"defined_on_line":13,"documentation":"","default":"'fields/checkbox_field'"},"events":{"defined_on_line":14,"documentation":"","default":null},"version":{"defined_on_line":46,"documentation":"","default":"1"}},"source_file_contents":"checkboxField = Luca.register         \"Luca.fields.CheckboxField\"\n\ncheckboxField.extends                 \"Luca.core.Field\"\n\ncheckboxField.triggers                \"checked\",\n                                      \"unchecked\"\n\ncheckboxField.publicConfiguration\n  send_blanks: true\n  input_value: 1\n\ncheckboxField.privateConfiguration\n  template: 'fields/checkbox_field'\n  events:\n    \"change input\" : \"change_handler\"\n\ncheckboxField.privateInterface\n  change_handler: (e)->\n    me = my = $(e.target)\n\n    if me.is(\":checked\")\n      @trigger \"checked\"\n    else\n      @trigger \"unchecked\"\n\n    @trigger \"on:change\", @, e, me.is(\":checked\")\n\n  initialize: (@options={})->\n    _.extend @, @options\n    _.bindAll @, \"change_handler\"\n\n    Luca.core.Field::initialize.apply @, arguments\n\n    @input_id ||= _.uniqueId('field')\n    @input_name ||= @name\n    @label ||= @name\n\ncheckboxField.publicInterface\n  setValue: (checked)->\n    @getInputElement().attr('checked', checked)\n\n  getValue:()->\n    @getInputElement().is(\":checked\")\n\ncheckboxField.defines\n  version: 1"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/file_upload_field.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/file_upload_field.coffee","type":"component_definition","starts_on_line":1,"class_name":"Luca.fields.FileUploadField","header_documentation":"","type_alias":"file_upload_field","css_class_identifier":"luca-fields-file-upload-field","defines_methods":{"afterInitialize":{"defined_on_line":9,"documentation":"","arguments":[]}},"defines_properties":{"version":{"defined_on_line":5,"documentation":"","default":"1"},"template":{"defined_on_line":7,"documentation":"","default":"'fields/file_upload_field'"}},"source_file_contents":"fileUpload = Luca.register              \"Luca.fields.FileUploadField\"\nfileUpload.extends                      \"Luca.core.Field\"\n\nfileUpload.defines\n  version: 1\n\n  template: 'fields/file_upload_field'\n\n  afterInitialize: ()->\n    @input_id ||= _.uniqueId('field')\n    @input_name ||= @name\n    @label ||= @name\n    @helperText ||= \"\"\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/hidden_field.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/hidden_field.coffee","type":"component_definition","starts_on_line":1,"class_name":"Luca.fields.HiddenField","header_documentation":"","type_alias":"hidden_field","css_class_identifier":"luca-fields-hidden-field","defines_methods":{"afterInitialize":{"defined_on_line":7,"documentation":"","arguments":[]}},"defines_properties":{"template":{"defined_on_line":5,"documentation":"","default":"'fields/hidden_field'"}},"source_file_contents":"hiddenField = Luca.register       \"Luca.fields.HiddenField\"\nhiddenField.extends               \"Luca.core.Field\"\n\nhiddenField.defines\n  template: 'fields/hidden_field'\n\n  afterInitialize: ()->\n    @input_id ||= _.uniqueId('field')\n    @input_name ||= @name\n    @input_value ||= @value\n    @label ||= @name"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/label_field.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/label_field.coffee","type":"component_definition","starts_on_line":1,"class_name":"Luca.components.LabelField","header_documentation":"","type_alias":"label_field","css_class_identifier":"luca-label-field","defines_methods":{"formatter":{"defined_on_line":5,"documentation":"","arguments":[{"argument":"value","value":null}]},"setValue":{"defined_on_line":9,"documentation":"","arguments":[{"argument":"value","value":null}]}},"defines_properties":{},"source_file_contents":"labelField = Luca.register          \"Luca.components.LabelField\"\nlabelField.extends                  \"Luca.core.Field\"\n\nlabelField.defines\n  formatter: (value)->\n    value ||= @getValue()\n    _.str.titleize( value )\n\n  setValue: (value)->\n    @trigger(\"change\", value, @getValue())\n    @getInputElement().attr('value', value)\n    @$('.value').html( @formatter(value) )\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/select_field.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/select_field.coffee","type":"component_definition","starts_on_line":1,"class_name":"Luca.fields.SelectField","header_documentation":"","type_alias":"select_field","css_class_identifier":"luca-fields-select-field","defines_methods":{"setValue":{"defined_on_line":47,"documentation":"<p>sets the value of this select field.</p>\n","arguments":[{"argument":"value","value":null}]},"getValue":{"defined_on_line":54,"documentation":"<p>returns the value of the select field.  runs\nthe value through the getParsedValue method which\nenforces the valueType type conversion.</p>\n","arguments":[]},"initialize":{"defined_on_line":64,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"afterInitialize":{"defined_on_line":80,"documentation":"","arguments":[]},"parseData":{"defined_on_line":99,"documentation":"<p>if the select field is configured with a data property\nthen parse that data into the proper format.  either\nan array of objects with the valueField and displayField\nproperties, or an array of arrays with [valueField, displayField]</p>\n","arguments":[]},"getInputElement":{"defined_on_line":109,"documentation":"","arguments":[]},"afterRender":{"defined_on_line":112,"documentation":"","arguments":[]},"beforeFetch":{"defined_on_line":118,"documentation":"","arguments":[]},"change_handler":{"defined_on_line":121,"documentation":"","arguments":[{"argument":"e","value":null}]},"resetOptions":{"defined_on_line":124,"documentation":"","arguments":[]},"populateOptions":{"defined_on_line":132,"documentation":"","arguments":[]}},"defines_properties":{"allowMultiple":{"defined_on_line":10,"documentation":"<p>Enables multi-select UI element.</p>\n","default":"false"},"includeBlank":{"defined_on_line":14,"documentation":"<p>Includes a blank option in addition to all of the items\nin the underlying collection.  Defaults to <code>true</code></p>\n","default":"true"},"blankValue":{"defined_on_line":18,"documentation":"<p>determines which value is sent when\nthe blank option is selected?</p>\n","default":"''"},"blankText":{"defined_on_line":22,"documentation":"<p>Determines the text displayed when\nthe blank option is selected</p>\n","default":"'Select One'"},"maxDisplayLength":{"defined_on_line":28,"documentation":"<p>Specifying a value for maxDisplayLength will truncate\nvalues displayed in the select field when they reach\npast a certain point, using the _.str truncate method.\nLeave at 0 if you want to keep this feature disabled.</p>\n","default":"0"},"retainValue":{"defined_on_line":34,"documentation":"<p>When the underlying collection is reset and we re-render\nthe options elements, should we keep the value that was set\non this field prior to that? Defaults to <code>true</code> unless otherwise\nspecified.</p>\n","default":"undefined"},"label":{"defined_on_line":38,"documentation":"<p>Determines which value is rendered in the label element that gets\nrendered along with this control group.</p>\n","default":"undefined"},"template":{"defined_on_line":41,"documentation":"","default":"\"fields/select_field\""},"events":{"defined_on_line":42,"documentation":"","default":null}},"source_file_contents":"selectField = Luca.register   \"Luca.fields.SelectField\"\n\nselectField.extends           \"Luca.core.Field\"\n\nselectField.triggers          \"after:select\",\n                              \"on:change\"\n\nselectField.publicConfiguration\n  # Enables multi-select UI element.\n  allowMultiple: false\n\n  # Includes a blank option in addition to all of the items\n  # in the underlying collection.  Defaults to `true` \n  includeBlank: true\n\n  # determines which value is sent when \n  # the blank option is selected?\n  blankValue: ''\n\n  # Determines the text displayed when \n  # the blank option is selected \n  blankText: 'Select One'\n\n  # Specifying a value for maxDisplayLength will truncate\n  # values displayed in the select field when they reach \n  # past a certain point, using the _.str truncate method.\n  # Leave at 0 if you want to keep this feature disabled.\n  maxDisplayLength: 0 \n\n  # When the underlying collection is reset and we re-render\n  # the options elements, should we keep the value that was set\n  # on this field prior to that? Defaults to `true` unless otherwise\n  # specified.\n  retainValue: undefined\n\n  # Determines which value is rendered in the label element that gets\n  # rendered along with this control group. \n  label: undefined\n\nselectField.privateConfiguration\n  template: \"fields/select_field\"\n  events:\n    \"change select\" : \"change_handler\"\n\nselectField.publicMethods\n  # sets the value of this select field.\n  setValue: (value)->\n    @currentValue = value\n    Luca.core.Field::setValue.apply @, arguments\n\n  # returns the value of the select field.  runs\n  # the value through the getParsedValue method which\n  # enforces the valueType type conversion.\n  getValue: ()->\n    raw = @getInputElement()?.val()\n\n    if @allowMultiple\n      _.map raw, (value)=>\n        @getParsedValue(value)\n    else\n      @getParsedValue(raw)\n\nselectField.privateMethods\n  initialize: (@options={})->\n    _.extend @, @options\n    _.extend @, Luca.concerns.Deferrable\n    _.bindAll @, \"change_handler\"\n\n    if _.isArray(@collection)\n      @collection = data: @collection\n\n    Luca.core.Field::initialize.apply @, arguments\n\n    @input_id ||= _.uniqueId('field')\n    @input_name ||= @name\n    @valueType ||= Luca.config.idAttributeType if @valueField is \"id\"\n    @label ||= @name\n    @retainValue = true unless @retainValue? \n\n  afterInitialize: ()->\n    if @collection?.data\n      @valueField ||= \"id\"\n      @displayField ||= \"name\"\n      @sortOptionsBy ||= @displayField\n      @parseData()\n\n    try\n      @configure_collection( @setAsDeferrable )\n    catch e\n      console.log \"Error Configuring Collection\", @, e.message\n\n    @collection?.bind \"before:fetch\", @beforeFetch, @\n    @collection?.bind \"reset\", @populateOptions, @\n\n  # if the select field is configured with a data property\n  # then parse that data into the proper format.  either\n  # an array of objects with the valueField and displayField\n  # properties, or an array of arrays with [valueField, displayField]\n  parseData: ()->\n    @collection.data = _( @collection.data ).map (record)=>\n      return record if not _.isArray( record )\n\n      hash = {}\n      hash[ @valueField ] = record[0]\n      hash[ @displayField ] = record[1] || record[0]\n\n      hash\n\n  getInputElement: ()->\n    @input ||= @$('select').eq(0)\n\n  afterRender: ()->\n    if @collection?.models?.length > 0\n      @populateOptions()\n    else\n      @collection?.trigger(\"reset\")\n\n  beforeFetch: ()->\n    @resetOptions()\n\n  change_handler: (e)->\n    @trigger \"on:change\", @, e\n\n  resetOptions: ()->\n    @getInputElement().html('')\n\n    if @allowMultiple\n      @getInputElement().attr(multiple: true)\n    else if @includeBlank\n      @getInputElement().append(\"<option value='#{ @blankValue }'>#{ @blankText }</option>\")\n\n  populateOptions: ()->\n    @resetOptions()\n\n    if @collection?.length > 0\n      if @sortOptionsBy?\n        models = @collection.sortBy (model)=>\n          if model.read?\n            model.read( @sortOptionsBy )\n          else\n            model.get( @sortOptionsBy )\n      else\n        models = @collection.models\n\n      for model in models\n        v = model.read?( @valueField ) || model.get(@valueField)\n        d = model.read?( @displayField ) || model.get(@displayField)\n\n        if @maxDisplayLength and @maxDisplayLength > 0\n          d = _.str.truncate(d, @maxDisplayLength)\n\n        selected = \"selected\" if @selected and v is @selected\n        option = \"<option #{ selected } value='#{ v }'>#{ d }</option>\"\n        @getInputElement().append( option )\n\n    @trigger \"after:populate:options\", @\n    @setValue( @currentValue )\n\nselectField.register()"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/text_area_field.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/text_area_field.coffee","type":"component_definition","starts_on_line":1,"class_name":"Luca.fields.TextAreaField","header_documentation":"","type_alias":"text_area_field","css_class_identifier":"luca-fields-text-area-field","defines_methods":{"initialize":{"defined_on_line":16,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"setValue":{"defined_on_line":35,"documentation":"","arguments":[{"argument":"value","value":null}]},"getValue":{"defined_on_line":38,"documentation":"","arguments":[]},"field":{"defined_on_line":41,"documentation":"","arguments":[]},"keyup_handler":{"defined_on_line":44,"documentation":"","arguments":[{"argument":"e","value":null}]},"blur_handler":{"defined_on_line":50,"documentation":"","arguments":[{"argument":"e","value":null}]},"focus_handler":{"defined_on_line":53,"documentation":"","arguments":[{"argument":"e","value":null}]},"change_handler":{"defined_on_line":56,"documentation":"","arguments":[{"argument":"e","value":null}]}},"defines_properties":{"autoBindEventHandlers":{"defined_on_line":4,"documentation":"","default":"true"},"events":{"defined_on_line":6,"documentation":"","default":null},"template":{"defined_on_line":10,"documentation":"","default":"'fields/text_area_field'"},"height":{"defined_on_line":12,"documentation":"","default":"\"200px\""},"width":{"defined_on_line":13,"documentation":"","default":"\"90%\""},"keyEventThrottle":{"defined_on_line":14,"documentation":"","default":"300"}},"source_file_contents":"textArea = Luca.register          \"Luca.fields.TextAreaField\"\ntextArea.extends                  \"Luca.core.Field\"\ntextArea.defines\n  autoBindEventHandlers: true\n\n  events:\n    \"blur textarea\" : \"blur_handler\"\n    \"focus textarea\" : \"focus_handler\"\n\n  template: 'fields/text_area_field'\n\n  height: \"200px\"\n  width: \"90%\"\n  keyEventThrottle: 300\n\n  initialize: (@options={})->\n\n    @input_id ||= _.uniqueId('field')\n    @input_name ||= @name\n    @label ||= @name\n    @input_class ||= @class\n    @input_value ||= \"\"\n    @inputStyles ||= \"height:#{ @height };width:#{ @width }\"\n    @placeHolder ||= \"\"\n\n    Luca.core.Field::initialize.apply @, arguments\n\n    if @enableKeyEvents is true\n      @keyup_handler = _.debounce(@keyup_handler, @keyEventThrottle || 10)\n\n      console.log \"Registering Key Events\"\n      @registerEvent(\"keyup textarea\",\"keyup_handler\")     \n      @registerEvent(\"keydown textarea\",\"keyup_handler\")     \n\n  setValue: (value)->\n    $( @field() ).val(value)\n\n  getValue: ()->\n    $( @field() ).val()\n\n  field: ()->\n    @input = @$(\"textarea\")\n\n  keyup_handler: (e)->\n    # TODO: Should ignore certain keyup events\n    # which would not indicate a change\n    @trigger \"on:change\", @, e\n    @trigger \"on:keyup\", @, e\n\n  blur_handler: (e)->\n    @trigger \"on:blur\", @, e\n\n  focus_handler: (e)->\n    @trigger \"on:focus\", @, e\n\n  change_handler: (e)-> \n    @trigger \"on:change\", @, e"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/text_field.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/text_field.coffee","type":"component_definition","starts_on_line":1,"class_name":"Luca.fields.TextField","header_documentation":"","type_alias":"text_field","css_class_identifier":"luca-fields-text-field","defines_methods":{"initialize":{"defined_on_line":18,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"keyup_handler":{"defined_on_line":43,"documentation":"","arguments":[{"argument":"e","value":null}]},"blur_handler":{"defined_on_line":49,"documentation":"","arguments":[{"argument":"e","value":null}]},"focus_handler":{"defined_on_line":52,"documentation":"","arguments":[{"argument":"e","value":null}]},"change_handler":{"defined_on_line":55,"documentation":"","arguments":[{"argument":"e","value":null}]}},"defines_properties":{"_inheritEvents":{"defined_on_line":5,"documentation":"","default":null},"template":{"defined_on_line":10,"documentation":"","default":"'fields/text_field'"},"autoBindEventHandlers":{"defined_on_line":12,"documentation":"","default":"true"},"send_blanks":{"defined_on_line":14,"documentation":"","default":"true"},"keyEventThrottle":{"defined_on_line":16,"documentation":"","default":"300"}},"source_file_contents":"textField = Luca.register     'Luca.fields.TextField'\ntextField.extends             'Luca.core.Field'\n\ntextField.defines\n  _inheritEvents:\n    \"blur input\" : \"blur_handler\"\n    \"focus input\" : \"focus_handler\"\n    \"change input\" : \"change_handler\"\n\n  template: 'fields/text_field'\n\n  autoBindEventHandlers: true\n\n  send_blanks: true\n\n  keyEventThrottle: 300\n\n  initialize: (@options={})->\n    if @enableKeyEvents\n      if @keyEventThrottle\n        @keyup_handler = _.debounce(@keyup_handler, @keyEventThrottle)\n        \n      @registerEvent(\"keyup input\",\"keyup_handler\")     \n\n    @input_id ||= _.uniqueId('field')\n    @input_name ||= @name\n    @label ||= @name\n    @input_class ||= @class\n    @input_value ||= @value || \"\" \n    \n    if @prepend\n      @$el.addClass 'input-prepend'\n      @addOn = @prepend\n\n    if @append\n      @$el.addClass 'input-append'\n      @addOn = @append\n\n    @placeHolder ||= \"\"\n\n    Luca.core.Field::initialize.apply @, arguments\n\n  keyup_handler: (e)->\n    # TODO: Should ignore certain keyup events\n    # which would not indicate a change\n    @trigger \"on:change\", @, e\n    @trigger \"on:keyup\", @, e\n\n  blur_handler: (e)->\n    @trigger \"on:blur\", @, e\n\n  focus_handler: (e)->\n    @trigger \"on:focus\", @, e\n\n  change_handler: (e)-> \n    @trigger \"on:change\", @, e\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/type_ahead_field.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/type_ahead_field.coffee","type":"component_definition","starts_on_line":1,"class_name":"Luca.fields.TypeAheadField","header_documentation":"","type_alias":"type_ahead_field","css_class_identifier":"luca-fields-type-ahead-field","defines_methods":{"getSource":{"defined_on_line":6,"documentation":"","arguments":[]},"matcher":{"defined_on_line":9,"documentation":"","arguments":[{"argument":"item","value":null}]},"beforeRender":{"defined_on_line":12,"documentation":"","arguments":[]},"afterRender":{"defined_on_line":16,"documentation":"","arguments":[]}},"defines_properties":{},"source_file_contents":"typeAheadField = Luca.register      \"Luca.fields.TypeAheadField\"\ntypeAheadField.extends              \"Luca.fields.TextField\" \n\n\ntypeAheadField.defines\n  getSource: ()->\n    Luca.util.read(@source) || []\n\n  matcher: (item)->\n    true\n\n  beforeRender: ()->\n    Luca.fields.TextField::beforeRender.apply(@, arguments)\n    @getInputElement().attr('data-provide','typeahead')\n\n  afterRender: ()->\n    Luca.fields.TextField::afterRender.apply(@, arguments)\n    @getInputElement().typeahead\n      matcher: @matcher\n      source: @getSource()"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/form_view.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/form_view.coffee","type":"component_definition","starts_on_line":7,"class_name":"Luca.components.FormView","header_documentation":"<p>The FormView component is a special container which provides functionality\naround the components inside which extend from the Luca.core.Field class.\nThe FormView component integrates well with Luca.Models and can control\nthe attributes on that model, respond to validations, and submit changes\nto an API.</p>\n","type_alias":"form_view","css_class_identifier":"luca-form-view","defines_methods":{"initialize":{"defined_on_line":110,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"onFieldChange":{"defined_on_line":138,"documentation":"","arguments":[{"argument":"field","value":null},{"argument":"e","value":null}]},"getDefaultToolbar":{"defined_on_line":142,"documentation":"","arguments":[]},"applyStyleClasses":{"defined_on_line":146,"documentation":"","arguments":[]},"applyBootstrapStyleClasses":{"defined_on_line":153,"documentation":"","arguments":[]},"resetHandler":{"defined_on_line":161,"documentation":"","arguments":[{"argument":"e","value":null}]},"submitHandler":{"defined_on_line":170,"documentation":"","arguments":[{"argument":"e","value":null}]},"afterComponents":{"defined_on_line":180,"documentation":"","arguments":[]},"eachField":{"defined_on_line":188,"documentation":"","arguments":[{"argument":"iterator","value":null}]},"getField":{"defined_on_line":191,"documentation":"","arguments":[{"argument":"name","value":null}]},"getFields":{"defined_on_line":197,"documentation":"","arguments":[{"argument":"attr","value":null},{"argument":"value","value":null}]},"loadModel":{"defined_on_line":208,"documentation":"","arguments":[{"argument":"model","value":null}]},"reset":{"defined_on_line":230,"documentation":"","arguments":[]},"clear":{"defined_on_line":233,"documentation":"","arguments":[]},"isDirty":{"defined_on_line":242,"documentation":"","arguments":[]},"setValues":{"defined_on_line":247,"documentation":"<p>set the values on the form\nwithout syncing</p>\n","arguments":[{"argument":"source","value":null},{"argument":"options","value":"{}"}]},"getValues":{"defined_on_line":270,"documentation":"<p>Public: returns a hash of values for the form fields in this view.</p>\n\n<p>options - An options Hash to control the behavior of values returned (default: {}):\nreject<em>blank: don&#39;t include values which are blank (default: true)\nskip</em>buttons: don&#39;t include button fields (default: true)\nblanks: an inverse alias for reject_blank (default: false)</p>\n","arguments":[{"argument":"options","value":"{}"}]},"removeErrors":{"defined_on_line":309,"documentation":"","arguments":[]},"displayErrors":{"defined_on_line":316,"documentation":"","arguments":[{"argument":"errors","value":null}]},"displayValidationErrorsMessage":{"defined_on_line":326,"documentation":"","arguments":[]},"submit_success_handler":{"defined_on_line":329,"documentation":"","arguments":[{"argument":"model","value":null},{"argument":"response","value":null},{"argument":"xhr","value":null}]},"submit_fatal_error_handler":{"defined_on_line":338,"documentation":"","arguments":[{"argument":"model","value":null},{"argument":"response","value":null},{"argument":"xhr","value":null}]},"submit":{"defined_on_line":348,"documentation":"","arguments":[{"argument":"save","value":"true"},{"argument":"saveOptions","value":"{}"}]},"hasModel":{"defined_on_line":359,"documentation":"","arguments":[]},"currentModel":{"defined_on_line":362,"documentation":"","arguments":[{"argument":"options","value":"{}"}]},"applyFormValuesToModel":{"defined_on_line":368,"documentation":"","arguments":[{"argument":"options","value":null}]},"setLegend":{"defined_on_line":371,"documentation":"","arguments":[{"argument":"@legend","value":null}]},"flash":{"defined_on_line":374,"documentation":"","arguments":[{"argument":"message","value":null}]},"successMessage":{"defined_on_line":382,"documentation":"","arguments":[{"argument":"message","value":null}]},"errorMessage":{"defined_on_line":389,"documentation":"","arguments":[{"argument":"message","value":null}]},"setupToolbar":{"defined_on_line":394,"documentation":"","arguments":[]}},"defines_properties":{"trackDirtyState":{"defined_on_line":35,"documentation":"<p>track dirty state will bind to change events\non all of the underlying fields, and set a\nflag whenever one of them changes</p>\n","default":"false"},"trackModelChanges":{"defined_on_line":38,"documentation":"<p>don&#39;t setup two way binding to the model</p>\n","default":"false"},"labelAlign":{"defined_on_line":42,"documentation":"<p>should the label display above, or to the\nside of the fields</p>\n","default":"undefined"},"fieldLayoutClass":{"defined_on_line":46,"documentation":"<p>specifying this class gives you the ability\nto layout the nested fields accordingly.</p>\n","default":"undefined"},"legend":{"defined_on_line":49,"documentation":"<p>should this form have a legend?</p>\n","default":"\"\""},"toolbar":{"defined_on_line":55,"documentation":"<p>available options are true, false, &quot;top&quot;, &quot;bottom&quot;, or &quot;both&quot;\nthe component configuration for the toolbar can be controlled\nby specifying a name of a property that contains a valid\ncomponent reference ( either hash w/ type reference )</p>\n","default":"true"},"toolbarConfig":{"defined_on_line":60,"documentation":"<p>the name of the property which contains the configuration\nfor the buttons that will go in this toolbar.  Specify\na string so it can be lazily evaluated at initialization.</p>\n","default":"undefined"},"defaultToolbar":{"defined_on_line":66,"documentation":"<p>the default toolbar definition that will be created if\nthe form is configured to have a toolbar on it.  this value\nwill be resolved at initialization, so pass a string identifying\nan object in memory.</p>\n","default":"\"Luca.components.FormView.defaultToolbar\""},"loadMask":{"defined_on_line":71,"documentation":"<p>if this form will be submitting values to a RESTful API and you\nwant to show a loading indicator or progress bar, configure the\n@loadMask property.</p>\n","default":"true"},"well":{"defined_on_line":75,"documentation":"<p>Applies the twitter bootstrap well class to this form.\n@$el.addClass(&#39;well&#39;) if @well</p>\n","default":"false"},"searchForm":{"defined_on_line":79,"documentation":"<p>Applies the twitter bootstrap form-search class to this form.\n@$el.addClass(&#39;form-search&#39;) if @searchForm</p>\n","default":"false"},"horizontalForm":{"defined_on_line":83,"documentation":"<p>Applies the twitter bootstrap horizontal form class to this form.\n@$el.addClass(&#39;form-horizontal&#39;) if @horizontalForm</p>\n","default":"false"},"inlineForm":{"defined_on_line":87,"documentation":"<p>Applies the twitter bootstrap inline form class to this form.\n@$el.addClass(&#39;form-inline&#39;) if @inlineForm</p>\n","default":"false"},"includeBlankValues":{"defined_on_line":91,"documentation":"<p>if we should always include blank values\nregardless of how the field is configured</p>\n","default":"undefined"},"tagName":{"defined_on_line":94,"documentation":"","default":"'form'"},"_inheritEvents":{"defined_on_line":99,"documentation":"<p>These events will get registered on the component\nbut still leave the @events property open to extend\nfor any component which inherits from us.</p>\n","default":null},"bodyClassName":{"defined_on_line":103,"documentation":"","default":"\"form-view-body\""},"stateful":{"defined_on_line":105,"documentation":"","default":null},"successFlashDelay":{"defined_on_line":380,"documentation":"","default":"1500"},"version":{"defined_on_line":420,"documentation":"","default":"2"}},"source_file_contents":"# The FormView component is a special container which provides functionality\n# around the components inside which extend from the Luca.core.Field class.\n#\n# The FormView component integrates well with Luca.Models and can control\n# the attributes on that model, respond to validations, and submit changes\n# to an API.\nformView = Luca.register        \"Luca.components.FormView\"\n\nformView.extends                \"Luca.Container\"\n\nformView.mixesIn                \"LoadMaskable\",\n                                \"FormModelBindings\"\n\nformView.triggers               \"before:submit\",\n                                \"before:reset\",\n                                \"before:load\",\n                                \"before:load:new\",\n                                \"before:load:existing\",\n                                \"after:submit\",\n                                \"after:reset\",\n                                \"after:load\",\n                                \"after:load:new\",\n                                \"after:load:existing\",\n                                \"after:submit:success\",\n                                \"after:submit:fatal_error\",\n                                \"after:submit:error\",\n                                \"state:change:dirty\"\n\n\n\nformView.publicConfiguration\n  # track dirty state will bind to change events\n  # on all of the underlying fields, and set a\n  # flag whenever one of them changes\n  trackDirtyState: false\n\n  # don't setup two way binding to the model\n  trackModelChanges: false\n\n  # should the label display above, or to the\n  # side of the fields\n  labelAlign: undefined\n\n  # specifying this class gives you the ability\n  # to layout the nested fields accordingly.\n  fieldLayoutClass: undefined\n\n  # should this form have a legend?\n  legend: \"\"\n\n  # available options are true, false, \"top\", \"bottom\", or \"both\"\n  # the component configuration for the toolbar can be controlled\n  # by specifying a name of a property that contains a valid\n  # component reference ( either hash w/ type reference )\n  toolbar: true\n\n  # the name of the property which contains the configuration\n  # for the buttons that will go in this toolbar.  Specify\n  # a string so it can be lazily evaluated at initialization.\n  toolbarConfig: undefined\n\n  # the default toolbar definition that will be created if\n  # the form is configured to have a toolbar on it.  this value\n  # will be resolved at initialization, so pass a string identifying\n  # an object in memory.\n  defaultToolbar: \"Luca.components.FormView.defaultToolbar\"\n\n  # if this form will be submitting values to a RESTful API and you\n  # want to show a loading indicator or progress bar, configure the\n  # @loadMask property.\n  loadMask: true\n\n  # Applies the twitter bootstrap well class to this form.\n  # @$el.addClass('well') if @well\n  well: false\n\n  # Applies the twitter bootstrap form-search class to this form.\n  # @$el.addClass('form-search') if @searchForm\n  searchForm: false\n\n  # Applies the twitter bootstrap horizontal form class to this form.\n  # @$el.addClass('form-horizontal') if @horizontalForm\n  horizontalForm: false\n\n  # Applies the twitter bootstrap inline form class to this form.\n  # @$el.addClass('form-inline') if @inlineForm\n  inlineForm: false\n\n  # if we should always include blank values\n  # regardless of how the field is configured\n  includeBlankValues: undefined\n\nformView.privateConfiguration\n  tagName: 'form'\n\n  # These events will get registered on the component\n  # but still leave the @events property open to extend\n  # for any component which inherits from us.\n  _inheritEvents:\n    \"click .submit-button\" : \"submitHandler\"\n    \"click .reset-button\" : \"resetHandler\"\n\n  bodyClassName: \"form-view-body\"\n\n  stateful:\n    dirty: false\n    currentModel: undefined\n\nformView.privateMethods\n  initialize: (@options={})->\n    form = @\n\n    @loadMask = Luca.config.enableBoostrap unless @loadMask?\n\n    Luca.Container::initialize.apply @, arguments\n\n    @components ||= @fields\n\n    _.bindAll @, \"submitHandler\", \"resetHandler\", \"renderToolbars\"\n\n    # have our events be internal to the view, and not\n    # part of the normal @events chain, so they can be inherited\n    for eventId, handler of @_inheritEvents\n      @registerEvent(eventId, handler)\n\n    if @trackDirtyState is true\n      @on \"after:components\", ()->\n        for field in @getFields()\n          field.on \"on:change\", @onFieldChange, form\n      , form\n\n    @setupHooks( @hooks )\n\n    @applyStyleClasses()\n\n    Luca.components.FormView.setupToolbar.call(@)\n\n  onFieldChange: (field, e)->\n    @trigger \"field:change\", field, e\n    @state.set('dirty', true)\n\n  getDefaultToolbar: ()->\n    config = @toolbarConfig || @defaultToolbar\n    Luca.util.resolve( Luca.util.read(config) )\n\n  applyStyleClasses: ()->\n    if Luca.config.enableBoostrap\n      @applyBootstrapStyleClasses()\n\n    @$el.addClass( \"label-align-#{ @labelAlign }\") if @labelAlign\n    @$el.addClass( @fieldLayoutClass ) if @fieldLayoutClass\n\n  applyBootstrapStyleClasses: ()->\n    @inlineForm = true if @labelAlign is \"left\"\n\n    @$el.addClass('well') if @well\n    @$el.addClass('form-search') if @searchForm\n    @$el.addClass('form-horizontal') if @horizontalForm\n    @$el.addClass('form-inline') if @inlineForm\n\n  resetHandler: (e)->\n    me = my = $( e?.target )\n    if @beforeReset?\n      result = @beforeReset()\n      return if result is false\n\n    @reset()\n    @trigger \"after:reset\", @\n\n  submitHandler: (e)->\n    if @beforeSubmit?\n      result = @beforeSubmit()\n      return if result is false\n    else\n      @trigger \"before:submit\", @\n\n    @trigger \"enable:loadmask\", @ if @loadMask is true\n    @submit() if @hasModel()\n\n  afterComponents: ()->\n    Luca.Container::afterComponents?.apply(@, arguments)\n\n    form = @\n    @eachField (field)->\n      field.getForm = ()=> form\n      field.getModel = ()=> form.currentModel()\n\n  eachField: (iterator)->\n    _( @getFields() ).map( iterator )\n\n  getField: (name)->\n    passOne = _( @getFields('name', name) ).first()\n    return passOne if passOne?\n\n    _( @getFields('input_name', name) ).first()\n\n  getFields: (attr,value)->\n    fields = @selectByAttribute(\"isField\", true, true)\n\n    if attr? and value?\n      fields = _(fields).select (field)->\n        property  = field[ attr ]\n        property  = property.call(field) if _.isFunction(property)\n        property is value\n\n    fields\n\n  loadModel: (model)->\n    form = @\n    fields = @getFields()\n\n    @state.set('dirty', false)\n\n    @trigger \"before:load\", @, model\n\n    if model\n      model.beforeFormLoad?.apply(model, @)\n      event = \"before:load:#{ (if model.isNew() then \"new\" else \"existing\")}\"\n      @trigger event, @, model\n\n    @state.set('currentModel', model)\n\n    @setValues(model || {}, silent: true)\n\n    @trigger \"after:load\", @, model\n\n    if model\n      @trigger \"after:load:#{ (if model.isNew() then \"new\" else \"existing\")}\", @, model\n\n  reset: ()->\n    @loadModel( @state.get('currentModel') )\n\n  clear: ()->\n    @state.set('currentModel', @defaultModel?() )\n\n    _( @getFields() ).each (field)=>\n      try\n        field.setValue('')\n      catch e\n        console.log \"Error Clearing\", @, field\n\n  isDirty: ()->\n    !!@state.get('dirty')\n\n  # set the values on the form\n  # without syncing\n  setValues: (source, options={})->\n    source ||= @currentModel()\n    fields = @getFields()\n\n    _( fields ).each (field) =>\n      field_name = field.input_name || field.name\n\n      if source?[field_name]\n        value = Luca.util.read( source[field_name] )\n\n      if !value and Luca.isBackboneModel(source)\n        value = source.get(field_name)\n\n      field?.setValue( value ) unless field.readOnly is true\n\n    @applyFormValuesToModel() unless options.silent? is true\n\n  # Public: returns a hash of values for the form fields in this view.\n  #\n  # options - An options Hash to control the behavior of values returned (default: {}):\n  #           reject_blank: don't include values which are blank (default: true)\n  #           skip_buttons: don't include button fields (default: true)\n  #           blanks: an inverse alias for reject_blank (default: false)\n  getValues: (options={})->\n    options.reject_blank = true unless options.reject_blank?\n    options.skip_buttons = true unless options.skip_buttons?\n    options.reject_blank = true if options.blanks is false\n\n    values = _( @getFields() ).inject (memo,field)=>\n      value   = field.getValue()\n      key     = field.input_name || field.name\n\n      valueIsBlank      = !!(_.str.isBlank( value ) || _.isUndefined( value ))\n\n      allowBlankValues  = not options.reject_blank and not field.send_blanks\n      allowBlankValues = true if field.includeBlank is true or @includeBlankValues is true\n\n\n      if options.debug\n        console.log \"#{ key } Options\", options, \"Value\", value, \"Value Is Blank?\", valueIsBlank, \"Allow Blanks?\", allowBlankValues\n\n      if options.skip_buttons and field.isButton\n        skip = true\n      else\n        if valueIsBlank and allowBlankValues is false\n          skip = true\n\n        if field.input_name is \"id\" and valueIsBlank is true\n          skip = true\n\n      if options.debug\n        console.log \"Skip is true on #{ key }\"\n\n      if skip isnt true\n        memo[ key ] = value\n\n      memo\n\n    , (options.defaults || {})\n\n    values\n\n  removeErrors: ()->\n    @$('.alert.alert-error').remove()\n    @$el.removeClass('error')\n\n    for field in @getFields()\n      field.clearErrors()\n\n  displayErrors: (errors)->\n    has_errors = false\n    for field in @getFields()\n      for field_name, field_errors of errors when field_name is field.input_name\n        field.displayErrors(field_errors)\n        has_errors = true\n\n    if has_errors\n      @$el.addClass('error')\n\n  displayValidationErrorsMessage: ()->\n    @errorMessage('Please fix the fields with errors')\n\n  submit_success_handler: (model, response, xhr)->\n    @trigger \"after:submit\", @, model, response\n    @trigger \"disable:loadmask\", @ if @loadMask is true\n\n    if response and response?.success is true\n      @trigger \"after:submit:success\", @, model, response\n    else\n      @trigger \"after:submit:error\", @, model, response\n\n  submit_fatal_error_handler: (model, response, xhr)->\n    @trigger \"after:submit\", @, model, response\n    @trigger \"after:submit:fatal_error\", @, model, response\n\n    try\n      json = $.parseJSON(response.responseText)\n      if !json.success && json.errors?\n        @displayValidationErrorsMessage()\n        @displayErrors(json.errors)\n\n  submit: (save=true, saveOptions={})->\n    _.bindAll @, \"submit_success_handler\", \"submit_fatal_error_handler\"\n\n    saveOptions.success ||= @submit_success_handler\n    saveOptions.error ||= @submit_fatal_error_handler\n\n    @removeErrors()\n    @applyFormValuesToModel()\n    return unless save\n    @currentModel()?.save( @currentModel().toJSON(), saveOptions )\n\n  hasModel: ()->\n    @currentModel()?\n\n  currentModel: (options={})->\n    if options is true or options?.refresh is true\n      @applyFormValuesToModel()\n\n    @state.get('currentModel')\n\n  applyFormValuesToModel: (options)->\n    @currentModel()?.set( @getValues(), options )\n\n  setLegend: (@legend)->\n    $('fieldset legend', @el).first().html(@legend)\n\n  flash: (message)->\n    if @$('.toolbar-container.top').length > 0\n      @$('.toolbar-container.top').after(message)\n    else\n      @$bodyEl().prepend(message)\n\n  successFlashDelay: 1500\n\n  successMessage: (message)->\n    @$('.alert.alert-success').remove()\n    @flash Luca.template(\"components/form_alert\", className:\"alert alert-success\", message: message)\n    _.delay ()=>\n      @$('.alert.alert-success').fadeOut()\n    , @successFlashDelay || 0\n\n  errorMessage: (message)->\n    @$('.alert.alert-error').remove()\n    @flash Luca.template(\"components/form_alert\", className:\"alert alert-error\", message: message)\n\nformView.classInterface\n  setupToolbar: ()->\n    if @toolbar isnt false and (not @topToolbar and not @bottomToolbar)\n      if @toolbar is \"both\" or @toolbar is \"top\"\n        @topToolbar = _.clone( @getDefaultToolbar() )\n\n      unless @toolbar is \"top\"\n        @bottomToolbar = _.clone( @getDefaultToolbar() )\n\n  defaultToolbar:\n    buttons:[\n      icon:\"remove-sign\"\n      label: \"Reset\"\n      eventId: \"click:reset\"\n      className:\"reset-button\"\n      align: 'right'\n    ,\n      icon:\"ok-sign\"\n      white: true\n      label: \"Save Changes\"\n      eventId: \"click:submit\"\n      color: \"success\"\n      className: 'submit-button'\n      align: 'right'\n    ]\n\nformView.defines\n  version: 2\n\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/grid_layout_view.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/grid_layout_view.coffee","type":"component_definition","starts_on_line":1,"class_name":"Luca.components.GridLayoutView","header_documentation":"","type_alias":"grid_layout_view","css_class_identifier":"luca-grid-layout-view","defines_methods":{"attributesForItem":{"defined_on_line":19,"documentation":"<p>adds the bootstrap span class to each collection-item,\nwhere span class is equal to the 12 column grid / @itemsPerRow.\nfor example, each item would receive a span4 class when @itemsPerRow = 3</p>\n","arguments":[]},"renderModels":{"defined_on_line":29,"documentation":"<p>wraps every N number of rows, where N = @itemsPerRow\nin a row-fluid wrapper, and appends it to the view</p>\n","arguments":[{"argument":"models","value":null}]}},"defines_properties":{"itemsPerRow":{"defined_on_line":8,"documentation":"<p>how many items do you wish to render per row?\nassuming a 12 column grid, each item will receive\nan equal amount of grid span/columns.</p>\n","default":"3"},"className":{"defined_on_line":11,"documentation":"","default":"\"grid-layout-view\""},"tagName":{"defined_on_line":12,"documentation":"","default":"\"div\""},"itemTagName":{"defined_on_line":13,"documentation":"","default":"\"div\""}},"source_file_contents":"gridView = Luca.register    \"Luca.components.GridLayoutView\"\ngridView.extends            \"Luca.CollectionView\"\n\ngridView.publicConfiguration\n  # how many items do you wish to render per row?\n  # assuming a 12 column grid, each item will receive\n  # an equal amount of grid span/columns.\n  itemsPerRow: 3\n\ngridView.privateConfiguration\n  className: \"grid-layout-view\"\n  tagName: \"div\"\n  itemTagName: \"div\"\n\ngridView.privateMethods\n  # adds the bootstrap span class to each collection-item,\n  # where span class is equal to the 12 column grid / @itemsPerRow.\n  # for example, each item would receive a span4 class when @itemsPerRow = 3\n  attributesForItem: ()->\n    base = Luca.CollectionView::attributesForItem.apply(@, arguments)\n    @itemsPerRow = 3 unless _.isNumber(@itemsPerRow) and @itemsPerRow > 1\n    columns = parseInt(12 / @itemsPerRow)\n    base.class += \" span#{ columns }\"\n\n    base\n\n  # wraps every N number of rows, where N = @itemsPerRow\n  # in a row-fluid wrapper, and appends it to the view\n  renderModels: (models)->\n    index = 0\n    rowIndex = 0\n\n    rows = for model in models\n      row = @make(\"div\", class:\"row-fluid\") if rowIndex++ is 0\n      $(row).append @makeItem(model,index++)\n      rowIndex = 0 if index > 0 and index % @itemsPerRow is 0\n      row\n\n    for row in rows\n      @$append(row) \n\ngridView.register()\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/load_mask.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/load_mask.coffee","type":"component_definition","starts_on_line":2,"class_name":"Luca.components.LoadMask","header_documentation":"<p>#_.def(&quot;Luca.components.LoadMask&quot;).extends(&quot;Luca.View&quot;).with</p>\n","type_alias":"load_mask","css_class_identifier":"luca-load-mask","defines_methods":{},"defines_properties":{"className":{"defined_on_line":7,"documentation":"","default":"\"luca-ui-load-mask\""},"bodyTemplate":{"defined_on_line":8,"documentation":"","default":"\"components/load_mask\""}},"source_file_contents":"#_.def(\"Luca.components.LoadMask\").extends(\"Luca.View\").with\nloadMask = Luca.register  \"Luca.components.LoadMask\"\n\nloadMask.extends          \"Luca.View\"\n\nloadMask.defines\n  className: \"luca-ui-load-mask\"\n  bodyTemplate:\"components/load_mask\"\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/multi_collection_view.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/multi_collection_view.coffee","type":"component_definition","starts_on_line":1,"class_name":"Luca.components.MultiCollectionView","header_documentation":"","type_alias":"multi_collection_view","css_class_identifier":"luca-multi-collection-view","defines_methods":{"initialize":{"defined_on_line":42,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"relayAfterRefresh":{"defined_on_line":54,"documentation":"","arguments":[{"argument":"models","value":null},{"argument":"query","value":null},{"argument":"options","value":null}]},"refresh":{"defined_on_line":57,"documentation":"","arguments":[]},"propagateCollectionComponents":{"defined_on_line":61,"documentation":"","arguments":[]},"validateComponent":{"defined_on_line":81,"documentation":"","arguments":[{"argument":"component","value":null}]}},"defines_properties":{"stateful":{"defined_on_line":39,"documentation":"","default":null},"version":{"defined_on_line":92,"documentation":"","default":"3"}},"source_file_contents":"multiView = Luca.register     \"Luca.components.MultiCollectionView\"\n\n# The CollectionMultiView is a collection view with multiple renderings\n# of the list.  ( e.g. Icons, Table, List ).  It works by maintaining\n# a current view, and rendering that view.  It refreshes the views\n# whenever they are activated. \n#\n# The MultiView allows you to share one collection, filter, pagination setup\n# but render multiple versions of a model.  To do this, you  are expected to\n# define one or more objects in the @views property of the component.\n\n# Example:\n#   multiView = new Luca.components.MultiCollectionView\n#     collection: \"my_collection\"\n#     paginatable:\n#       page: 1\n#       limit: 20\n#     views:[\n#       type:           \"table\"\n#       columns:[\n#         header: \"Header\"\n#         reader: \"attribute\"\n#       ]\n#     ]\nmultiView.extends           \"Luca.containers.CardView\"\n\nmultiView.mixesIn           \"QueryCollectionBindings\", \n                            \"LoadMaskable\",\n                            \"Filterable\",\n                            \"Paginatable\",\n                            \"Sortable\"\n\nmultiView.triggers          \"before:refresh\",\n                            \"after:refresh\",\n                            \"refresh\",\n                            \"empty:results\"\n\nmultiView.private\n  stateful:\n    activeView: 0\n\n  initialize: (@options={})->\n    @components ||= @views\n\n    for view in @components    \n      Luca.components.MultiCollectionView.validateComponent( view ) \n\n    Luca.containers.CardView::initialize.apply(@, arguments) \n\n    @on \"data:refresh\", @refresh, @\n    @on \"after:card:switch\", @refresh, @\n    @on \"after:components\", Luca.components.MultiCollectionView.propagateCollectionComponents, @\n\n  relayAfterRefresh: (models,query,options)->\n    @trigger \"after:refresh\", models, query, options\n\n  refresh: ()->\n    @activeComponent()?.refresh()\n\nmultiView.classMethods\n  propagateCollectionComponents: ()->\n    container = @\n\n    # in the multi view will share the same\n    # collection, filter state, pagination options, etc\n    for component in @components\n\n      component.on \"after:refresh\", (models,query,options)=> \n        @debug \"collection member after refresh\"\n        @trigger(\"after:refresh\",models,query,options)\n\n      _.extend component, \n        collection: container.getCollection() \n        getQuery: _.bind(container.getQuery, container)\n        getQueryOptions: _.bind(container.getQueryOptions, container)\n\n      if container.prepareQuery?\n        _.extend component,\n          prepareQuery: _.bind(container.prepareQuery, container)\n\n  validateComponent: (component)->\n    type = (component.type || component.ctype)\n\n    return if  type is \"collection\" or \n               type is \"collection_view\" or\n               type is \"table\" or\n               type is \"table_view\" \n\n    throw \"The MultiCollectionView expects to contain multiple collection views\" \n\nmultiView.defines\n  version: 3\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/nav_bar.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/nav_bar.coffee","type":"component_definition","starts_on_line":25,"class_name":"Luca.components.NavBar","header_documentation":"<p>A Twitter Bootstrap compatible navigation bar.  The Luca.Application\nand Luca.containers.Viewport class both have configuration options for\ncreating navbar components in the header and footer of the viewport.</p>\n\n<h4>Example of an Application with a Navbar</h4>\n\n<h5>Component Definition</h5>\n\n<pre><code>  # Navigation Component\n  navBar = Luca.register  &quot;App.views.TopNavigation&quot;\n  navBar.extends          &quot;Luca.components.NavBar&quot;\n  navBar.defines\n    brand: &quot;My App&quot;\n    # for white on black\n    inverse: true\n</code></pre>\n\n<p>We are able to reference the component we just defined in the\nconfiguration of the Application, simply by using it&#39;s \ntype alias <code>top_navigation</code>\n      # Application Component\n      app = Luca.register       &quot;App.Application&quot;\n      app.extends               &quot;Luca.Application&quot;\n      app.defines\n        topNav: &quot;top_navigation&quot;</p>\n","type_alias":"nav_bar","css_class_identifier":"luca-nav-bar","defines_methods":{"beforeRender":{"defined_on_line":54,"documentation":"","arguments":[]},"render":{"defined_on_line":70,"documentation":"","arguments":[]},"navContainer":{"defined_on_line":73,"documentation":"","arguments":[]},"content":{"defined_on_line":76,"documentation":"","arguments":[]}},"defines_properties":{"fixed":{"defined_on_line":31,"documentation":"<p>Specify whether the navbar is supposed to be fixed\nthe way Twitter bootstrap navbar can be.</p>\n","default":"true"},"position":{"defined_on_line":34,"documentation":"<p>Valid options are &#39;top&#39;, &#39;bottom&#39;.  Only valid when <code>@fixed is true</code></p>\n","default":"'top'"},"fluid":{"defined_on_line":38,"documentation":"<p>Specify whether the navbar should use the fluid grid.\nUsually the same as your Viewport setting.</p>\n","default":"undefined"},"brand":{"defined_on_line":42,"documentation":"<p>What content do you want to show in the logo area of the\nstandard bootstrap nav</p>\n","default":"\"Luca.js\""},"template":{"defined_on_line":47,"documentation":"<p>Specifies an optional template to use for the navigation menu\ncontent.  Whatever you specify will be rendered inside of the\ncollapsible container inside of the standard bootstrap nav.</p>\n","default":"undefined"},"className":{"defined_on_line":50,"documentation":"","default":"'navbar'"},"bodyTemplate":{"defined_on_line":51,"documentation":"","default":"'nav_bar'"},"bodyClassName":{"defined_on_line":52,"documentation":"","default":"'luca-ui-navbar-body'"}},"source_file_contents":"# A Twitter Bootstrap compatible navigation bar.  The Luca.Application\n# and Luca.containers.Viewport class both have configuration options for\n# creating navbar components in the header and footer of the viewport.\n#\n# #### Example of an Application with a Navbar\n# ##### Component Definition\n#       # Navigation Component\n#       navBar = Luca.register  \"App.views.TopNavigation\"\n#       navBar.extends          \"Luca.components.NavBar\"\n#       navBar.defines\n#         brand: \"My App\"\n#         # for white on black\n#         inverse: true\n#\n# We are able to reference the component we just defined in the\n# configuration of the Application, simply by using it's \n# type alias `top_navigation`\n#\n#       # Application Component\n#       app = Luca.register       \"App.Application\"\n#       app.extends               \"Luca.Application\"\n#       app.defines\n#         topNav: \"top_navigation\"\n#\nnavBar = Luca.register \"Luca.components.NavBar\"\nnavBar.extends         \"Luca.View\"\n\nnavBar.publicConfiguration\n  # Specify whether the navbar is supposed to be fixed\n  # the way Twitter bootstrap navbar can be.\n  fixed: true\n\n  # Valid options are 'top', 'bottom'.  Only valid when `@fixed is true`\n  position: 'top'\n\n  # Specify whether the navbar should use the fluid grid. \n  # Usually the same as your Viewport setting.\n  fluid: undefined\n\n  # What content do you want to show in the logo area of the\n  # standard bootstrap nav\n  brand: \"Luca.js\"\n\n  # Specifies an optional template to use for the navigation menu\n  # content.  Whatever you specify will be rendered inside of the \n  # collapsible container inside of the standard bootstrap nav.\n  template: undefined\n\nnavBar.privateConfiguration\n  className: 'navbar'\n  bodyTemplate: 'nav_bar'\n  bodyClassName: 'luca-ui-navbar-body'\n\n  beforeRender: ()->\n    @$el.addClass \"navbar-fixed-#{ @position }\" if @fixed\n    @$el.addClass \"navbar-inverse\" if @inverse is true\n\n    if @brand?\n      @$('.brand').attr('href', @homeLink || '#')\n      @$('.brand').html(@brand)\n\n    if @template\n      @navContainer().html Luca.template(@template, @)\n\n    if !!(@fluid || Luca.getApplication()?.fluid)\n      @content().addClass( Luca.config.fluidWrapperClass )\n    else\n      @content().addClass( Luca.config.wrapperClass )\n\n  render: ()->\n    @\n\n  navContainer: ()->\n    @$('.luca-ui-navbar-body .nav-collapse')\n\n  content: ()->\n    @$('.luca-ui-navbar-body').eq(0)\n\n\nnavBar.register()"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/page.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/page.coffee","type":"component_definition","starts_on_line":21,"class_name":"Luca.components.Page","header_documentation":"<p>The <code>Page</code> is a type of <code>Container</code> that has\nall of its subcomponents visible at one time, \nand assigned to various <code>@regions</code> that exist\nin the <code>@layout</code> template which provide its \ninternal dom structure.</p>\n\n<h4>Example Template (haml):</h4>\n\n<pre><code>  .page.layout.row-fluid{&quot;data-layout&quot;=&gt;&quot;layouts/left_nav_grid&quot;}\n    .span3.region{&quot;data-region&quot;=&gt;&quot;left&quot;}\n    .span9.region{&quot;data-region&quot;=&gt;&quot;right&quot;}\n</code></pre>\n\n<h3>Example Page Configuration</h3>\n\n<pre><code>page = new Luca.components.Page\n  layout: &quot;layouts/left_nav_grid&quot;\n  regions:\n    left: \n      type: &quot;navigation&quot;\n    right:\n      type: &quot;details&quot;\n</code></pre>\n","type_alias":"page","css_class_identifier":"luca-page","defines_methods":{"initialize":{"defined_on_line":26,"documentation":"<p><code>Page</code>s are typically instantiated by a <code>Luca.components.Controller</code></p>\n","arguments":[{"argument":"@options","value":"{}"}]},"assignComponentsToRegions":{"defined_on_line":34,"documentation":"<p>Takes the configuration specified in @regions\nand creates a components hash out of them.</p>\n","arguments":[]}},"defines_properties":{"layout":{"defined_on_line":54,"documentation":"","default":"undefined"},"regions":{"defined_on_line":68,"documentation":"<p>The @regions property assigns containers ( by their type alias )\nto DOM elements identified as regions within a layout template.</p>\n\n<h4>Example:</h4>\n\n<p>new Luca.components.Page\nregions:\nleft: &quot;my<em>component&quot;\nright:\ntype: &quot;my</em>other<em>component&quot;\nrole: &quot;component</em>role&quot;</p>\n\n<p>This will render an instance of MyComponent to this\npage&#39;s @$(&#39;[data-region-id=&quot;right&quot;]&#39;) DOM element.</p>\n","default":"{}"}},"source_file_contents":"# The `Page` is a type of `Container` that has\n# all of its subcomponents visible at one time, \n# and assigned to various `@regions` that exist\n# in the `@layout` template which provide its \n# internal dom structure.\n#\n# #### Example Template (haml):\n#       .page.layout.row-fluid{\"data-layout\"=>\"layouts/left_nav_grid\"}\n#         .span3.region{\"data-region\"=>\"left\"}\n#         .span9.region{\"data-region\"=>\"right\"}\n#\n# ### Example Page Configuration\n#     page = new Luca.components.Page\n#       layout: \"layouts/left_nav_grid\"\n#       regions:\n#         left: \n#           type: \"navigation\"\n#         right:\n#           type: \"details\"\n#\npage = Luca.register       \"Luca.components.Page\"\npage.extends               \"Luca.Container\"\n\npage.privateMethods\n  # `Page`s are typically instantiated by a `Luca.components.Controller`\n  initialize: (@options={})->\n    @assignComponentsToRegions()\n    @bodyTemplate = @options.layout || @layout\n    @bodyTemplate ||= @options.template || @template\n    Luca.Container::initialize.apply(@, arguments)\n\n  # Takes the configuration specified in @regions\n  # and creates a components hash out of them.\n  assignComponentsToRegions: ()->\n    @components ||= []\n\n    assigned = for regionId, regionAssignment of @regions\n      if _.isString(regionAssignment) and componentClass = Luca.registry.lookup( regionAssignment )\n        regionAssignment = \n          component: regionAssignment\n      else if _.isString(regionAssignment) and Luca.template(regionAssignment)\n        regionAssignment = \n          bodyTemplate: regionAssignment\n\n      _.extend(regionAssignment, container: \"[data-region='#{ regionId }']\")\n\n    @components = assigned\n\npage.publicConfiguration\n  # The `@layout` property is the equivalent to specifying @bodyTemplate\n  # but more semantic.  A `@layout` template is expected to contain DOM \n  # elements with a data attribute named `region` on it.  \n\n  layout: undefined\n  # The @regions property assigns containers ( by their type alias )\n  # to DOM elements identified as regions within a layout template.\n  #\n  # #### Example:\n  #     new Luca.components.Page\n  #       regions: \n  #         left: \"my_component\"\n  #         right: \n  #           type: \"my_other_component\"\n  #           role: \"component_role\"\n  #\n  #   This will render an instance of MyComponent to this\n  #   page's @$('[data-region-id=\"right\"]') DOM element.\n  regions: {}\n\npage.register()\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/pagination_control.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/pagination_control.coffee","type":"component_definition","starts_on_line":1,"class_name":"Luca.components.PaginationControl","header_documentation":"","type_alias":"pagination_control","css_class_identifier":"luca-pagination-control","defines_methods":{"onPageCountChange":{"defined_on_line":20,"documentation":"","arguments":[]},"limit":{"defined_on_line":23,"documentation":"","arguments":[]},"page":{"defined_on_line":26,"documentation":"","arguments":[]},"nextPage":{"defined_on_line":29,"documentation":"","arguments":[]},"previousPage":{"defined_on_line":33,"documentation":"","arguments":[]},"selectPage":{"defined_on_line":37,"documentation":"","arguments":[{"argument":"e","value":null}]},"setPage":{"defined_on_line":46,"documentation":"","arguments":[{"argument":"page","value":"1"},{"argument":"options","value":"{}"}]},"setLimit":{"defined_on_line":49,"documentation":"","arguments":[{"argument":"limit","value":"1"},{"argument":"options","value":"{}"}]},"pageButtonContainer":{"defined_on_line":52,"documentation":"","arguments":[]},"previousEnabled":{"defined_on_line":55,"documentation":"","arguments":[]},"nextEnabled":{"defined_on_line":58,"documentation":"","arguments":[]},"previousButton":{"defined_on_line":61,"documentation":"","arguments":[]},"nextButton":{"defined_on_line":64,"documentation":"","arguments":[]},"pageButtons":{"defined_on_line":67,"documentation":"","arguments":[]},"updateWithPageCount":{"defined_on_line":70,"documentation":"","arguments":[{"argument":"@pageCount","value":null},{"argument":"models","value":"[]"}]},"toggleNavigationButtons":{"defined_on_line":85,"documentation":"","arguments":[]},"selectActivePageButton":{"defined_on_line":90,"documentation":"","arguments":[]},"activePageButton":{"defined_on_line":93,"documentation":"","arguments":[]},"totalPages":{"defined_on_line":96,"documentation":"","arguments":[]},"totalItems":{"defined_on_line":99,"documentation":"","arguments":[]},"itemsPerPage":{"defined_on_line":102,"documentation":"","arguments":[{"argument":"value","value":null},{"argument":"options","value":"{}"}]}},"defines_properties":{"template":{"defined_on_line":6,"documentation":"","default":"\"components/pagination\""},"stateful":{"defined_on_line":8,"documentation":"","default":"true"},"stateChangeEvents":{"defined_on_line":10,"documentation":"","default":null},"autoBindEventHandlers":{"defined_on_line":13,"documentation":"","default":"true"},"events":{"defined_on_line":15,"documentation":"","default":null}},"source_file_contents":"paginationControl = Luca.register   \"Luca.components.PaginationControl\"\n\npaginationControl.extends           \"Luca.View\"\n\npaginationControl.defines\n  template: \"components/pagination\"\n\n  stateful: true\n\n  stateChangeEvents:\n    \"numberOfPages\" : \"onPageCountChange\"\n\n  autoBindEventHandlers: true\n\n  events:\n    \"click a[data-page-number]\" : \"selectPage\"\n    \"click a.next\"              : \"nextPage\"\n    \"click a.prev\"              : \"previousPage\"\n\n  onPageCountChange: ()->\n    @updateWithPageCount( @get('numberOfPages') )\n\n  limit: ()->\n    parseInt (@get('limit') || @collection?.length)\n\n  page: ()->\n    parseInt (@get('page') || 1)\n\n  nextPage: ()->\n    return unless @nextEnabled()\n    @set('page', @page() + 1 )\n\n  previousPage: ()->\n    return unless @previousEnabled()\n    @set('page', @page() - 1 )\n\n  selectPage: (e)->\n    me = my = @$( e.target )\n    me = my = my.closest('a.page') unless me.is('a.page')\n\n    my.siblings().removeClass('is-selected')\n    me.addClass('is-selected')\n\n    @setPage( my.data('page-number') )\n\n  setPage: (page=1,options={})->\n    @set('page', page, options)\n\n  setLimit: (limit=1,options={})->\n    @set('limit', limit, options)\n\n  pageButtonContainer: ()->\n    @$ '.group'\n\n  previousEnabled: ()->\n    @page() > 1\n\n  nextEnabled: ()->\n    @page() < @totalPages()\n\n  previousButton: ()->\n    @$ 'a.page.prev'\n\n  nextButton: ()->\n    @$ 'a.page.next'\n\n  pageButtons: ()->\n    @$ 'a[data-page-number]', @pageButtonContainer()\n\n  updateWithPageCount: (@pageCount, models=[])->\n    modelCount = models.length\n\n    @pageButtonContainer().empty()\n\n    _( @pageCount ).times (index)=>\n      page = index + 1\n      button = @make(\"a\",\"data-page-number\":page, class:\"page\", page )\n      @pageButtonContainer().append(button)\n\n    @toggleNavigationButtons()\n    @selectActivePageButton()\n\n    @\n\n  toggleNavigationButtons: ()->\n    @$('a.next, a.prev').addClass('disabled')\n    @nextButton().removeClass('disabled') if @nextEnabled()\n    @previousButton().removeClass('disabled') if @previousEnabled()\n\n  selectActivePageButton: ()->\n    @activePageButton().addClass('is-selected')\n\n  activePageButton: ()->\n    @pageButtons().filter(\"[data-page-number='#{ @page() }']\")\n\n  totalPages: ()->\n    @pageCount\n\n  totalItems: ()->\n    parseInt @collection?.length || 0\n\n  itemsPerPage: (value, options={})->\n    @set(\"limit\", value, options) if value?\n    parseInt @get(\"limit\")\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/router.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/router.coffee","type":"component_definition","starts_on_line":2,"class_name":"Luca.Router","header_documentation":"<p>#_.def(&quot;Luca.Router&quot;).extends(&quot;Backbone.Router&quot;).with</p>\n","type_alias":"router","css_class_identifier":"luca-router","defines_methods":{"initialize":{"defined_on_line":8,"documentation":"","arguments":[{"argument":"@options","value":null}]},"navigate":{"defined_on_line":26,"documentation":"<p>Intercept calls to Backbone.Router.navigate so that we can at least\nbuild a path from the route, even if we don&#39;t trigger the route handler</p>\n","arguments":[{"argument":"route","value":null},{"argument":"triggerRoute","value":"false"}]},"buildPathFrom":{"defined_on_line":34,"documentation":"<p>given a url fragment, construct an argument chain similar to what would be\nemitted from a normal route:#{ name } event that gets triggered\nwhen a route is actually fired.  This is used to trap route changes that happen\nthrough calls to @navigate()</p>\n","arguments":[{"argument":"matchedRoute","value":null}]}},"defines_properties":{"routes":{"defined_on_line":5,"documentation":"","default":null}},"source_file_contents":"#_.def(\"Luca.Router\").extends(\"Backbone.Router\").with\nrouter = Luca.register  \"Luca.Router\"\nrouter.extends          \"Backbone.Router\"\nrouter.defines\n  routes:\n    \"\" : \"default\"\n\n  initialize: (@options)->\n    _.extend @, @options\n\n    @routeHandlers = _( @routes ).values()\n\n    # when a route handler is fired, the route:route_name event is triggered by the router\n    # unfortunately this doesn't apply to calls to @navigate() so we override Backbone.Router.navigate\n    # and trigger an event separately.\n    _( @routeHandlers ).each (route_id) =>\n      @bind \"route:#{ route_id }\", ()=>\n        @trigger.apply @, [\"change:navigation\", route_id  ].concat( _( arguments ).flatten() )\n\n    Backbone.Router.initialize?.apply(@, arguments)\n\n  #### Router Functions\n\n  # Intercept calls to Backbone.Router.navigate so that we can at least\n  # build a path from the route, even if we don't trigger the route handler\n  navigate: (route, triggerRoute=false)->\n    Backbone.Router.prototype.navigate.apply @, arguments\n    @buildPathFrom( Backbone.history.getFragment() )\n\n  # given a url fragment, construct an argument chain similar to what would be\n  # emitted from a normal route:#{ name } event that gets triggered\n  # when a route is actually fired.  This is used to trap route changes that happen\n  # through calls to @navigate()\n  buildPathFrom: (matchedRoute)->\n    _(@routes).each (route_id, route)=>\n      regex = @_routeToRegExp(route)\n      if regex.test(matchedRoute)\n        args = @_extractParameters(regex, matchedRoute)\n        @trigger.apply @, [\"change:navigation\", route_id].concat( args )\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/simple_collection_view.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/simple_collection_view.coffee","type":"component_definition","starts_on_line":3,"class_name":"Luca.components.SimpleCollectionView","header_documentation":"<p>The SimpleCollectionView class is a CollectionView without any of the\nbells and whistles ( filtering, pagination, sorting, etc )</p>\n","type_alias":"simple_collection_view","css_class_identifier":"luca-simple-collection-view","defines_methods":{},"defines_properties":{"filterable":{"defined_on_line":7,"documentation":"","default":"false"},"paginatable":{"defined_on_line":8,"documentation":"","default":"false"},"sortable":{"defined_on_line":9,"documentation":"","default":"false"},"loadMask":{"defined_on_line":10,"documentation":"","default":"false"}},"source_file_contents":"# The SimpleCollectionView class is a CollectionView without any of the\n# bells and whistles ( filtering, pagination, sorting, etc )\nsimple = Luca.register    \"Luca.components.SimpleCollectionView\"\nsimple.extends            \"Luca.CollectionView\"\n\nsimple.defines\n  filterable: false\n  paginatable: false\n  sortable: false\n  loadMask: false"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/table_view.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/table_view.coffee","type":"component_definition","starts_on_line":1,"class_name":"Luca.components.TableView","header_documentation":"","type_alias":"table_view","css_class_identifier":"luca-table-view","defines_methods":{"lastColumn":{"defined_on_line":21,"documentation":"","arguments":[]},"eachColumn":{"defined_on_line":24,"documentation":"","arguments":[{"argument":"fn","value":null},{"argument":"scope","value":"@"}]},"itemRenderer":{"defined_on_line":29,"documentation":"","arguments":[{"argument":"item","value":null},{"argument":"model","value":null}]},"initialize":{"defined_on_line":32,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"rowRenderer":{"defined_on_line":80,"documentation":"","arguments":[{"argument":"item","value":null},{"argument":"model","value":null},{"argument":"index","value":null}]}},"defines_properties":{"widths":{"defined_on_line":5,"documentation":"","default":"[]"},"columns":{"defined_on_line":6,"documentation":"","default":"[]"},"emptyText":{"defined_on_line":7,"documentation":"","default":"\"There are no results to display\""},"additionalClassNames":{"defined_on_line":10,"documentation":"","default":"\"table\""},"tagName":{"defined_on_line":11,"documentation":"","default":"\"table\""},"bodyTemplate":{"defined_on_line":12,"documentation":"","default":"\"table_view\""},"bodyTagName":{"defined_on_line":13,"documentation":"","default":"\"tbody\""},"bodyClassName":{"defined_on_line":14,"documentation":"","default":"\"table-body\""},"stateful":{"defined_on_line":15,"documentation":"","default":"true"},"itemTagName":{"defined_on_line":16,"documentation":"","default":"\"tr\""},"observeChanges":{"defined_on_line":17,"documentation":"","default":"true"}},"source_file_contents":"tableView = Luca.register     \"Luca.components.TableView\"\ntableView.extends             \"Luca.CollectionView\"\n\ntableView.publicConfiguration\n  widths: []\n  columns:[]\n  emptyText: \"There are no results to display\"\n\ntableView.privateConfiguration\n  additionalClassNames: \"table\"\n  tagName: \"table\"\n  bodyTemplate: \"table_view\"\n  bodyTagName: \"tbody\"\n  bodyClassName: \"table-body\"\n  stateful: true\n  itemTagName: \"tr\"\n  observeChanges: true\n\ntableView.privateMethods\n\n  lastColumn: ()->\n    @columns[ @columns.length - 1 ]\n\n  eachColumn: (fn, scope=@)->\n    index = 0\n    for col in @columns  \n      fn.call(scope, col, index++, @)\n\n  itemRenderer: (item, model)->\n    Luca.components.TableView.rowRenderer.call(@, item, model)\n\n  initialize: (@options={})->\n    Luca.components.CollectionView::initialize.apply(@, arguments)\n\n    index = 0\n    @columns = for column in @columns\n      if width = @widths[ index ]\n        column.width = width\n\n      if _.isString(column)\n        column = reader: column\n\n      if !column.header?\n        column.header = _.str.titleize(_.str.humanize(column.reader))\n\n      index++\n      column\n\n    @defer ()=> \n      Luca.components.TableView.renderHeader.call(@, @columns, @$('thead') )\n    .until(\"after:render\")\n\ntableView.classMethods\n  renderHeader : (columns, targetElement)->\n    index = 0\n\n    @$( targetElement ).append(\"<tr></tr>\")\n\n    for column in columns\n      attrs = \"data-col-index\": index++\n\n      if column.sortable\n        attrs.class = \"sortable-toggle\"\n        attrs[\"data-sortable-sort-by\"] = column.sortBy || column.sortable\n        attrs[\"data-sortable-order\"] = column.order\n\n      content = column.header \n      content = \"<a class='link'>#{ column.header }</a>\" if column.sortable\n\n      @$(targetElement).find('tr').append( Luca.View::make \"th\", attrs, content )\n\n\n    index = 0\n\n    for column in columns when column.width?\n      th = @$(\"th[data-col-index='#{ index++ }']\",targetElement)\n      th.css('width', column.width)\n\n\n  rowRenderer: (item, model, index)->\n    colIndex = 0\n    for columnConfig in @columns\n      Luca.components.TableView.renderColumn.call(@, columnConfig, item, model, colIndex++) \n\n  renderColumn : (column, item, model, index)->\n    cellValue = model.read( column.reader )\n\n    if _.isFunction( column.renderer )\n      cellValue = column.renderer.call @, cellValue, model, column \n\n    Luca.View::make(\"td\", {\"data-col-index\":index}, cellValue)\n\ntableView.register()"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/table_view_scrollable.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/table_view_scrollable.coffee","type":"component_definition","starts_on_line":1,"class_name":"Luca.components.ScrollableTable","header_documentation":"","type_alias":"scrollable_table","css_class_identifier":"luca-scrollable-table","defines_methods":{"$scrollableWrapperEl":{"defined_on_line":11,"documentation":"","arguments":[]},"setMaxHeight":{"defined_on_line":14,"documentation":"","arguments":[]},"afterRender":{"defined_on_line":18,"documentation":"","arguments":[]}},"defines_properties":{"maxHeight":{"defined_on_line":8,"documentation":"","default":"undefined"},"version":{"defined_on_line":23,"documentation":"","default":"1"}},"source_file_contents":"scrollable = Luca.register      'Luca.components.ScrollableTable'\n\nscrollable.extends              'Luca.components.TableView'\n\nscrollable.replaces             'Luca.components.GridView'\n\nscrollable.publicConfiguration\n  maxHeight: undefined\n\nscrollable.privateMethods\n  $scrollableWrapperEl: ()->\n    @$el.parent('.scrollable-wrapper')\n\n  setMaxHeight: ()->\n    parent = @$scrollableWrapperEl()\n    parent.css('overflow':'auto', 'max-height': @maxHeight)\n\n  afterRender: ()->\n    @$wrap 'scrollable-wrapper'\n    @setMaxHeight()\n\nscrollable.defines\n  version: 1"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/card_view.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/card_view.coffee","type":"component_definition","starts_on_line":21,"class_name":"Luca.containers.CardView","header_documentation":"<p>The CardView is a type of Container which has many sub-views\nwhich are only going to be visible one at a time.  A CardView\nallows you to @activate() its cards, navigate through them using\n@next(), @previous(), @cycle()\nExample:\n  cardView = new Luca.containers.CardView\n    cards:[\n      getter: &quot;getCardOne&quot;\n      type: &quot;my<em>component&quot;\n      name: &quot;one&quot;\n    ,\n      getter: &quot;getCardTwo&quot;\n      type: &quot;my</em>component&quot;\n      name: &quot;two&quot;\n    ]\n  cardView.activeComponent().name # =&gt; &quot;one&quot;\n  cardView.activate(&#39;two&#39;)\n  cardView.activeComponent().name # =&gt; &quot;two&quot;</p>\n","type_alias":"card_view","css_class_identifier":"luca-containers-card-view","defines_methods":{"atFirst":{"defined_on_line":52,"documentation":"<p>Returns true if at the first</p>\n","arguments":[]},"atLast":{"defined_on_line":56,"documentation":"<p>Returns true if we&#39;re at the last card</p>\n","arguments":[]},"next":{"defined_on_line":60,"documentation":"<p>Activate the next component.  If at the last, do nothing.</p>\n","arguments":[]},"previous":{"defined_on_line":65,"documentation":"<p>Activate the previous component.  If at the first, do nothing.</p>\n","arguments":[]},"cycle":{"defined_on_line":71,"documentation":"<p>Activates the next component after the current one.\nIf at the last component, it will activate the first.</p>\n","arguments":[]},"find":{"defined_on_line":76,"documentation":"<p>Find a direct component on this card by its name.</p>\n","arguments":[{"argument":"name","value":null}]},"activate":{"defined_on_line":85,"documentation":"<p>Activates the component at the specified index.  You may optionally specify\nthe name of the component you wish to activate.  You can pass false as your second\nargument, to disable the event handling that occurs when you activate a card on this container.\nIf you pass a callback function to the activate method, that callback will be executed within\nthe context of the activated component.</p>\n","arguments":[{"argument":"index","value":null},{"argument":"silent","value":"false"},{"argument":"callback","value":null}]},"initialize":{"defined_on_line":136,"documentation":"","arguments":[{"argument":"@options","value":null}]},"simulateActivationEvent":{"defined_on_line":144,"documentation":"<p>Simulates the activation event being triggered on the\nactive component that gets rendered inside of this card view.</p>\n","arguments":[]},"prepareComponents":{"defined_on_line":153,"documentation":"","arguments":[]},"activeComponentElement":{"defined_on_line":158,"documentation":"","arguments":[]},"activeComponent":{"defined_on_line":161,"documentation":"","arguments":[]},"customizeContainerEl":{"defined_on_line":164,"documentation":"","arguments":[{"argument":"containerEl","value":null},{"argument":"panel","value":null},{"argument":"panelIndex","value":null}]},"firstActivation":{"defined_on_line":174,"documentation":"<p>The first time activate event is triggered on this component\nthe @firstActivation hook is responsible for relaying that event\nto our @activeComponent() so that it knows it has been activated.</p>\n","arguments":[]}},"defines_properties":{"activeCard":{"defined_on_line":25,"documentation":"","default":"0"},"components":{"defined_on_line":26,"documentation":"","default":"[]"},"activationContext":{"defined_on_line":33,"documentation":"<p>When the activate method is called and passed a callback\nwhat context should we run that callback in?  Default is\nto call the callback in the context of the component that\nis currently being activated</p>\n","default":"\"current\""},"hooks":{"defined_on_line":39,"documentation":"<p>Will automatically call beforeCardSwitch and afterCardSwitch\nmethods if they exist on this view.  These events will be triggered\nin response to a call to @activate()</p>\n","default":"["},"componentClass":{"defined_on_line":45,"documentation":"<p>Which css class should we apply to each of the cards</p>\n","default":"'luca-ui-card'"},"generateComponentElements":{"defined_on_line":48,"documentation":"<p>Should we generate elements to append each component?</p>\n","default":"true"}},"source_file_contents":"# The CardView is a type of Container which has many sub-views\n# which are only going to be visible one at a time.  A CardView\n# allows you to @activate() its cards, navigate through them using\n# @next(), @previous(), @cycle()\n#\n# Example:\n#   cardView = new Luca.containers.CardView\n#     cards:[\n#       getter: \"getCardOne\"\n#       type: \"my_component\"\n#       name: \"one\"\n#     ,\n#       getter: \"getCardTwo\"\n#       type: \"my_component\"\n#       name: \"two\"\n#     ]\n#\n#   cardView.activeComponent().name # => \"one\"\n#   cardView.activate('two')\n#   cardView.activeComponent().name # => \"two\"\ncomponent = Luca.register       \"Luca.containers.CardView\"\ncomponent.extends               \"Luca.Container\"\n\ncomponent.publicConfiguration\n  activeCard: 0\n  components: []\n\ncomponent.classInterface\n  # When the activate method is called and passed a callback\n  # what context should we run that callback in?  Default is\n  # to call the callback in the context of the component that\n  # is currently being activated\n  activationContext: \"current\"\n\ncomponent.privateConfiguration\n  # Will automatically call beforeCardSwitch and afterCardSwitch\n  # methods if they exist on this view.  These events will be triggered\n  # in response to a call to @activate()\n  hooks:[\n    'before:card:switch',\n    'after:card:switch'\n  ]\n\n  # Which css class should we apply to each of the cards\n  componentClass: 'luca-ui-card'\n\n  # Should we generate elements to append each component?\n  generateComponentElements: true\n\ncomponent.publicMethods\n  # Returns true if at the first \n  atFirst: ()->\n    @activeCard is 0\n\n  # Returns true if we're at the last card\n  atLast: ()->\n    @activeCard is @components.length - 1\n\n  # Activate the next component.  If at the last, do nothing.\n  next: ()->\n    return if @atLast()\n    @activate( @activeCard + 1)\n\n  # Activate the previous component.  If at the first, do nothing.\n  previous: ()->   \n    return if @atFirst()\n    @activate( @activeCard - 1)\n\n  # Activates the next component after the current one.\n  # If at the last component, it will activate the first.\n  cycle: ()->\n    nextIndex = if @atLast() then 0 else @activeCard + 1\n    @activate( nextIndex )\n\n  # Find a direct component on this card by its name.\n  find: (name)-> \n    _( @components ).detect (c)-> \n      c.name is name\n\n  # Activates the component at the specified index.  You may optionally specify\n  # the name of the component you wish to activate.  You can pass false as your second\n  # argument, to disable the event handling that occurs when you activate a card on this container.\n  # If you pass a callback function to the activate method, that callback will be executed within\n  # the context of the activated component. \n  activate: (index, silent=false, callback)->\n    if _.isFunction(silent)\n      silent = false\n      callback = silent\n\n    return if index is @activeCard\n\n    previous = @activeComponent()\n\n    current = @getComponent(index)\n\n    if !current?\n      index = @indexOf(index) \n      return unless current = @getComponent(index)\n\n    unless silent is true\n      @trigger \"before:card:switch\", previous, current\n      previous?.trigger \"before:deactivation\", @, previous, current\n      current?.trigger \"before:activation\", @, previous, current\n\n      _.defer ()=>\n        @$el.data( @activeAttribute || \"active-card\", current.name)\n\n    @componentElements().hide()\n\n    unless current.previously_activated is true\n      if current.rendered is true\n        current.trigger \"first:activation\"\n      else\n        current.once \"after:render\", ()->\n          current.rendered = true\n          current.trigger(\"first:activation\")\n      current.previously_activated = true\n\n    @activeCard = index \n    @activeComponentElement().show()\n\n    unless silent is true\n      @trigger \"after:card:switch\", previous, current\n      previous?.trigger \"deactivation\", @, previous, current\n      current?.trigger \"activation\", @, previous, current\n\n    activationContext = @\n\n    if Luca.containers.CardView.activationContext is \"current\"\n      activationContext = current\n\n    if _.isFunction(callback)\n      callback.apply activationContext, [@,previous,current]\n\ncomponent.privateMethods\n  initialize: (@options)->\n    @components ||= @pages ||= @cards \n    Luca.Container::initialize.apply @,arguments\n    @setupHooks(@hooks)\n    @defer( @simulateActivationEvent, @ ).until(\"after:render\")\n\n  # Simulates the activation event being triggered on the\n  # active component that gets rendered inside of this card view. \n  simulateActivationEvent: ()->\n    c = @activeComponent()\n\n    if c? and (@visible || @$el.is(\":visible\"))\n      c?.trigger \"activation\", @, c, c \n      if !c.previously_activated\n        c.trigger \"first:activation\"\n        c.previously_activated = true\n\n  prepareComponents: ()->\n    Luca.Container::prepareComponents?.apply(@, arguments)\n    @componentElements().hide()\n    @activeComponentElement().show()\n\n  activeComponentElement: ()->\n    @componentElements().eq( @activeCard )\n\n  activeComponent: ()->\n    @getComponent( @activeCard )\n\n  customizeContainerEl: (containerEl, panel, panelIndex)->\n    containerEl.style += if panelIndex is @activeCard then \"display:block;\" else \"display:none;\"\n\n    containerEl\n\n\n\n  # The first time activate event is triggered on this component\n  # the @firstActivation hook is responsible for relaying that event\n  # to our @activeComponent() so that it knows it has been activated.\n  firstActivation: ()->\n    if activeComponent = @activeComponent()\n      activeComponent.trigger \"first:activation\", @, @activeComponent()\n\ncomponent.register()\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/container.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/container.coffee","type":"component_definition","starts_on_line":146,"class_name":"Luca.Container","header_documentation":"<p>The Luca.Container is the heart and soul of the Luca framework \nand the component driven design philosophy.  The central idea\nis that every component should be designed as an isolated unit\nwhich completely encapsulates its features.  It should not know about\nother components outside of it.</p>\n\n<p>It is the responsibility of a <code>Luca.Container</code> to define its \nchild <code>@components</code>, render them, and broker communication between them\nin response to events which occur in the user interface.<br>\nA common use case for this would be a page which has a filter form, and\na grid of search results.  The fields in the filter form are used to \nfilter the table.  Neither the form or the table know about each other, \nsince both can be used in other contexts.  A <code>Luca.Container</code> would be used\nto relay events from the form to the table, and in doing so create a higher\nlevel component which can be extended and re-used. </p>\n\n<h4>Using a container to combine a Filter View and Results Table</h4>\n\n<pre><code>    form = Luca.register    &quot;App.views.FilterForm&quot;\n    form.extends            &quot;Luca.components.FormView&quot;\n    form.contains\n      type:   &quot;text&quot;\n      label:  &quot;Filter by&quot;\n      name:   &quot;filter_text&quot;\n    ,\n      type:   &quot;button&quot;\n      className: &quot;filter&quot;\n      value:  &quot;Filter&quot;          \n    form.defines\n      toolbar: false \n</code></pre>\n\n<p>Elsewhere, we have a table that lists records in a collection:</p>\n\n<pre><code>    table = Luca.register     &quot;App.views.ResultsTable&quot;\n    table.extends             &quot;Luca.components.TableView&quot;\n    table.defines \n      striped: true\n      collection: &quot;components&quot;\n      columns:[\n        header: &quot;Component Class&quot;\n        reader: &quot;class_name&quot;\n      ,\n        header: &quot;Component Type Alias&quot;\n        reader: &quot;type_alias&quot;\n      ]\n</code></pre>\n\n<p>We can join these two components together by declaring their relationship\nin a <code>Luca.Container</code>.  Remember the components we defined above are just\nprototypes.  We can override specific instance configuration and properties \nin our container.</p>\n\n<h4>Container Example</h4>\n\n<pre><code>    container = Luca.register     &quot;App.views.ComponentFinder&quot;\n    container.extends             &quot;Luca.Container&quot;\n\n  # This is the same as defining a components property on the component.\n  # The type alias is derived from the name of the component.  It is \n  # a short hand way of referencing a component you might reuse a lot.\n  container.contains\n    type: &quot;filter_form&quot;\n    role: &quot;filter&quot;\n  ,\n    type: &quot;results_table&quot;\n    # change the prototype&#39;s default \n    striped: false\n    role: &quot;results&quot;\n    filterable: true\n  # A Container will generally define some component event bindings\n  # and handler methods to handle the communication between its sub\n  # components.  By default a container is able to access events\n  # from all of its descendants in the hierarchy. \n  container.defines\n    # These will be applied to each of our components.\n    defaults:\n      attributes:\n        &quot;data-attribute&quot;: &quot;whatever&quot;\n    componentEvents:\n      # Any time any of our child components emit\n      # the on:change event, pass it to the filterTable method\n      &quot;* on:change&quot; : &quot;filterTable&quot;\n    # Communicates between the filter and the table&#39;s\n    # underlying collection.  NOtice the use of the @role\n    # property.  It automatically creates getter helpers for us.\n    filterTable: ()-&gt;\n      filter = @getFilter()\n      results = @getResults()\n      # filter.getValues() is a hash of each field and its value\n      results.applyFilter( filter.getValues() )\n</code></pre>\n\n<h3>DOM Layout Configuration</h3>\n\n<p>Another responsibility of the container is to structurally layout its\nchild components in the DOM.  There are a number of different \noptions available depending on how you need to do this.  By default,\na <code>Luca.Container</code> will simply append the @$el of all of its views\nto its own.\nThe <code>Luca.components.Controller</code> is a container which hides every page\nbut the active page.  Similarly, there is the <code>Luca.containers.TabView</code>\nwhich does the same thing, but renders a tab selector menu for you.  You\ncan create any type of interface you want using containers. \nTo make this easy for you, you can do a few different things:</p>\n\n<h4>Use the Twitter Bootstrap Fluid Grid</h4>\n\n<pre><code>    container = Luca.register &quot;App.views.ColumnLayout&quot; \n    container.extends         &quot;App.views.ComponentFinder&quot;\n    container.contains\n      span: 4\n      type: &quot;filter_form&quot;\n      role: &quot;filter&quot;\n    ,\n      span: 8\n      type: &quot;results_table&quot;\n      role: &quot;results&quot;\n    container.defines\n      rowFluid: true\n</code></pre>\n\n<h4>Using a layout template with CSS Selectors</h4>\n\n<p>If you find yourself needing a container view with a complicated\nvisual layout, you can provide your own DOM template as a <code>@bodyTemplate</code>\nand assign each child view in <code>@components</code> to its own specific CSS selector.\n        ... \n        container.contains\n          role: &quot;filter&quot;\n          container: &quot;#filter-wrapper-dom-selector&quot;\n        ,\n          role: &quot;results&quot;\n          container: &quot;#results-wrapper-dom-selector&quot;\n        ...\n        container.defines\n          # assumes the template will provide the CSS selectors used above \n          bodyTemplate: &quot;layouts/custom_template&quot;</p>\n","type_alias":"container","css_class_identifier":"luca-container","defines_methods":{"initialize":{"defined_on_line":248,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"remove":{"defined_on_line":268,"documentation":"<p>Removing a container will call remove on all of the nested components as well.</p>\n","arguments":[]},"beforeRender":{"defined_on_line":273,"documentation":"","arguments":[]},"customizeContainerEl":{"defined_on_line":282,"documentation":"<p>Components which inherit from Luca.Container can implement\ntheir own versions of this method, if they need to apply any sort\nof additional styling / configuration for the DOM elements that\nare created to wrap each container.</p>\n","arguments":[{"argument":"containerEl","value":null},{"argument":"panel","value":null},{"argument":"panelIndex","value":null}]},"prepareLayout":{"defined_on_line":285,"documentation":"","arguments":[]},"prepareComponents":{"defined_on_line":308,"documentation":"","arguments":[]},"createComponents":{"defined_on_line":351,"documentation":"<p>create components is responsible for turning the JSON syntax of the\ncontainer&#39;s definition into live objects against a given Luca Component\ntype.</p>\n\n<p>In addition to this, a container builds an index of the components\nwhich belong to it, so that they can easily be looked up by name</p>\n","arguments":[]},"renderComponents":{"defined_on_line":414,"documentation":"<p>Trigger the Rendering Pipeline process on all of the nested components</p>\n","arguments":[{"argument":"@debugMode","value":"\"\""}]},"firstActivation":{"defined_on_line":458,"documentation":"<p>When a container is first activated is a good time to perform\noperations which are not needed unless that component becomes\nvisible.  This first activation event should be relayed to all\nof the nested components.  Components which hide / display\nother components, such as a CardView or TabContainer\nwill trigger first:activation on the components as they become\ndisplayed.</p>\n","arguments":[]},"registerComponentEvents":{"defined_on_line":467,"documentation":"","arguments":[{"argument":"eventList","value":null},{"argument":"direction","value":"\"on\""}]},"_":{"defined_on_line":490,"documentation":"<p>Returns an underscore.js object that wraps the components array</p>\n","arguments":[{"argument":")-> _( @components","value":null}]},"pluck":{"defined_on_line":493,"documentation":"<p>Return the value of attribute of each component</p>\n","arguments":[{"argument":"attribute","value":null}]},"invoke":{"defined_on_line":497,"documentation":"<p>Invoke the passed method name on each component</p>\n","arguments":[{"argument":"method","value":null}]},"select":{"defined_on_line":501,"documentation":"<p>Select any component for which the passed iterator returns true</p>\n","arguments":[{"argument":"iterator","value":null}]},"detect":{"defined_on_line":505,"documentation":"<p>Find the first matching component for which the passed iterator returns true</p>\n","arguments":[{"argument":"iterator","value":null}]},"reject":{"defined_on_line":509,"documentation":"<p>Return a list of components without the components for which the passed iterator returns true</p>\n","arguments":[{"argument":"iterator","value":null}]},"map":{"defined_on_line":513,"documentation":"<p>Run the passed iterator over each component and return the result in an array</p>\n","arguments":[{"argument":"fn","value":null}]},"subContainers":{"defined_on_line":517,"documentation":"<p>Returns a list of nested components which are also containers</p>\n","arguments":[]},"roles":{"defined_on_line":521,"documentation":"","arguments":[]},"allChildren":{"defined_on_line":524,"documentation":"","arguments":[]},"find":{"defined_on_line":533,"documentation":"<p>Find a direct component on this card by its name.</p>\n","arguments":[{"argument":"name","value":null}]},"findComponentForEventBinding":{"defined_on_line":537,"documentation":"","arguments":[{"argument":"nameRoleOrGetter","value":null},{"argument":"deep","value":"true"}]},"findComponentByGetter":{"defined_on_line":540,"documentation":"","arguments":[{"argument":"getter","value":null},{"argument":"deep","value":"false"}]},"findComponentByRole":{"defined_on_line":544,"documentation":"","arguments":[{"argument":"role","value":null},{"argument":"deep","value":"false"}]},"findComponentByType":{"defined_on_line":548,"documentation":"","arguments":[{"argument":"desired","value":null},{"argument":"deep","value":"false"}]},"findComponentByName":{"defined_on_line":552,"documentation":"","arguments":[{"argument":"name","value":null},{"argument":"deep","value":"false"}]},"findComponentById":{"defined_on_line":556,"documentation":"","arguments":[{"argument":"id","value":null},{"argument":"deep","value":"false"}]},"findComponent":{"defined_on_line":559,"documentation":"","arguments":[{"argument":"needle","value":null},{"argument":"haystack","value":"\"name\""},{"argument":"deep","value":"false"}]},"each":{"defined_on_line":573,"documentation":"","arguments":[{"argument":"fn","value":null}]},"eachComponent":{"defined_on_line":579,"documentation":"<p>run a function for each component in this container\nand any nested containers in those components, recursively\npass false as the second argument to skip the deep recursion</p>\n","arguments":[{"argument":"fn","value":null},{"argument":"deep","value":"true"}]},"indexOfComponentName":{"defined_on_line":584,"documentation":"","arguments":[{"argument":"name","value":null}]},"indexOf":{"defined_on_line":588,"documentation":"","arguments":[{"argument":"nameOrComponent","value":null}]},"activeComponent":{"defined_on_line":595,"documentation":"","arguments":[]},"componentElements":{"defined_on_line":599,"documentation":"","arguments":[]},"getComponent":{"defined_on_line":602,"documentation":"","arguments":[{"argument":"needle","value":null}]},"isRootComponent":{"defined_on_line":605,"documentation":"","arguments":[]},"getRootComponent":{"defined_on_line":608,"documentation":"","arguments":[]},"selectByAttribute":{"defined_on_line":612,"documentation":"","arguments":[{"argument":"attribute","value":null},{"argument":"value","value":"undefined"},{"argument":"deep","value":"false"}]},"at":{"defined_on_line":704,"documentation":"","arguments":[{"argument":"index","value":null}]}},"defines_properties":{"components":{"defined_on_line":177,"documentation":"<p>@components should contain a list of object configurations for child view(s)\nof this container.  The values specified in the configuration object will override the\nvalues defined as properties and methods on your view prototypes.</p>\n\n<p>There are special properties you can define in your components configuration items\nthat will effect the container:</p>\n\n<ul>\n<li><p>role:       will create a camelized getter for you on the container.  e.g. when role is <code>my_custom_role</code>,\nthe container will have a method <code>getMyCustomRole()</code> that returns that child view.</p></li>\n<li><p>name:       a name for the child view.  this allows you to access the component by name using\nthe find() method on the container.</p></li>\n<li><p>type:       a type alias from the component registry.  type alias are underscore&#39;d strings\nmatching the component class name.  e.g. App.views.MyCustomView type alias is <code>my_custom_view</code></p></li>\n<li><p>component:  a convenience property for setting type, role, and name to be equal.</p></li>\n</ul>\n","default":"[]"},"defaults":{"defined_on_line":182,"documentation":"<p>The <code>@defaults</code> property is an object of configuration parameters which will be set\non each child component.  Values explicitly defines in the components config will\ntake precedence over the default.</p>\n","default":"{}"},"extensions":{"defined_on_line":194,"documentation":"<p>The <code>@extensions</code> property is useful when you are subclassing a container view\nwhich already defines an array of components, and you want to specifically override\nproperties and settings on the children. The <code>@extensions</code> property expects either:</p>\n\n<p>An object whose keys match the names of the <code>@role</code> property defined on the child components.\nThe value should be an object which will override any values defined on the parent class.</p>\n\n<p>or:</p>\n\n<p>An array of objects in the same array position / index as the target child view you wish to extend.</p>\n","default":"{}"},"componentEvents":{"defined_on_line":215,"documentation":"<p>@componentEvents provides declarative syntax for responding to events on\nthe components in this container.  the format of the syntax is very similar\nto the other event binding helpers:</p>\n\n<p><code>component_accessor component:trigger</code></p>\n\n<p>where component_accessor is either the name of the component, or a the role\nproperty on the component, component:trigger is the event that component fires.\nhandler is a method on the container which will respond to the child component event.\n<pre>\nmyContainer = new Luca.Container\ncomponentEvents:\n&quot;name component:trigger&quot;    : &quot;handler&quot;\n&quot;role component:trigger&quot;    : &quot;handler&quot;\n&quot;getter component:trigger&quot;  : &quot;handler&quot;\ncomponents:[\nname: &quot;name&quot;\n]\n</pre></p>\n","default":"{}"},"className":{"defined_on_line":218,"documentation":"","default":"'luca-ui-container'"},"isContainer":{"defined_on_line":222,"documentation":"<p>This is a convenience attribute for identifying\nviews which are luca containers</p>\n","default":"true"},"generateComponentElements":{"defined_on_line":228,"documentation":"<p>if set to true, we will generate DOM elements\nto wrap each of our components in.  This should\ngenerally be avoided IMO as it pollutes the DOM,\nbut is currently necessary for some container implementations</p>\n","default":"false"},"emptyContainerElements":{"defined_on_line":233,"documentation":"<p>if set to true, the DOM elements which wrap\nour components will be emptied prior to rendering\nthe component inside this container.</p>\n","default":"false"},"componentTag":{"defined_on_line":237,"documentation":"<p>if @generateComponentElements is true, which tag should this\ncontainer wrap our components in?</p>\n","default":"'div'"},"componentClass":{"defined_on_line":241,"documentation":"<p>if @generateComponentElements is true, which class should we\napply to the container elements which wrap our components?</p>\n","default":"'luca-ui-panel'"},"rendered":{"defined_on_line":243,"documentation":"","default":"false"},"@trigger \"before":{"defined_on_line":640,"documentation":"","default":"layout\", @"},"@trigger \"after":{"defined_on_line":642,"documentation":"","default":"layout\", @"},"style_declarations.push \"height":{"defined_on_line":647,"documentation":"","default":"#{ (if _.isNumber(panel.height) then panel.height + 'px' else panel.height ) }\" if panel.height?"},"style_declarations.push \"width":{"defined_on_line":648,"documentation":"","default":"#{ (if _.isNumber(panel.width) then panel.width + 'px' else panel.width ) }\" if panel.width?"},"style_declarations.push \"float":{"defined_on_line":649,"documentation":"","default":"#{ panel.float }\" if panel.float"}},"source_file_contents":"# The Luca.Container is the heart and soul of the Luca framework \n# and the component driven design philosophy.  The central idea\n# is that every component should be designed as an isolated unit\n# which completely encapsulates its features.  It should not know about\n# other components outside of it.\n# \n# It is the responsibility of a `Luca.Container` to define its \n# child `@components`, render them, and broker communication between them\n# in response to events which occur in the user interface.  \n#\n# A common use case for this would be a page which has a filter form, and\n# a grid of search results.  The fields in the filter form are used to \n# filter the table.  Neither the form or the table know about each other, \n# since both can be used in other contexts.  A `Luca.Container` would be used\n# to relay events from the form to the table, and in doing so create a higher\n# level component which can be extended and re-used. \n#\n# #### Using a container to combine a Filter View and Results Table \n#\n#         form = Luca.register    \"App.views.FilterForm\"\n#         form.extends            \"Luca.components.FormView\"\n#\n#         form.contains\n#           type:   \"text\"\n#           label:  \"Filter by\"\n#           name:   \"filter_text\"\n#         ,\n#           type:   \"button\"\n#           className: \"filter\"\n#           value:  \"Filter\"          \n#\n#\n#         form.defines\n#           toolbar: false \n# \n# Elsewhere, we have a table that lists records in a collection:\n#         \n#         table = Luca.register     \"App.views.ResultsTable\"\n#         table.extends             \"Luca.components.TableView\"\n#         table.defines \n#           striped: true\n#           collection: \"components\"\n#           columns:[\n#             header: \"Component Class\"\n#             reader: \"class_name\"\n#           ,\n#             header: \"Component Type Alias\"\n#             reader: \"type_alias\"\n#           ]\n#\n# We can join these two components together by declaring their relationship\n# in a `Luca.Container`.  Remember the components we defined above are just\n# prototypes.  We can override specific instance configuration and properties \n# in our container.\n#\n# #### Container Example\n#\n#         container = Luca.register     \"App.views.ComponentFinder\"\n#         container.extends             \"Luca.Container\"\n#       \n#       # This is the same as defining a components property on the component.\n#       # The type alias is derived from the name of the component.  It is \n#       # a short hand way of referencing a component you might reuse a lot.\n#       container.contains\n#         type: \"filter_form\"\n#         role: \"filter\"\n#       ,\n#         type: \"results_table\"\n#         # change the prototype's default \n#         striped: false\n#         role: \"results\"\n#         filterable: true\n#\n#       # A Container will generally define some component event bindings\n#       # and handler methods to handle the communication between its sub\n#       # components.  By default a container is able to access events\n#       # from all of its descendants in the hierarchy. \n#       container.defines\n#         # These will be applied to each of our components.\n#         defaults:\n#           attributes:\n#             \"data-attribute\": \"whatever\"\n#\n#         componentEvents:\n#           # Any time any of our child components emit\n#           # the on:change event, pass it to the filterTable method\n#           \"* on:change\" : \"filterTable\"\n#\n#         # Communicates between the filter and the table's\n#         # underlying collection.  NOtice the use of the @role\n#         # property.  It automatically creates getter helpers for us.\n#         filterTable: ()->\n#           filter = @getFilter()\n#           results = @getResults()\n#           # filter.getValues() is a hash of each field and its value\n#           results.applyFilter( filter.getValues() )\n#         \n# ### DOM Layout Configuration\n#\n# Another responsibility of the container is to structurally layout its\n# child components in the DOM.  There are a number of different \n# options available depending on how you need to do this.  By default,\n# a `Luca.Container` will simply append the @$el of all of its views\n# to its own.\n#\n# The `Luca.components.Controller` is a container which hides every page\n# but the active page.  Similarly, there is the `Luca.containers.TabView`\n# which does the same thing, but renders a tab selector menu for you.  You\n# can create any type of interface you want using containers. \n#\n# To make this easy for you, you can do a few different things:\n#\n# #### Use the Twitter Bootstrap Fluid Grid\n#\n#         container = Luca.register \"App.views.ColumnLayout\" \n#         container.extends         \"App.views.ComponentFinder\"\n#\n#         container.contains\n#           span: 4\n#           type: \"filter_form\"\n#           role: \"filter\"\n#         ,\n#           span: 8\n#           type: \"results_table\"\n#           role: \"results\"\n#\n#         container.defines\n#           rowFluid: true\n#\n# #### Using a layout template with CSS Selectors\n# If you find yourself needing a container view with a complicated\n# visual layout, you can provide your own DOM template as a `@bodyTemplate`\n# and assign each child view in `@components` to its own specific CSS selector.\n#\n#         ... \n#         container.contains\n#           role: \"filter\"\n#           container: \"#filter-wrapper-dom-selector\"\n#         ,\n#           role: \"results\"\n#           container: \"#results-wrapper-dom-selector\"\n#         ...\n#         container.defines\n#           # assumes the template will provide the CSS selectors used above \n#           bodyTemplate: \"layouts/custom_template\"\ncontainer = Luca.register         \"Luca.Container\"\n\ncontainer.extends                 \"Luca.Panel\"\n\ncontainer.triggers                \"before:components\",\n                                  \"before:render:components\",\n                                  \"before:layout\",\n                                  \"after:components\",\n                                  \"after:layout\",\n                                  \"first:activation\"\n\ncontainer.replaces                \"Luca.Container\"\n\ncontainer.publicConfiguration\n  # @components should contain a list of object configurations for child view(s)\n  # of this container.  The values specified in the configuration object will override the \n  # values defined as properties and methods on your view prototypes.\n  #\n  # There are special properties you can define in your components configuration items \n  # that will effect the container:\n  #\n  # - role:       will create a camelized getter for you on the container.  e.g. when role is `my_custom_role`, \n  #               the container will have a method `getMyCustomRole()` that returns that child view.\n  #\n  # - name:       a name for the child view.  this allows you to access the component by name using \n  #               the find() method on the container.\n  #\n  # - type:       a type alias from the component registry.  type alias are underscore'd strings \n  #               matching the component class name.  e.g. App.views.MyCustomView type alias is `my_custom_view`\n  #\n  # - component:  a convenience property for setting type, role, and name to be equal. \n  components:[]\n\n  # The `@defaults` property is an object of configuration parameters which will be set\n  # on each child component.  Values explicitly defines in the components config will \n  # take precedence over the default.\n  defaults: {}\n\n  # The `@extensions` property is useful when you are subclassing a container view\n  # which already defines an array of components, and you want to specifically override\n  # properties and settings on the children. The `@extensions` property expects either: \n  #\n  # An object whose keys match the names of the `@role` property defined on the child components.\n  # The value should be an object which will override any values defined on the parent class.\n  #\n  # or:\n  # \n  # An array of objects in the same array position / index as the target child view you wish to extend.\n  extensions: {}\n\n  # @componentEvents provides declarative syntax for responding to events on\n  # the components in this container.  the format of the syntax is very similar\n  # to the other event binding helpers:\n  #\n  # `component_accessor component:trigger`\n  #\n  # where component_accessor is either the name of the component, or a the role \n  # property on the component, component:trigger is the event that component fires.\n  # handler is a method on the container which will respond to the child component event.\n  # <pre>\n  #       myContainer = new Luca.Container\n  #         componentEvents:\n  #           \"name component:trigger\"    : \"handler\"\n  #           \"role component:trigger\"    : \"handler\"\n  #           \"getter component:trigger\"  : \"handler\"\n  #         components:[\n  #           name: \"name\"\n  #         ]\n  # </pre>\n  componentEvents: {}\n\ncontainer.privateConfiguration\n  className: 'luca-ui-container'\n\n  # This is a convenience attribute for identifying\n  # views which are luca containers\n  isContainer: true\n\n  # if set to true, we will generate DOM elements\n  # to wrap each of our components in.  This should \n  # generally be avoided IMO as it pollutes the DOM, \n  # but is currently necessary for some container implementations\n  generateComponentElements: false\n\n  # if set to true, the DOM elements which wrap\n  # our components will be emptied prior to rendering\n  # the component inside this container.\n  emptyContainerElements: false\n\n  # if @generateComponentElements is true, which tag should this \n  # container wrap our components in?\n  componentTag: 'div'\n\n  # if @generateComponentElements is true, which class should we \n  # apply to the container elements which wrap our components?\n  componentClass: 'luca-ui-panel'\n\n  rendered: false\n\n\n\ncontainer.privateMethods\n  initialize: (@options={})->\n    _.extend @, @options\n\n    # aliases for the components property\n    @components ||= @fields ||= @pages ||= @cards ||= @views\n    \n    # accept components as an array of strings representing\n    # the luca component type\n    for component in @components when _.isString(component)\n      component = (type: component, role: component, name: component)\n\n    _.bindAll(@, \"beforeRender\")\n\n    @setupHooks( Luca.Container::hooks )\n\n    validateContainerConfiguration(@)\n\n    Luca.View::initialize.apply @, arguments\n\n  # Removing a container will call remove on all of the nested components as well.\n  remove: ()->\n    Luca.View::remove.apply(@, arguments)\n    @eachComponent (component)->\n      component.remove?()\n      \n  beforeRender: ()->\n    doLayout.call(@)\n    doComponents.call(@)\n    Luca.Panel::beforeRender?.apply(@, arguments)\n\n  # Components which inherit from Luca.Container can implement\n  # their own versions of this method, if they need to apply any sort\n  # of additional styling / configuration for the DOM elements that\n  # are created to wrap each container.\n  customizeContainerEl: (containerEl, panel, panelIndex)->\n    containerEl\n\n  prepareLayout: ()->\n    container = @\n    @componentContainers = _( @components ).map (component, index)->\n      applyDOMConfig.call(container, component, index)\n\n    componentsWithClassBasedAssignment = @_().select (component)->\n      _.isString(component.container) and component.container?.match(/^\\./) and container.$( component.container ).length > 0\n\n    # TEMP / HACK / Workaround\n    #\n    # Containers with components assigned to .class-based-containers\n    # seem to get double rendered in the renderComponents() method.\n    #\n    # So here I am uniquely identifying the containers in a way that is not possible\n    # in the templates ( since we want to be able to inherit templates and component assignments )\n    if componentsWithClassBasedAssignment.length > 0\n      for specialComponent in componentsWithClassBasedAssignment\n        containerAssignment = _.uniqueId('container')\n        targetEl = container.$( specialComponent.container )\n        if targetEl.length > 0\n          $(targetEl).attr('data-container-assignment', containerAssignment)\n          specialComponent.container += \"[data-container-assignment='#{ containerAssignment }']\"\n\n  prepareComponents: ()->\n    container = @\n\n    _( @components ).each (component, index)=>\n      ce = componentContainerElement = @componentContainers?[index]\n\n      # support a variety of the bad naming conventions\n      ce.class = ce.class || ce.className || ce.classes\n\n      if @generateComponentElements\n        panel = @make(@componentTag, componentContainerElement, '')\n        @$append( panel )\n\n      # if the container defines a @defaults property\n      # then we should make sure our child components inherit\n      # these values unless specifically defined\n      if container.defaults?\n        component = _.defaults(component, (container.defaults || {}))\n\n      # if the container defines an @extensions property as an array of\n      # configuration objects, then we will extend the component config with\n      # the object in the matching position of the @extensions array.\n      if _.isArray(container.extensions) and _.isObject(container.extensions?[ index ])\n        componentExtension = container.extensions[index]\n        component = _.extend(component, componentExtension)\n\n      # if the container defines an @extensions property as an object of nested hashes,\n      # then extensions is a key/value pair whose key represents the role of the component\n      # that we wish to extend / customize \n      if component.role? and _.isObject(container.extensions) and _.isObject(container.extensions[component.role])\n        componentExtension = container.extensions[component.role]\n        component = _.extend(component, componentExtension)\n        \n      unless component.container?\n        component.container = \"##{ componentContainerElement.id }\" if @generateComponentElements\n        component.container ||= @$bodyEl()\n\n  # create components is responsible for turning the JSON syntax of the\n  # container's definition into live objects against a given Luca Component\n  # type.\n  #\n  # In addition to this, a container builds an index of the components\n  # which belong to it, so that they can easily be looked up by name\n  createComponents: ()->\n    return if @componentsCreated is true\n\n    map = @componentIndex =\n      name_index: {}\n      cid_index: {}\n      role_index: {}\n\n    container   = @\n\n    @components = _( @components ).map (object, index)=>\n\n      # you can include normal backbone views as components\n      # you will want to make sure your render method handles\n      # adding the views @$el to the appropriate @container.\n\n      # you can also just pass a string representing the component_type\n      component = if Luca.isComponent( object )\n        object\n      else\n        # if a component is tagged with a @component property\n        # we assume this is the kind of singleton component\n        # and set the type, role and name to the same value (if they're blank)\n        if object.component? and not (object.type || object.ctype)\n          object.type = object.component\n          object.name ||= object.component\n          object.role ||= object.component\n\n        object.type ||= object.ctype\n\n        # guess the type based on the properties\n        if !object.type?\n          # TODO\n          # Add support for all of the various components property aliases\n          if object.components?\n            object.type = object.ctype = 'container'\n          else\n            object.type = object.ctype = Luca.defaultComponentType\n\n        object._parentCid ||= container.cid\n        created = Luca.util.lazyComponent( object )\n\n      # if we're using base backbone views, then they don't extend themselves\n      # with their passed options, so this is a workaround to get them to\n      # pick up the container config property\n      if !component.container and component.options?.container\n        component.container = component.options.container\n\n      component.getParent ||= ()-> Luca( component._parentCid )\n\n      if not component.container?\n        console.log component,index,@\n        console.error \"could not assign container property to component on container #{ @name || @cid }\"\n\n      indexComponent( component ).at(index).in( @componentIndex )\n\n      component\n\n    @componentsCreated = true\n\n    map\n\n  # Trigger the Rendering Pipeline process on all of the nested components\n  renderComponents: (@debugMode=\"\")->\n    @debug \"container render components\"\n\n    container = @\n\n    _(@components).each (component)->\n      try\n        component.trigger \"before:attach\"\n\n        containerElement = container.$(component.container)\n\n        if containerElement.length is 0\n          if _.isString( component.container )\n            # the container trying to assign this component to is not in the dom\n            1\n\n          # try in the window context.  this is almost always certainly a bug\n          # so look into wtf is going on and which components are problematic\n          containerElement = @$( component.container ).eq(0) if containerElement.length is 0\n\n        if @emptyContainerElements is true\n          containerElement.empty()\n\n        containerElement.append( component.el )\n\n        component.trigger \"after:attach\"\n        component.render()\n        component.rendered = true\n      catch e\n        console.log \"Error Rendering Component #{ component.name || component.cid }\", component\n\n        if _.isObject(e)\n          console.log e.message\n          console.log e.stack\n\n        throw e unless Luca.silenceRenderErrors? is true\n\n  # When a container is first activated is a good time to perform\n  # operations which are not needed unless that component becomes\n  # visible.  This first activation event should be relayed to all\n  # of the nested components.  Components which hide / display\n  # other components, such as a CardView or TabContainer\n  # will trigger first:activation on the components as they become\n  # displayed.\n  firstActivation: ()->\n    activator = @\n    @each (component, index)->\n      # apply the first:activation trigger on the component, in the context of the component\n      # passing as arguments the component itself, and the component doing the activation\n      unless component?.previously_activated is true\n        component?.trigger?.call component, \"first:activation\", component, activator\n        component.previously_activated = true\n\n  registerComponentEvents: (eventList, direction=\"on\")->\n    container = @\n\n    for listener, handler of (eventList || @componentEvents||{})\n      [componentNameOrRole,eventId] = listener.split(' ')\n\n      unless _.isFunction( @[handler] )\n        console.log \"Error registering component event\", listener, componentNameOrRole, eventId\n        throw \"Invalid component event definition #{ listener }. Specified handler is not a method on the container\"\n\n      if componentNameOrRole is \"*\"\n        @eachComponent (component)=> component.on(eventId, @[handler], container)\n      else\n        component = @findComponentForEventBinding( componentNameOrRole )\n\n        unless component? and Luca.isComponent(component)\n          console.log \"Error registering component event\", listener, componentNameOrRole, eventId\n          throw \"Invalid component event definition: #{ componentNameOrRole }\"\n\n        component[direction](eventId, @[handler], container)\n\ncontainer.publicMethods\n  # Returns an underscore.js object that wraps the components array\n  _: ()-> _( @components )\n\n  # Return the value of attribute of each component \n  pluck: (attribute)->\n    @_().pluck(attribute)\n\n  # Invoke the passed method name on each component\n  invoke: (method)->\n    @_().invoke(method)\n\n  # Select any component for which the passed iterator returns true\n  select: (iterator)->\n    @_().select(iterator)\n\n  # Find the first matching component for which the passed iterator returns true\n  detect: (iterator)->\n    @_().detect(iterator)\n\n  # Return a list of components without the components for which the passed iterator returns true \n  reject: (iterator)->\n    @_().reject(iterator)\n\n  # Run the passed iterator over each component and return the result in an array\n  map: (fn)->\n    @_().map(fn)\n\n  # Returns a list of nested components which are also containers\n  subContainers: ()->\n    @select (component)->\n      component.isContainer is true\n\n  roles: ()->\n    _( @allChildren() ).chain().pluck('role').compact().value()\n\n  allChildren: ()->\n    children = @components\n\n    grandchildren = _( @subContainers() ).map (component)->\n      component?.allChildren?()\n\n    _([children,grandchildren]).chain().compact().flatten().value()\n\n  # Find a direct component on this card by its name.\n  find: (name)-> \n    _( @components ).detect (c)-> \n      c.name is name    \n\n  findComponentForEventBinding: (nameRoleOrGetter, deep=true)->\n    @findComponentByName(nameRoleOrGetter, deep) || @findComponentByGetter( nameRoleOrGetter, deep ) || @findComponentByRole( nameRoleOrGetter, deep )\n\n  findComponentByGetter: (getter, deep=false)->\n    _( @allChildren() ).detect (component)->\n      component?.getter is getter\n\n  findComponentByRole: (role,deep=false)->\n    _( @allChildren() ).detect (component)->\n      component?.role is role or component?.type is role or component?.ctype is role\n\n  findComponentByType: (desired,deep=false)->\n    _( @allChildren() ).detect (component)->\n      desired is (component.type || component.ctype)\n\n  findComponentByName: (name, deep=false)->\n    _( @allChildren() ).detect (component)->\n      component.name is name\n\n  findComponentById: (id, deep=false)->\n    @findComponent(id, \"cid_index\", deep)\n\n  findComponent: (needle, haystack=\"name\", deep=false)->\n    @createComponents() unless @componentsCreated is true\n\n    position = @componentIndex?[ haystack ][ needle ]\n    component = @components[ position ]\n\n    return component if component\n\n    if deep is true\n      sub_container = _( @components ).detect (component)->\n        component?.findComponent?(needle, haystack, true)\n\n      sub_container?.findComponent?(needle, haystack, true)\n\n  each: (fn)->\n    @eachComponent(fn, false)\n\n  # run a function for each component in this container\n  # and any nested containers in those components, recursively\n  # pass false as the second argument to skip the deep recursion\n  eachComponent: (fn, deep=true)->\n    _( @components ).each (component, index)=>\n      fn.call component, component, index\n      component?.eachComponent?.apply component, [fn,deep] if deep\n\n  indexOfComponentName: (name)->\n    names = _( @components ).pluck('name')\n    _( names ).indexOf(name)\n\n  indexOf: (nameOrComponent)->\n    if _.isString(nameOrComponent)\n      return @indexOfComponentName(nameOrComponent)\n\n    if _.isObject(nameOrComponent)\n      _( @components ).indexOf( nameOrComponent )\n\n  activeComponent: ()->\n    return @ unless @activeItem\n    return @components[ @activeItem ]\n\n  componentElements: ()->\n    @$(\"[data-luca-parent='#{ @name || @cid }']\")\n\n  getComponent: (needle)->\n    @components[ needle ]\n\n  isRootComponent:()->\n    @rootComponent is true || !@getParent?\n\n  getRootComponent: ()->\n    if @isRootComponent() then @ else @getParent().getRootComponent()\n\n\n  selectByAttribute: (attribute, value=undefined, deep=false)->\n    components = _( @components ).map (component)->\n      matches = []\n      test = component[ attribute ]\n\n      matches.push( component ) if test is value or (not value? and test?)\n\n      # recursively traverse our components\n      matches.push component.selectByAttribute?(attribute, value, true) if deep is true\n\n      _.compact matches\n\n    _.flatten( components )\n\n\ncontainer.register()\n\n# This is the method by which a container injects the rendered child views\n# into the DOM.  It will get passed the container object, and the component\n# that is being rendered.\nLuca.Container.componentRenderer = (container, component)->\n  attachMethod = $( component.container )[ component.attachWith || \"append\" ]\n  attachMethod( component.render().el )\n\n\n#### Private Helpers\n\ndoLayout = ()->\n  @trigger \"before:layout\", @\n  @prepareLayout()\n  @trigger \"after:layout\", @\n\napplyDOMConfig = (panel, panelIndex)->\n  style_declarations = []\n\n  style_declarations.push \"height: #{ (if _.isNumber(panel.height) then panel.height + 'px' else panel.height ) }\" if panel.height?\n  style_declarations.push \"width: #{ (if _.isNumber(panel.width) then panel.width + 'px' else panel.width ) }\" if panel.width?\n  style_declarations.push \"float: #{ panel.float }\" if panel.float\n\n  config =\n    class: panel?.classes || @componentClass\n    id: \"#{ @cid }-#{ panelIndex }\"\n    style: style_declarations.join(';')\n    \"data-luca-parent\" : @name || @cid\n\n  if @customizeContainerEl?\n   config = @customizeContainerEl( config, panel, panelIndex )\n\n  config\n\n\n\ncreateGetterMethods = ()->\n  container = @\n\n  childrenWithGetter = _( @allChildren() ).select (component)->\n    component?.getter?\n\n  _( childrenWithGetter ).each (component)->\n    container[ component.getter ] ||= ()-> component\n\ncreateMethodsToGetComponentsByRole = ()->\n  container = @\n\n  childrenWithRole = _( @allChildren() ).select (component)->\n    component?.role?\n\n  _( childrenWithRole ).each (component)->\n    getter = _.str.camelize( \"get_\" + component.role )\n    getterFn = ()-> component\n    container[ getter ] ||= _.bind(getterFn, container) \n\ndoComponents = ()->\n  @trigger \"before:components\", @, @components\n  @prepareComponents()\n  @trigger \"before:create:components\", @, @components\n  @createComponents()\n  @trigger \"before:render:components\", @, @components\n  @renderComponents()\n  @trigger \"after:components\", @, @components\n\n  unless @skipGetterMethods is true\n    createGetterMethods.call(@)\n    createMethodsToGetComponentsByRole.call(@)\n\n  @registerComponentEvents()\n\nvalidateContainerConfiguration = ()->\n  true\n\n# indexComponent( component ).at( index ).in( componentsInternalIndexMap )\nindexComponent = (component)->\n  at: (index)->\n    in: (map)->\n      if component.cid?\n        map.cid_index[ component.cid ] = index\n      if component.role?\n        map.role_index[ component.role ] = index\n      if component.name?\n        map.name_index[ component.name ] = index\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/modal_view.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/modal_view.coffee","type":"component_definition","starts_on_line":1,"class_name":"Luca.containers.ModalView","header_documentation":"","type_alias":"modal_view","css_class_identifier":"luca-containers-modal-view","defines_methods":{"container":{"defined_on_line":11,"documentation":"","arguments":[]},"toggle":{"defined_on_line":14,"documentation":"","arguments":[]},"show":{"defined_on_line":17,"documentation":"","arguments":[]},"hide":{"defined_on_line":20,"documentation":"","arguments":[]},"render":{"defined_on_line":23,"documentation":"","arguments":[]}},"defines_properties":{"closeOnEscape":{"defined_on_line":5,"documentation":"","default":"true"},"showOnInitialize":{"defined_on_line":6,"documentation":"","default":"false"},"backdrop":{"defined_on_line":7,"documentation":"","default":"false"},"className":{"defined_on_line":8,"documentation":"","default":"\"modal\""}},"source_file_contents":"view = Luca.register      \"Luca.containers.ModalView\"\nview.extends              \"Luca.Container\"\n\nview.publicConfiguration\n  closeOnEscape: true\n  showOnInitialize: false\n  backdrop: false\n  className: \"modal\"\n\nview.publicMethods\n  container: ()->\n    $('body')\n\n  toggle: ()->\n    @$el.modal('toggle')\n\n  show: ()->\n    @$el.modal('show')\n\n  hide: ()->\n    @$el.modal('hide')\n\n  render: ()->\n    @$el.addClass 'modal'\n    @$el.addClass 'fade' if @fade is true\n\n    $('body').append( @$el )\n    \n    @$el.modal\n      backdrop: !!(@backdrop is true)\n      keyboard: !!(@closeOnEscape is true)\n      show: !!(@showOnInitialize is true)\n\n    @\n\nview.register()\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/page_controller.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/page_controller.coffee","type":"component_definition","starts_on_line":13,"class_name":"Luca.containers.PageController","header_documentation":"<p>The PageController container is a special type of container whose components or pages\nwill always monopolize the entire element&#39;s display and where only one page or component\nwill be visible at a time.  The PageController is typically going to be at the very root\nof every application, and will be directly integrated with the application&#39;s router. \nA typical application hierarchy will be an abstract <code>Viewport</code> with a single top level\n<code>PageController</code> named &#39;main_controller&#39;. \n      - Viewport / Application\n        - Router. ( maps urls to named pages on the controller )\n        - Main Page Controller\n          - Pages\n            - Named views / containers</p>\n","type_alias":"page_controller","css_class_identifier":"luca-containers-page-controller","defines_methods":{"initialize":{"defined_on_line":17,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]}},"defines_properties":{},"source_file_contents":"# The PageController container is a special type of container whose components or pages\n# will always monopolize the entire element's display and where only one page or component\n# will be visible at a time.  The PageController is typically going to be at the very root\n# of every application, and will be directly integrated with the application's router. \n# A typical application hierarchy will be an abstract `Viewport` with a single top level\n# `PageController` named 'main_controller'. \n#\n#       - Viewport / Application\n#         - Router. ( maps urls to named pages on the controller )\n#         - Main Page Controller\n#           - Pages\n#             - Named views / containers\nview = Luca.register    \"Luca.containers.PageController\"\nview.extends            \"Luca.Container\"\n\nview.privateMethods\n  initialize: (@options={})->\n    @components ||= @pages || @options.pages\n    for component in @components\n      component.components ||= component.pages\n\n    Luca.Container::initialize.apply(@, arguments)\n\nview.register()  \n\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/panel_toolbar.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/panel_toolbar.coffee","type":"component_definition","starts_on_line":1,"class_name":"Luca.PanelToolbar","header_documentation":"<p>The Panel Toolbar is a collection of buttons and / or dropdowns</p>\n","type_alias":"panel_toolbar","css_class_identifier":"luca-panel-toolbar","defines_methods":{"initialize":{"defined_on_line":29,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"clickHandler":{"defined_on_line":43,"documentation":"<p>The Toolbar behaves by triggering events on the components which they\nbelong to. Combined with Luca.View::setupHooks it is a clean way\nto organize actions</p>\n","arguments":[{"argument":"e","value":null}]},"beforeRender":{"defined_on_line":61,"documentation":"","arguments":[]},"render":{"defined_on_line":72,"documentation":"","arguments":[]}},"defines_properties":{"buttons":{"defined_on_line":20,"documentation":"<p>@buttons is an array of button config objects\nbutton config accepts the following paramters:</p>\n\n<p>label       what should the button say\neventId     what event should the button trigger\ndropdown    an array of arrays: [eventId, label]\ngroup       an array of button configs\nwrapper     a css class, in addition to btn-group\nicon        which icon do you want to use on this button?\nwhite       true or false: is it a white colored text?\ncolor       options are primary, info, success, warning, danger, inverse</p>\n","default":"[]"},"orientation":{"defined_on_line":22,"documentation":"","default":"'top'"},"autoBindEventHandlers":{"defined_on_line":24,"documentation":"","default":"true"},"events":{"defined_on_line":26,"documentation":"","default":null}},"source_file_contents":"panelToolbar = Luca.register        \"Luca.PanelToolbar\"\n# The Panel Toolbar is a collection of buttons and / or dropdowns\n# which are automatically created by BasicPanel classes, or can be\n# added to any other view component.\npanelToolbar.extends                \"Luca.View\"\n\n\npanelToolbar.defines\n  # @buttons is an array of button config objects\n  # button config accepts the following paramters:\n  #\n  # label       what should the button say\n  # eventId     what event should the button trigger\n  # dropdown    an array of arrays: [eventId, label]\n  # group       an array of button configs\n  # wrapper     a css class, in addition to btn-group\n  # icon        which icon do you want to use on this button?\n  # white       true or false: is it a white colored text?\n  # color       options are primary, info, success, warning, danger, inverse\n  buttons:[]\n\n  orientation: 'top'\n\n  autoBindEventHandlers: true\n\n  events:\n    \"click a.btn, click .dropdown-menu li\" : \"clickHandler\"\n\n  initialize: (@options={})->\n    @_super(\"initialize\", @, arguments)\n\n    # if the toolbar consists of a single button group\n    # don't make the developer specify buttons = {buttons:[group:true, buttons:[...]]}\n    if @group is true and @buttons?.length >= 0\n      @buttons = [\n        group: true\n        buttons: @buttons\n      ]\n\n  # The Toolbar behaves by triggering events on the components which they\n  # belong to. Combined with Luca.View::setupHooks it is a clean way\n  # to organize actions\n  clickHandler: (e)->\n    me = my = $( e.target )\n    me = my = $( e.target ).parent() if me.is('i')\n\n    if @selectable is true\n      my.siblings().removeClass(\"is-selected\")\n      me.addClass('is-selected')\n\n    return unless eventId = my.data('eventid')\n\n    hook = Luca.util.hook( eventId )\n\n    source = @parent || @\n    if _.isFunction( source[hook] )\n      source[ hook ].call(@, me, e)\n    else\n      source.trigger(eventId, me, e)\n\n  beforeRender:()->\n    @_super(\"beforeRender\", @, arguments)\n\n    if @well is true\n      @$el.addClass 'well'\n\n    @$el.addClass 'btn-selectable' if @selectable is true\n    @$el.addClass \"toolbar-#{ @orientation }\"\n    @$el.addClass \"pull-right\" if @align is \"right\"\n    @$el.addClass \"pull-left\" if @align is \"left\"\n\n  render: ()->\n    @$el.empty()\n    @$el.append( element ) for element in prepareButtons(@buttons)\n    @\n\n\nmake = Luca.View::make\n\nbuildButton = (config, wrap=true)->\n  if config.ctype? or config.type?\n    config.className ||= \"\"\n    config.className += 'toolbar-component'\n\n    object = Luca(config).render()\n\n    if Luca.isBackboneView(object)\n      return object.$el\n\n  if config.spacer\n    return make \"div\", class: \"spacer #{ config.spacer }\"\n\n  if config.text\n    return make \"div\", {class: \"toolbar-text\"}, config.text\n\n  wrapper = 'btn-group'\n  wrapper += \"#{ config.wrapper }\" if config.wrapper?\n  wrapper += \"pull-#{ config.align } align-#{ config.align }\" if config.align?\n  wrapper += 'btn-selectable' if config.selectable is true\n\n  # if we're passed a group, then we need to just\n  # wrap the contents of the buttons property in that group\n  # skipping the btn-group wrapping that takes place for\n  # individual buttons\n  if config.group? and config.buttons?\n    buttons = prepareButtons( config.buttons, false )\n    return make \"div\", class: wrapper, buttons\n\n  # if it is a normal button, and not a button group\n  else\n    label = config.label ||= \"\"\n\n    config.eventId ||= _.string.dasherize( config.label.toLowerCase() )\n\n    if config.icon\n      label = \" \" if _.string.isBlank( label )\n      white = \"icon-white\" if config.white\n      label = \"<i class='#{ white || \"\" } icon-#{ config.icon }' /> #{ label }\"\n\n    buttonAttributes =\n      class: _.compact([\"btn\",config.classes,config.className]).join(\" \")\n      \"data-eventId\" : config.eventId\n      title: config.title || config.description\n\n    buttonAttributes[\"class\"] += \" btn-#{ config.color }\" if config.color?\n    buttonAttributes[\"class\"] += \" is-selected\" if config.selected?\n\n    if config.dropdown\n      label = \"#{ label } <span class='caret'></span>\"\n      buttonAttributes[\"class\"] += \" dropdown-toggle\"\n      buttonAttributes[\"data-toggle\"] = \"dropdown\"\n\n      dropdownItems = for dropdownItem in config.dropdown\n        if _.isObject(dropdownItem)\n          dropdownItem = _.values(dropdownItem).reverse()\n\n        link = make \"a\", {}, dropdownItem[1]\n        make \"li\", {\"data-eventId\": dropdownItem[0]}, link\n\n      dropdownEl = make \"ul\", {class:\"dropdown-menu\"}, dropdownItems\n\n    buttonEl = make \"a\", buttonAttributes, label\n\n    # needs to be wrapped for proper rendering, but not\n    # if it already is part of a group\n    autoWrapClass = \"btn-group\"\n    autoWrapClass += \" align-#{ config.align }\" if config.align?\n\n    if wrap is true\n      return make \"div\", {class: autoWrapClass}, [buttonEl,dropdownEl]\n    else\n      # for buttons which are already part f a group\n      buttonEl\n\nprepareButtons = (buttons=[], wrap=true)->\n  buildButton(button, wrap) for  button in buttons\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/tab_view.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/tab_view.coffee","type":"component_definition","starts_on_line":1,"class_name":"Luca.containers.TabView","header_documentation":"","type_alias":"tab_view","css_class_identifier":"luca-containers-tab-view","defines_methods":{"initialize":{"defined_on_line":19,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"activeTabSelector":{"defined_on_line":30,"documentation":"","arguments":[]},"beforeLayout":{"defined_on_line":33,"documentation":"","arguments":[]},"afterRender":{"defined_on_line":41,"documentation":"","arguments":[]},"createTabSelectors":{"defined_on_line":50,"documentation":"","arguments":[]},"highlightSelectedTab":{"defined_on_line":63,"documentation":"","arguments":[]},"tabSelectClickHandler":{"defined_on_line":67,"documentation":"","arguments":[{"argument":"e","value":null}]},"select":{"defined_on_line":75,"documentation":"","arguments":[{"argument":"tabName","value":"0"}]},"componentElements":{"defined_on_line":80,"documentation":"","arguments":[]},"tabContentWrapper":{"defined_on_line":83,"documentation":"","arguments":[]},"tabContainerWrapper":{"defined_on_line":86,"documentation":"","arguments":[]},"tabContainer":{"defined_on_line":89,"documentation":"","arguments":[]},"tabSelectors":{"defined_on_line":92,"documentation":"","arguments":[]},"bodyTemplateVars":{"defined_on_line":95,"documentation":"","arguments":[]}},"defines_properties":{"tab_position":{"defined_on_line":8,"documentation":"","default":"'top'"},"tabVerticalOffset":{"defined_on_line":9,"documentation":"","default":"'50px'"},"additionalClassNames":{"defined_on_line":12,"documentation":"","default":"'tabbable'"},"navClass":{"defined_on_line":13,"documentation":"","default":"\"nav-tabs\""},"bodyTemplate":{"defined_on_line":14,"documentation":"","default":"\"containers/tab_view\""},"bodyClassName":{"defined_on_line":15,"documentation":"","default":"\"tab-content\""},"skipGetterMethods":{"defined_on_line":16,"documentation":"","default":"true"}},"source_file_contents":"tabView = Luca.register       \"Luca.containers.TabView\"\ntabView.extends               \"Luca.containers.CardView\"\n\ntabView.triggers              \"before:select\",\n                              \"after:select\"\n\ntabView.publicConfiguration\n  tab_position: 'top'\n  tabVerticalOffset: '50px'\n\ntabView.privateConfiguration\n  additionalClassNames: 'tabbable'\n  navClass: \"nav-tabs\"\n  bodyTemplate: \"containers/tab_view\"\n  bodyClassName: \"tab-content\"\n  skipGetterMethods: true\n\ntabView.defines\n  initialize: (@options={})->\n    @navClass = \"nav-list\"if @navStyle is \"list\"\n\n    Luca.containers.CardView::initialize.apply @, arguments\n\n    _.bindAll @, \"select\", \"highlightSelectedTab\"\n\n    @setupHooks( @hooks )\n\n    @bind \"after:card:switch\", @highlightSelectedTab\n\n  activeTabSelector: ()->\n    @tabSelectors().eq( @activeCard || @activeTab || @activeItem )\n\n  beforeLayout: ()->\n    @$el.addClass(\"tabs-#{ @tab_position }\")\n    @activeTabSelector().addClass 'active'\n\n    @createTabSelectors()\n\n    Luca.containers.CardView::beforeLayout?.apply @, arguments\n\n  afterRender: ()->\n    Luca.containers.CardView::afterRender?.apply @, arguments\n    tabContainerId = @tabContainer().attr(\"id\")\n    @registerEvent(\"click ##{ tabContainerId } li a\", \"tabSelectClickHandler\")\n\n    if Luca.config.enableBootstrap and (@tab_position is \"left\" or @tab_position is \"right\")\n      @tabContainerWrapper().addClass(\"span2\")\n      @tabContentWrapper().addClass(\"span9\")\n\n  createTabSelectors: ()->\n    tabView = @\n    @each (component,index)->\n      icon = \"<i class='icon-#{ component.tabIcon }'></i>\" if component.tabIcon\n      link = \"<a href='#'>#{ icon || ''} #{ component.title }</a>\"\n      selector = tabView.make(\"li\",{class:\"tab-selector\",\"data-target\":index}, link)\n      tabView.tabContainer().append(selector)\n\n      if component.navHeading? and not tabView.navHeadings?[ component.navHeading ]\n        $( selector ).before( tabView.make('li',{class:\"nav-header\"}, component.navHeading))\n        tabView.navHeadings ||= {}\n        tabView.navHeadings[ component.navHeading ] = true\n\n  highlightSelectedTab: ()->\n    @tabSelectors().removeClass('active')\n    @activeTabSelector().addClass('active')\n\n  tabSelectClickHandler: (e)->\n    e?.preventDefault()\n    me = my = $( e.target )\n    me = my ||= @tabSelectors()[0]\n    tabName = my.parent().data('target')\n\n    @select(tabName)\n\n  select: (tabName=0)->\n    @trigger \"before:select\", @\n    @activate(tabName)\n    @trigger \"after:select\", @\n\n  componentElements: ()->\n    @$(\">.tab-content >.#{ @componentClass }\")\n\n  tabContentWrapper: ()->\n    $(\"##{ @cid }-tab-view-content\")\n\n  tabContainerWrapper: ()->\n    $(\"##{ @cid }-tabs-selector\")\n\n  tabContainer: ()->\n    @$(\"ul.#{ @navClass }\", @tabContainerWrapper() )\n\n  tabSelectors: ()->\n    @$( 'li.tab-selector', @tabContainer() )\n\n  bodyTemplateVars: ()->\n    cid: @cid  \n    navClass: @navClass"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/viewport.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/viewport.coffee","type":"component_definition","starts_on_line":1,"class_name":"Luca.containers.Viewport","header_documentation":"","type_alias":"viewport","css_class_identifier":"luca-containers-viewport","defines_methods":{"initialize":{"defined_on_line":10,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"enableFluid":{"defined_on_line":21,"documentation":"","arguments":[{"argument":")-> @enableWrapper(","value":null}]},"disableFluid":{"defined_on_line":23,"documentation":"","arguments":[{"argument":")-> @disableWrapper(","value":null}]},"enableWrapper":{"defined_on_line":25,"documentation":"","arguments":[]},"disableWrapper":{"defined_on_line":29,"documentation":"","arguments":[]},"enableFullscreen":{"defined_on_line":33,"documentation":"","arguments":[]},"disableFullscreen":{"defined_on_line":37,"documentation":"","arguments":[]},"beforeRender":{"defined_on_line":41,"documentation":"","arguments":[]},"height":{"defined_on_line":47,"documentation":"","arguments":[]},"width":{"defined_on_line":50,"documentation":"","arguments":[]},"afterRender":{"defined_on_line":53,"documentation":"","arguments":[]},"renderTopNavigation":{"defined_on_line":59,"documentation":"","arguments":[]},"renderBottomNavigation":{"defined_on_line":74,"documentation":"","arguments":[]}},"defines_properties":{"fullscreen":{"defined_on_line":5,"documentation":"","default":"true"},"fluid":{"defined_on_line":6,"documentation":"","default":"false"},"applyWrapper":{"defined_on_line":8,"documentation":"","default":"true"}},"source_file_contents":"viewport = Luca.register    \"Luca.containers.Viewport\"\nviewport.extends            \"Luca.Container\"\n\nviewport.defines\n  fullscreen: true\n  fluid: false\n\n  applyWrapper: true\n\n  initialize: (@options={})->\n    _.extend @, @options\n\n    if Luca.config.enableBoostrap is true and @applyWrapper is true\n      @wrapperClass = if @fluid is true then Luca.config.fluidWrapperClass else Luca.config.wrapperClass\n\n    Luca.Container::initialize.apply(@, arguments)\n\n    if @fullscreen is true\n      @enableFullscreen() \n\n  enableFluid: ()-> @enableWrapper()\n\n  disableFluid: ()-> @disableWrapper()\n   \n  enableWrapper: ()->\n    if @wrapperClass?\n      @$el.parent().addClass( @wrapperClass ) \n\n  disableWrapper: ()->\n    if @wrapperClass?\n      @$el.parent().removeClass( @wrapperClass ) \n\n  enableFullscreen: ()->\n    $('html,body').addClass('luca-ui-fullscreen')\n    @$el.addClass('fullscreen-enabled')\n\n  disableFullscreen: ()->\n    $('html,body').removeClass('luca-ui-fullscreen')\n    @$el.removeClass('fullscreen-enabled')\n\n  beforeRender: ()->\n    Luca.Container::beforeRender?.apply(@, arguments)\n\n    @renderTopNavigation() if @topNav?\n    @renderBottomNavigation() if @bottomNav?\n\n  height: ()->\n    @$el.height()\n\n  width: ()->\n    @$el.width()\n\n  afterRender: ()->\n    Luca.Container::afterRender?.apply(@, arguments)\n\n    if Luca.config.enableBoostrap is true and @containerClassName\n      @$el.children().wrap('<div class=\"#{ containerClassName }\" />')\n\n  renderTopNavigation: ()->\n    return unless @topNav?\n\n    if _.isString( @topNav )\n      @topNav = Luca.util.lazyComponent(@topNav)\n\n    if _.isObject( @topNav )\n      @topNav.ctype ||= @topNav.type || \"nav_bar\"\n      unless Luca.isBackboneView(@topNav)\n        @topNav = Luca.util.lazyComponent( @topNav )\n\n    @topNav.app = @\n\n    $('body').prepend( @topNav.render().el )\n\n  renderBottomNavigation: ()->\n    # IMPLEMENT\n\n\nLuca.containers.Viewport.defaultWrapperClass  = Luca.config.wrapperClass || 'container'\nLuca.containers.Viewport.fluidWrapperClass    = Luca.config.fluidWrapperClass || 'container-fluid'\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/core/collection.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/core/collection.coffee","type":"component_definition","starts_on_line":1,"class_name":"Luca.Collection","header_documentation":"","type_alias":"collection","css_class_identifier":"","defines_methods":{"initialize":{"defined_on_line":36,"documentation":"","arguments":[{"argument":"models","value":"[]"},{"argument":"@options","value":null}]},"__wrapUrl":{"defined_on_line":119,"documentation":"<p>TODO</p>\n\n<p>This has got to go.  It is messing up URL for show actions\nfor models part of luca collections when there are base query params</p>\n","arguments":[]},"queryString":{"defined_on_line":142,"documentation":"","arguments":[]},"resetFilter":{"defined_on_line":151,"documentation":"","arguments":[]},"applyFilter":{"defined_on_line":155,"documentation":"","arguments":[{"argument":"filter","value":"{}"},{"argument":"options","value":"{}"}]},"applyParams":{"defined_on_line":166,"documentation":"<p>You can apply params to a collection, so that any upcoming requests\nmade to the REST API are made with the key values specified</p>\n","arguments":[{"argument":"params","value":null}]},"register":{"defined_on_line":172,"documentation":"","arguments":[{"argument":"collectionManager","value":null},{"argument":"key","value":"\"\""},{"argument":"collection","value":null}]},"loadFromBootstrap":{"defined_on_line":199,"documentation":"<p>A Luca.Collection will load models from the in memory model store\nreturned from Luca.Collection.cache, where the key returned from\nthe @cache_keyattribute or method matches the key of the model cache</p>\n","arguments":[]},"bootstrap":{"defined_on_line":205,"documentation":"<p>an alias for loadFromBootstrap which is a bit more descriptive</p>\n","arguments":[]},"cached_models":{"defined_on_line":211,"documentation":"<p>cached<em>models is a reference to the Luca.Collection.cache object\nkey&#39;d on whatever this collection&#39;s bootstrap</em>cache<em>key is set to be\nvia the @cache</em>key() interface</p>\n","arguments":[]},"fetch":{"defined_on_line":220,"documentation":"<p>Luca.Collection overrides the default Backbone.Collection.fetch method\nand triggers an event &quot;before:fetch&quot; which gives you additional control\nover the process</p>\n\n<p>in addition, it loads models directly from the bootstrap cache instead\nof going directly to the API</p>\n","arguments":[{"argument":"options","value":"{}"}]},"onceLoaded":{"defined_on_line":249,"documentation":"<p>onceLoaded is equivalent to binding to the\nreset trigger with a function wrapped in _.once\nso that it only gets run...ahem...once.</p>\n\n<p>it won&#39;t even bother fetching it it will just run\nas if reset was already triggered</p>\n","arguments":[{"argument":"fn","value":null},{"argument":"options","value":"{}"}]},"ifLoaded":{"defined_on_line":269,"documentation":"<p>ifLoaded is equivalent to binding to the reset trigger with\na function, if the collection already has models it will just\nrun automatically.  similar to onceLoaded except the binding\nstays in place</p>\n","arguments":[{"argument":"fn","value":null},{"argument":"options","value":"{scope:@"},{"argument":"autoFetch:true}","value":null}]},"parse":{"defined_on_line":280,"documentation":"","arguments":[{"argument":"response","value":null}]},"restoreMethodCache":{"defined_on_line":295,"documentation":"<p>Method Caching</p>\n\n<p>Method Caching is a way of saving the output of a method on your collection.\nAnd then expiring that value if any changes are detected to the models in\nthe collection</p>\n","arguments":[]},"clearMethodCache":{"defined_on_line":301,"documentation":"","arguments":[{"argument":"method","value":null}]},"clearAllMethodsCache":{"defined_on_line":304,"documentation":"","arguments":[]},"setupMethodCaching":{"defined_on_line":308,"documentation":"","arguments":[]},"query":{"defined_on_line":351,"documentation":"<p>make sure the querying interface from backbone.query is present\nin the case backbone-query isn&#39;t loaded.  without it, it will\njust return the models</p>\n\n<p>TODO:</p>\n\n<p>Currently the View mixins: Filterable, Sortable, and Paginatable\nimplement a lot of logic that belongs in this interface.</p>\n","arguments":[{"argument":"filter","value":"{}"},{"argument":"options","value":"{}"}]},"trigger":{"defined_on_line":365,"documentation":"","arguments":[]}},"defines_properties":{"model":{"defined_on_line":10,"documentation":"","default":"Luca.Model"},"cachedMethods":{"defined_on_line":19,"documentation":"<p>cachedMethods refers to a list of methods on the collection\nwhose value gets cached once it is ran.  the collection then\nbinds to change, add, remove, and reset events and then expires\nthe cached value once these events are fired.</p>\n\n<p>cachedMethods expects an array of strings representing the method name\nor objects containing @method and @resetEvents properties.  by default\n@resetEvents are &#39;add&#39;,&#39;remove&#39;,reset&#39; and &#39;change&#39;.</p>\n","default":"[]"},"remoteFilter":{"defined_on_line":23,"documentation":"<p>if filtering a collection should handle via a call to a REST API\nand return the filtered results that way, then set this to true</p>\n","default":"false"},"cache_key":{"defined_on_line":30,"documentation":"<p>setting a cache key to a string, or to a function which returns\na string, will determine where the collections&#39; models are pulled\nfrom if they are available on page load.  also known as &quot;bootstrapping&quot;\nyour collections with data.  The cache key will look in whatever object\nis set in Luca.config.modelBootstrap for its models.</p>\n","default":"undefined"},"manager":{"defined_on_line":34,"documentation":"<p>Which CollectionManager should we register with? Expects either a string\nwhich will get resolved into a global variable, or a</p>\n","default":"undefined"}},"source_file_contents":"collection = Luca.register          'Luca.Collection'\ncollection.extends                  'Backbone.QueryCollection'\ncollection.includes                 'Luca.Events'\n\ncollection.triggers                 \"after:initialize\",  \n                                    \"before:fetch\",\n                                    \"after:response\"\n\ncollection.publicConfiguration    \n  model: Luca.Model\n  # cachedMethods refers to a list of methods on the collection\n  # whose value gets cached once it is ran.  the collection then\n  # binds to change, add, remove, and reset events and then expires\n  # the cached value once these events are fired.\n  #\n  # cachedMethods expects an array of strings representing the method name\n  # or objects containing @method and @resetEvents properties.  by default\n  # @resetEvents are 'add','remove',reset' and 'change'.\n  cachedMethods: []\n\n  # if filtering a collection should handle via a call to a REST API\n  # and return the filtered results that way, then set this to true\n  remoteFilter: false\n\n  # setting a cache key to a string, or to a function which returns\n  # a string, will determine where the collections' models are pulled\n  # from if they are available on page load.  also known as \"bootstrapping\"\n  # your collections with data.  The cache key will look in whatever object\n  # is set in Luca.config.modelBootstrap for its models.\n  cache_key: undefined\n\n  # Which CollectionManager should we register with? Expects either a string\n  # which will get resolved into a global variable, or a \n  manager: undefined\n\n  initialize: (models=[], @options)->\n    _.extend @, @options\n    @_reset()\n\n    # By specifying a @cache_key property or method, you can instruct\n    # Luca.Collection instances where to pull an array of model attributes\n    # usually done with the bootstrap functionality provided.\n\n    # DEPRECATION NOTICE\n    if @cached\n      console.log 'The @cached property of Luca.Collection is being deprecated.  Please change to cache_key'\n\n    if @cache_key ||= @cached\n      @bootstrap_cache_key = Luca.util.read(@cache_key) \n\n    if @registerAs or @registerWith\n      console.log \"This configuration API is deprecated.  use @name and @manager properties instead\"\n\n    # support the older configuration API\n    @name ||= @registerAs\n    @manager ||= @registerWith\n\n    @manager = Luca.util.read(@manager) if @manager? \n\n    # if they specify a\n    if @name and not @manager\n      @manager = Luca.CollectionManager.get()\n\n    # If we are going to be registering this collection with the CollectionManager\n    # class, then we need to specify a key to register ourselves under. @registerAs can be\n    # as simple as something as \"books\", or if you are using collections which need\n    # to be scoped with some sort of unique id, as say some sort of belongsTo relationship\n    # then you can specify @registerAs as a method()\n    if @manager\n      @name ||= Luca.util.read(@cache_key) \n      @name = Luca.util.read(@name) \n\n      unless @private or @anonymous\n        @bind \"after:initialize\", ()=>\n          @register( @manager, @name, @)\n\n    # by passing useLocalStorage = true to your collection definition\n    # you will bypass the RESTful persistence layer and just persist everything\n    # locally in localStorage\n    if @useLocalStorage is true and window.localStorage?\n      table = @bootstrap_cache_key || @name\n      throw \"Must specify a cache_key property or method to use localStorage\"\n      @localStorage = new Luca.LocalStore( table )\n\n    # Populating a collection with local data\n    #\n    # by specifying a @data property which is an array\n    # then you can set the collection to be a @memoryCollection\n    # which never interacts with a persistence layer at all.\n    #\n    # this is mainly used by the Luca.fields.SelectField class for\n    # generating simple select fields with static data\n    if _.isArray(@data) and @data.length > 0\n      @memoryCollection = true\n\n    @__wrapUrl() unless @useNormalUrl is true\n\n    Backbone.Collection::initialize.apply @, [models, @options]\n\n    if models\n      @reset models, silent: true, parse: options?.parse\n\n    Luca.concern.setup.call(@)\n    Luca.util.setupHooks.call(@, @hooks)\n\n    @setupMethodCaching()\n\n    @trigger \"after:initialize\"\n\n  # Luca.Collections will append a query string to the URL\n  # and will automatically do this for you without you having\n  # to write a special url handler.  If you want to use a normal\n  # url without this feature, just set @useNormalUrl = true\n\n  # TODO\n  #\n  # This has got to go.  It is messing up URL for show actions\n  # for models part of luca collections when there are base query params\n  __wrapUrl: ()->\n    if _.isFunction(@url)\n      @url = _.wrap @url, (fn)=>\n        val = fn.apply @\n        parts = val.split('?')\n\n        existing_params = _.last(parts) if parts.length > 1\n\n        queryString = @queryString()\n\n        if existing_params and val.match(existing_params)\n          queryString = queryString.replace( existing_params, '')\n\n        new_val = \"#{ val }?#{ queryString }\"\n        new_val = new_val.replace(/\\?$/,'') if new_val.match(/\\?$/)\n\n        new_val\n    else\n      url = @url\n      params = @queryString()\n\n      @url = _([url,params]).compact().join(\"?\")\n\n  queryString: ()->\n    parts = _( @base_params ||= Luca.Collection.baseParams() ).inject (memo, value, key)=>\n      str = \"#{ key }=#{ value }\"\n      memo.push(str)\n      memo\n    , []\n\n    _.uniq(parts).join(\"&\")\n\n  resetFilter: ()->\n    @base_params = _( Luca.Collection.baseParams() ).clone()\n    @\n\n  applyFilter: (filter={}, options={})->\n    options = _( options ).clone()\n\n    if options.remote? is true or @remoteFilter is true\n      @applyParams(filter)\n      @fetch _.extend(options,refresh:true,remote:true)\n    else\n      @reset @query(filter, options)\n\n  # You can apply params to a collection, so that any upcoming requests\n  # made to the REST API are made with the key values specified\n  applyParams: (params)->\n    @base_params = _( Luca.Collection.baseParams() ).clone() || {}\n    _.extend @base_params, params\n\n    @\n\n  register: (collectionManager, key=\"\", collection)->\n    collectionManager ||= Luca.CollectionManager.get()\n\n    unless key.length >= 1\n      throw \"Attempt to register a collection without specifying a key.\" \n\n\n    # by passing a string instead of a reference to an object, we can look up\n    # that object only when necessary.  this prevents us from having to create\n    # the manager instance before we can define our collections\n    if _.isString( collectionManager )\n      collectionManager = Luca.util.resolve( collectionManager )\n\n    unless collectionManager?\n      throw \"Attempt to register with a non existent collection manager.\" \n\n    if _.isFunction( collectionManager.add )\n      return collectionManager.add(key, collection)\n\n    # If we don't want to use the CollectionManager class, and just want\n    # to cache collection instances on an object, we can do that too.\n    if _.isObject( collectionManager )\n      collectionManager[ key ] = collection\n\n  # A Luca.Collection will load models from the in memory model store\n  # returned from Luca.Collection.cache, where the key returned from\n  # the @cache_keyattribute or method matches the key of the model cache\n  loadFromBootstrap: ()->\n    return unless @bootstrap_cache_key\n    @reset @cached_models()\n    @trigger \"bootstrapped\", @\n\n  # an alias for loadFromBootstrap which is a bit more descriptive\n  bootstrap: ()->\n    @loadFromBootstrap()\n\n  # cached_models is a reference to the Luca.Collection.cache object\n  # key'd on whatever this collection's bootstrap_cache_key is set to be\n  # via the @cache_key() interface\n  cached_models: ()->\n    Luca.Collection.cache( @bootstrap_cache_key )\n\n  # Luca.Collection overrides the default Backbone.Collection.fetch method\n  # and triggers an event \"before:fetch\" which gives you additional control\n  # over the process\n  #\n  # in addition, it loads models directly from the bootstrap cache instead\n  # of going directly to the API\n  fetch: (options={})->\n    @trigger \"before:fetch\", @\n\n    return @reset(@data) if @memoryCollection is true\n\n    # fetch will try to pull from the bootstrap if it is setup to do so\n    # you can actually make the roundtrip to the server anyway if you pass\n    # refresh = true in the options hash\n    return @bootstrap() if @cached_models().length and not (options.refresh is true or options.remote is true)\n\n    url = if _.isFunction(@url) then @url() else @url\n\n    return true unless ((url and url.length > 1) or @localStorage)\n\n    @fetching = true\n\n    try\n      Backbone.Collection.prototype.fetch.apply @, arguments\n    catch e\n      console.log \"Error in Collection.fetch\", e\n\n      throw e\n\n  # onceLoaded is equivalent to binding to the\n  # reset trigger with a function wrapped in _.once\n  # so that it only gets run...ahem...once.\n  #\n  # it won't even bother fetching it it will just run\n  # as if reset was already triggered\n  onceLoaded: (fn, options={})->\n    _.defaults(options, autoFetch: true)\n\n    if @length > 0 and not @fetching\n      fn.apply @, [@]\n      return\n\n    wrapped = ()=> fn.apply @,[@]\n\n    @bind \"reset\", ()->\n      wrapped()\n      @unbind \"reset\", @\n\n    unless @fetching or not !!options.autoFetch\n      @fetch()\n\n  # ifLoaded is equivalent to binding to the reset trigger with\n  # a function, if the collection already has models it will just\n  # run automatically.  similar to onceLoaded except the binding\n  # stays in place\n  ifLoaded: (fn, options={scope:@,autoFetch:true})->\n    scope = options.scope || @\n\n    if @length > 0 and not @fetching\n      fn.apply scope, [@]\n\n    @bind \"reset\", (collection)=> fn.call(scope,collection)\n\n    unless @fetching is true or !options.autoFetch or @length > 0\n      @fetch()\n\n  parse: (response)->\n    @fetching = false\n    @trigger \"after:response\", response\n    models = if @root? then response[ @root ] else response\n\n    if @bootstrap_cache_key\n      Luca.Collection.cache( @bootstrap_cache_key, models)\n\n    models\n\n  # Method Caching\n  #\n  # Method Caching is a way of saving the output of a method on your collection.\n  # And then expiring that value if any changes are detected to the models in\n  # the collection\n  restoreMethodCache: ()->\n    for name, config of @_methodCache\n      if config.original?\n        config.args = undefined\n        @[ name ] = config.original\n\n  clearMethodCache: (method)->\n    @_methodCache[method].value = undefined\n\n  clearAllMethodsCache: ()->\n    for name, config of @_methodCache\n      @clearMethodCache(name)\n\n  setupMethodCaching: ()->\n    return unless @cachedMethods?.length > 0 \n\n    collection = @\n    membershipEvents = [\"reset\",\"add\",\"remove\"]\n    cache = @_methodCache = {}\n\n    _( @cachedMethods ).each (method)->\n      # store a reference to the unwrapped version of the method\n      # and a placeholder for the cached value\n      cache[ method ] =\n        name: method\n        original: collection[method]\n        value: undefined\n\n      # wrap the collection method with a basic memoize operation\n      collection[ method ] = ()->\n        cache[method].value ||= cache[method].original.apply(collection, arguments)\n\n      # bind to events on the collection, which once triggered, will\n      # invalidate the cached value.  causing us to have to restore it\n      for membershipEvent in membershipEvents\n        collection.bind membershipEvent, ()->\n          collection.clearAllMethodsCache()\n\n      dependencies = method.split(':')[1]\n\n      if dependencies\n        watchForChangesOn = dependencies.split(\",\")\n\n        _( watchForChangesOn ).each (dependency)->\n          collection.bind \"change:#{dependency}\", ()->\n            collection.clearMethodCache(method: method)\n\n\n  # make sure the querying interface from backbone.query is present\n  # in the case backbone-query isn't loaded.  without it, it will\n  # just return the models\n  #\n  # TODO:\n  # \n  # Currently the View mixins: Filterable, Sortable, and Paginatable\n  # implement a lot of logic that belongs in this interface.\n  query: (filter={},options={})->\n    if Backbone.QueryCollection?\n      if _.isFunction(prepare = options.prepare || @prepareQuery)\n        filter = prepare(filter) \n\n      return Backbone.QueryCollection::query.call(@, filter, options)\n    else\n      @models\n\ncollection.register()\n\n\n# Global Collection Observer\n_.extend Luca.Collection.prototype,\n  trigger: ()->\n    if Luca.enableGlobalObserver\n      Luca.CollectionObserver ||= new Luca.Observer(type:\"collection\")\n      Luca.CollectionObserver.relay(@, arguments)\n\n    Backbone.View.prototype.trigger.apply @, arguments\n\nLuca.Collection._originalExtend = Backbone.Collection.extend\n\nLuca.Collection.extend = (definition={})->\n  # for backward compatibility\n  definition.concerns ||= definition.concerns if definition.concerns?\n\n  componentClass = Luca.Collection._originalExtend.call(@, definition)\n\n  if definition.concerns? and _.isArray( definition.concerns )\n    for module in definition.concerns\n      Luca.decorate( componentClass ).with( module )\n\n  componentClass\n\nLuca.Collection.namespace = (namespace)->\n  namespace = Luca.util.resolve(namespace) if _.isString(namespace)\n  Luca.Collection.__defaultNamespace = namespace if namespace?\n  Luca.Collection.__defaultNamespace ||= (window || global)\n  Luca.util.read( Luca.Collection.__defaultNamespace )\n  \n# Always include these parameters in every request to your REST API.\n#\n# either specify a function which returns a hash, or just a normal hash\nLuca.Collection.baseParams = (obj)->\n  obj = Luca.util.resolve(obj) if _.isString(obj)\n  Luca.Collection._baseParams = obj if obj\n\n  Luca.util.read( Luca.Collection._baseParams )\n\nLuca.Collection.resetBaseParams = ()->\n  Luca.Collection._baseParams = {}\n  \n# In order to make our Backbone Apps super fast it is a good practice\n# to pre-populate your collections by what is referred to as bootstrapping\n#\n# Luca.Collections make it easier for you to do this cleanly and automatically\n#\n# by specifying a @cache_keyproperty or method in your collection definition\n# Luca.Collections will automatically look in this space to find models\n# and avoid a roundtrip to your API unless explicitly told to.\nLuca.Collection._bootstrapped_models = {}\n\n# In order to do this, just load an object whose keys\nLuca.Collection.bootstrap = (obj)->\n  _.extend Luca.Collection._bootstrapped_models, obj\n\n# Lookup cached() or bootstrappable models.  This is used by the\n# augmented version of Backbone.Collection.fetch() in order to avoid\n# roundtrips to the API\nLuca.Collection.cache = (key, models)->\n  return Luca.Collection._bootstrapped_models[ key ] = models if models\n  Luca.Collection._bootstrapped_models[ key ] || []\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/core/model.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/core/model.coffee","type":"component_definition","starts_on_line":1,"class_name":"Luca.Model","header_documentation":"","type_alias":"model","css_class_identifier":"","defines_methods":{"initialize":{"defined_on_line":8,"documentation":"","arguments":[]},"read":{"defined_on_line":13,"documentation":"","arguments":[{"argument":"attr","value":null}]},"get":{"defined_on_line":19,"documentation":"","arguments":[{"argument":"attr","value":null}]}},"defines_properties":{},"source_file_contents":"model = Luca.register     'Luca.Model'\n\nmodel.extends             'Backbone.Model'\n\nmodel.includes            'Luca.Events'\n\nmodel.defines\n  initialize: ()->\n    Backbone.Model::initialize(@, arguments)\n    setupComputedProperties.call(@)\n    Luca.concern.setup.call(@)\n\n  read: (attr)->\n    if _.isFunction(@[attr])\n      @[attr].call(@)\n    else\n      @get(attr) || @[attr]\n\n  get: (attr)->\n    if @computed?.hasOwnProperty(attr)\n      @_computed[attr]\n    else\n      Backbone.Model::get.call @, attr\n\nsetupComputedProperties = ()->\n  return if _.isUndefined(@computed)\n\n  @_computed = {}\n\n  for attr, dependencies of @computed\n    @on \"change:#{attr}\", ()=>\n      @_computed[attr] = @read(attr) \n\n    dependencies = dependencies.split(',') if _.isString(dependencies)\n\n    _(dependencies).each (dep)=>\n      @on \"change:#{dep}\", ()=>\n        @trigger \"change:#{attr}\"\n        \n      @trigger \"change:#{attr}\" if @has(dep) \n\n\nLuca.Model._originalExtend = Backbone.Model.extend\n\nLuca.Model.extend = (definition={})->\n  # for backward compatibility\n  definition.concerns ||= definition.concerns if definition.concerns?\n\n  componentClass = Luca.Model._originalExtend.call(@, definition)\n  \n  if definition.concerns? and _.isArray( definition.concerns )\n    for module in definition.concerns\n      Luca.decorate( componentClass ).with( module )\n\n  componentClass\n\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/core/panel.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/core/panel.coffee","type":"component_definition","starts_on_line":4,"class_name":"Luca.Panel","header_documentation":"<p>Luca.Panel is a low level Luca.View component which is used \nto build components which have toolbar areas, and a body area for the main\ncontents of the view.</p>\n","type_alias":"panel","css_class_identifier":"luca-panel","defines_methods":{"applyStyles":{"defined_on_line":18,"documentation":"","arguments":[{"argument":"styles","value":"{}"},{"argument":"body","value":"false"}]},"$bodyEl":{"defined_on_line":27,"documentation":"","arguments":[]},"$wrap":{"defined_on_line":44,"documentation":"","arguments":[]},"$template":{"defined_on_line":50,"documentation":"","arguments":[]},"$empty":{"defined_on_line":53,"documentation":"","arguments":[]},"$html":{"defined_on_line":56,"documentation":"","arguments":[]},"$append":{"defined_on_line":59,"documentation":"","arguments":[]},"beforeRender":{"defined_on_line":63,"documentation":"","arguments":[]},"renderToolbars":{"defined_on_line":69,"documentation":"","arguments":[]},"renderToolbar":{"defined_on_line":74,"documentation":"","arguments":[{"argument":"orientation","value":"\"top\""},{"argument":"config","value":"{}"}]},"attachToolbar":{"defined_on_line":83,"documentation":"","arguments":[{"argument":"config","value":"{}"},{"argument":"targetEl","value":null}]}},"defines_properties":{"topToolbar":{"defined_on_line":11,"documentation":"","default":"undefined"},"bottomToolbar":{"defined_on_line":12,"documentation":"","default":"undefined"},"version":{"defined_on_line":124,"documentation":"","default":"3"}},"source_file_contents":"# Luca.Panel is a low level Luca.View component which is used \n# to build components which have toolbar areas, and a body area for the main\n# contents of the view.\npanel = Luca.register           \"Luca.Panel\"\n\npanel.replaces                  \"Luca.Panel\"\n\npanel.extends                   \"Luca.View\"\n\npanel.configuration\n  topToolbar: undefined\n  bottomToolbar: undefined\n  #loadMask: false\n  #loadMaskTemplate: \"components/load_mask\"\n  #loadMaskTimeout: 3000\n\npanel.publicMethods\n  applyStyles: (styles={},body=false)->\n\n    target = if body then @$bodyEl() else @$el\n\n    for setting, value  of styles\n      target.css(setting,value)\n\n    @\n\n  $bodyEl: ()->\n    element = @bodyTagName || \"div\"\n    className = @bodyClassName || \"view-body\"\n\n    @bodyEl ||= \"#{ element }.#{ className }\"\n\n    bodyEl = @$(@bodyEl)\n\n    return bodyEl if bodyEl.length > 0\n\n    if bodyEl.length is 0 and (@bodyClassName? || @bodyTagName?)\n      newElement = @make(element,class:className,\"data-auto-appended\":true)\n      @$el.append( newElement )\n      return @$(@bodyEl)\n\n    @$el\n\n  $wrap: (wrapper)->\n    if _.isString(wrapper) and not wrapper.match(/[<>]/)\n      wrapper = @make(\"div\",class:wrapper)\n\n    @$el.wrap( wrapper )\n\n  $template: (template, variables={})->\n    @$html( Luca.template(template,variables) )\n\n  $empty: ()->\n    @$bodyEl().empty()\n    \n  $html: (content)->\n    if content? then @$bodyEl().html( content ) else @$bodyEl().html()\n\n  $append: (content)->\n    @$bodyEl().append(content)\n\npanel.privateMethods\n  beforeRender: ()->\n    Luca.View::beforeRender?.apply(@, arguments)\n    @applyStyles( @styles ) if @styles?\n    @applyStyles( @bodyStyles, true ) if @bodyStyles?\n    @renderToolbars?()\n\n  renderToolbars: ()->\n    _( [\"top\",\"left\",\"right\",\"bottom\"] ).each (orientation)=>\n      if config = @[\"#{ orientation }Toolbar\"]\n        @renderToolbar( orientation, config)\n\n  renderToolbar: (orientation=\"top\", config={})->\n    config.parent = @\n    config.orientation = orientation\n    el = Luca.util.read( config.container )\n    el ||= Luca.util.read( config.targetEl )\n\n    Luca.Panel.attachToolbar.call(@, config, el )\n\npanel.classMethods\n  attachToolbar: (config={}, targetEl)->\n    config.orientation ||= \"top\"\n    config.type ||= config.ctype ||= @toolbarType || \"panel_toolbar\"\n\n    config.additionalClassNames = \"#{ Luca.config.toolbarContainerClass } #{ config.orientation }\"\n  \n    toolbar = Luca.util.lazyComponent( config )\n    # TEMP\n    # Do this properly\n    if config.orientation is \"bottom\"\n      @getBottomToolbar ||= ()-> toolbar   \n\n    if config.orientation is \"top\"\n      @getTopToolbar ||= ()-> toolbar   \n\n    if config.orientation is \"right\"\n      @getRightToolbar ||= ()-> toolbar   \n\n    if config.orientation is \"left\"\n      @getLeftToolbar ||= ()-> toolbar   \n\n    hasBody = @bodyClassName or @bodyTagName\n\n    action = config.attachmentAction\n    # there will be a body panel inside of the views $el\n    # so just place the toolbar before, or after the body\n    action ||= switch config.orientation\n      when \"top\", \"left\"\n        if hasBody and not targetEl?.length > 0 then \"before\" else \"prepend\"\n\n      when \"bottom\", \"right\"\n        if hasBody and not targetEl?.length > 0 then \"after\" else \"append\"\n\n    toolbarEl = if targetEl?.length > 0\n      @$(targetEl)\n    else\n      @$bodyEl()\n\n    toolbarEl[action]( toolbar.render().el )\n\npanel.defines\n  version: 3"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/core/view.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/core/view.coffee","type":"component_definition","starts_on_line":74,"class_name":"Luca.View","header_documentation":"<p><code>Luca.View</code> is an enhanced <code>Backbone.View</code> which provides common patterns for view components,\nand various helper methods and configuration conventions.</p>\n\n<h4>Instance caching / naming</h4>\n\n<p>If you provide a <code>@name</code> property to your views, they will be accessible by that property\nusing the Application helper.<br>\n      view = new Luca.View(name:&quot;my<em>view&quot;)\n      Luca(&quot;my</em>view&quot;) === view</p>\n\n<h4>CSS @className conventions</h4>\n\n<p>In order to make it easier to componentize your views, extending from <code>Luca.View</code> will\nenable CSS class based inheritance based on the names of the view class.</p>\n\n<h5>For Example:</h5>\n\n<pre><code>  base = Luca.register  &quot;App.views.BaseViewClass&quot;\n  base.extends          &quot;Luca.View&quot;\n  base.defines\n    className: &quot;some-other-class&quot;\n  child = Luca.register &quot;App.views.ChildViewClass&quot;\n  child.extends         &quot;App.views.BaseViewClass&quot;\n  child.defines\n    myClasses: ()-&gt;\n      @$el.attr(&#39;class&#39;) \n\nview = new App.views.ChildViewClass()\nview.myClasses() #=&gt; &quot;app-base-view-class app-child-view-class some-other-class&quot;\n</code></pre>\n\n<p>This establishes a convention for css class names, and allows you to componetize your css\nalong with the component by joining them based on the name of your view class.  When using\nSass scoping / nesting it fits very nicely together.</p>\n\n<h4>Internal state machine</h4>\n\n<p>Any <code>Luca.View</code> class which defines a <code>@stateful</code> property will automatically generate a\n<code>@state</code> model that can be used to get/set attributes on the view as well as bind to change events on these attributes.  </p>\n\n<p>This gives your views a dedicated place to store state, and you can bind to your data models separately\nand update the DOM without confusing the two. </p>\n\n<pre><code>  statefulView = Luca.register    &quot;App.views.StatefulView&quot;\n  statefulView.extends            &quot;Luca.View&quot;\n  statefulView.defines\n    # Passing an object allows you to set default values on the @state model.\n    stateful:\n      attribute: &quot;value&quot;\n    # Whenever the attribute specified changes, call the specified method.\n    stateChangeEvents:\n      &quot;attribute&quot; : &quot;onAttributeChange&quot;\n\n    onAttributeChange: (stateMachine, attributeValue)-&gt;\n      @doSomethingWhenAttributeChanges()\n</code></pre>\n\n<p>If this type of declarative style isn&#39;t your thing, you can still bind to events in code:</p>\n\n<pre><code>  view = new App.views.StatefulView()\n  view.on &quot;state:change:attribute&quot;, (stateMachine, attributeValue)=&gt; @$el.html(&quot;New Attribute: #&quot;)\n  view.set &quot;attribute&quot;, &quot;something&quot;\n</code></pre>\n\n<h4>Event binding helpers</h4>\n\n<p>In addition to the <code>@stateChangeEvent</code> bindings documented above, you have available\nto you similar configuration helpers for binding to events emitted by the singletons:\n- <code>Luca.Application</code> via <code>@applicationEvents</code> \n- <code>Luca.CollectionManager</code> via <code>@collectionEvents</code>\n- <code>Luca.SocketManager</code> via <code>@socketEvents</code></p>\n","type_alias":"view","css_class_identifier":"luca-view","defines_methods":{"identifier":{"defined_on_line":149,"documentation":"","arguments":[]},"remove":{"defined_on_line":154,"documentation":"<p>Calls Backbone.View::remove, and removes the view from the\ninstance cache.  Triggers a &quot;before:remove&quot; event.</p>\n","arguments":[]},"initialize":{"defined_on_line":159,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"debug":{"defined_on_line":188,"documentation":"","arguments":[{"argument":"args...","value":null}]},"trigger":{"defined_on_line":193,"documentation":"","arguments":[]},"make":{"defined_on_line":204,"documentation":"<p>Backbone.View.prototype.make is removed in 0.9.10.\nAs we happen to rely on this little utility heavily,\nwe add it to Luca.View</p>\n","arguments":[{"argument":"tagName","value":null},{"argument":"attributes","value":null},{"argument":"content","value":null}]},"registerEvent":{"defined_on_line":213,"documentation":"","arguments":[{"argument":"selector","value":null},{"argument":"handler","value":null}]},"definitionClass":{"defined_on_line":226,"documentation":"<p>Returns a reference to the class which this view is an instance of.</p>\n","arguments":[]},"_collections":{"defined_on_line":230,"documentation":"<p>Returns a list of all of the collections which are properties on this view.</p>\n","arguments":[]},"_models":{"defined_on_line":234,"documentation":"<p>Returns a list of all of the models which are properties on this view.</p>\n","arguments":[]},"_views":{"defined_on_line":238,"documentation":"<p>Returns a list of all of the views which are properties on this view.</p>\n","arguments":[]},"legacy":{"defined_on_line":276,"documentation":"","arguments":[{"argument":"_userSpecifiedMethod","value":null}]},"improved":{"defined_on_line":316,"documentation":"","arguments":[{"argument":"_userSpecifiedMethod","value":null}]}},"defines_properties":{"name":{"defined_on_line":111,"documentation":"<p>Specifying a <code>@name</code> for your views is useful for views which\nthere will only be one instance.  This allows you to reference\nthe view instances by name using the application helper:\nLuca(&quot;my<em>view</em>name&quot;)</p>\n","default":"undefined"},"autoBindEventHandlers":{"defined_on_line":137,"documentation":"<p>Setting this property to true will automatically bind the context\nof your event handler methods to the instance of this view.  This\nsaves you from having to manually do:</p>\n\n<p>Luca.View.extend\nevents:\n&quot;click .one&quot; : &quot;oneHandler&quot;\n&quot;click .two&quot; : &quot;twoHandler&quot;\ninitialize: ()-&gt;\n_.bindAll(@, &quot;oneHandler&quot;, &quot;twoHandler&quot;)</p>\n\n<p>Instead:</p>\n\n<p>Luca.View.extend\nautoBindEventHandlers: true\nevents:\n&quot;click .one&quot; : &quot;oneHandler&quot;</p>\n\n<p>Optionally, you can define an array of method names you want bound\nto this view:</p>\n\n<p>Luca.View.extend\nbindMethods:[&quot;oneHandler&quot;,&quot;twoHandler&quot;]</p>\n","default":"false"},"_inheritEvents":{"defined_on_line":143,"documentation":"<p>Supplying configuration to <code>@_inheritEvents</code> will ensure that this configuration\nis present on views which extend from this view.  In normal Backbone behavior\nthe <code>@events</code> property can be overridden by views which extend, and this isn&#39;t\nalways what you want from your component.</p>\n","default":"undefined"},"setupHooks":{"defined_on_line":252,"documentation":"<p>views which inherit from Luca.View can define hooks\nor events which can be emitted from them.  Automatically,\nany functions on the view which are named according to the\nconvention will automatically get run.</p>\n\n<p>by default, all Luca.View classes come with the following:</p>\n\n<ul>\n<li>before:render     : beforeRender()</li>\n<li>after:render      : afterRender()</li>\n<li>after:initialize  : afterInitialize()</li>\n<li>first:activation  : firstActivation()</li>\n</ul>\n","default":"Luca.util.setupHooks"},"if not Backbone.View":{"defined_on_line":257,"documentation":"","default":""},"_userSpecifiedMethod ||= ()-> @trigger \"empty":{"defined_on_line":343,"documentation":"","default":"render\""}},"source_file_contents":"# `Luca.View` is an enhanced `Backbone.View` which provides common patterns for view components,\n# and various helper methods and configuration conventions.\n#\n# #### Instance caching / naming\n#\n# If you provide a `@name` property to your views, they will be accessible by that property\n# using the Application helper.    \n#\n#       view = new Luca.View(name:\"my_view\")\n#       Luca(\"my_view\") === view\n#\n# #### CSS @className conventions\n#  \n# In order to make it easier to componentize your views, extending from `Luca.View` will\n# enable CSS class based inheritance based on the names of the view class.\n#\n# ##### For Example:\n#\n#       base = Luca.register  \"App.views.BaseViewClass\"\n#       base.extends          \"Luca.View\"\n#       base.defines\n#         className: \"some-other-class\"\n#\n#       child = Luca.register \"App.views.ChildViewClass\"\n#       child.extends         \"App.views.BaseViewClass\"\n#       child.defines\n#         myClasses: ()->\n#           @$el.attr('class') \n#     \n#     view = new App.views.ChildViewClass()\n#     view.myClasses() #=> \"app-base-view-class app-child-view-class some-other-class\"\n#\n# This establishes a convention for css class names, and allows you to componetize your css\n# along with the component by joining them based on the name of your view class.  When using\n# Sass scoping / nesting it fits very nicely together.\n#\n# #### Internal state machine\n# \n# Any `Luca.View` class which defines a `@stateful` property will automatically generate a\n# `@state` model that can be used to get/set attributes on the view as well as bind to change events on these attributes.  \n# \n# This gives your views a dedicated place to store state, and you can bind to your data models separately\n# and update the DOM without confusing the two. \n# \n#       statefulView = Luca.register    \"App.views.StatefulView\"\n#       statefulView.extends            \"Luca.View\"\n#\n#       statefulView.defines\n#         # Passing an object allows you to set default values on the @state model.\n#         stateful:\n#           attribute: \"value\"\n#\n#         # Whenever the attribute specified changes, call the specified method.\n#         stateChangeEvents:\n#           \"attribute\" : \"onAttributeChange\"\n#         \n#         onAttributeChange: (stateMachine, attributeValue)->\n#           @doSomethingWhenAttributeChanges()\n#\n#  If this type of declarative style isn't your thing, you can still bind to events in code:\n#       \n#       view = new App.views.StatefulView()\n#       view.on \"state:change:attribute\", (stateMachine, attributeValue)=> @$el.html(\"New Attribute: #\")\n#       view.set \"attribute\", \"something\"\n# \n# #### Event binding helpers\n# \n# In addition to the `@stateChangeEvent` bindings documented above, you have available\n# to you similar configuration helpers for binding to events emitted by the singletons:\n#\n# - `Luca.Application` via `@applicationEvents` \n# - `Luca.CollectionManager` via `@collectionEvents`\n# - `Luca.SocketManager` via `@socketEvents`\nview = Luca.register    \"Luca.View\"\nview.extends            \"Backbone.View\"\n\n# includes are extensions to the prototype, and have no special behavior\nview.includes           \"Luca.Events\",\n                        \"Luca.concerns.DomHelpers\",\n                        \"Luca.concerns.DevelopmentToolHelpers\"\n\n# concerns are includes with special property / method conventions\n# which customize the components through the use of __initializer and\n# __included method names.  These will be called every time an instance\n# is created, and the first time the mixin is used to enhance a component.\nview.mixesIn            \"DomHelpers\",\n                        \"Templating\",\n                        \"EnhancedProperties\",\n                        \"CollectionEventBindings\",\n                        \"ApplicationEventBindings\",\n                        \"StateModel\"\n\n# Luca.View classes have the concept of special events called hooks\n# which allow you to tap into the lifecycle events of your view to\n# customize their behavior.  This is especially useful in subclasses.\n#\n# You can utilize a @hook method by camelcasing the triggers defined below:\nview.triggers           \"before:initialize\",\n                        \"after:initialize\",\n                        \"before:render\",\n                        \"after:render\",\n                        \"first:activation\",\n                        \"activation\",\n                        \"deactivation\"\n\nview.publicConfiguration\n  # Specifying a `@name` for your views is useful for views which\n  # there will only be one instance.  This allows you to reference\n  # the view instances by name using the application helper:\n  #       Luca(\"my_view_name\")\n  name: undefined\n\n  # Setting this property to true will automatically bind the context\n  # of your event handler methods to the instance of this view.  This\n  # saves you from having to manually do:\n  #\n  #       Luca.View.extend\n  #         events:\n  #           \"click .one\" : \"oneHandler\"\n  #           \"click .two\" : \"twoHandler\"\n  #         initialize: ()->\n  #           _.bindAll(@, \"oneHandler\", \"twoHandler\")\n  #\n  #  Instead:\n  #\n  #       Luca.View.extend\n  #         autoBindEventHandlers: true\n  #         events: \n  #           \"click .one\" : \"oneHandler\"\n  #\n  # Optionally, you can define an array of method names you want bound\n  # to this view:\n  #\n  #       Luca.View.extend\n  #         bindMethods:[\"oneHandler\",\"twoHandler\"]\n  #\n  autoBindEventHandlers: false\n\n  # Supplying configuration to `@_inheritEvents` will ensure that this configuration\n  # is present on views which extend from this view.  In normal Backbone behavior\n  # the `@events` property can be overridden by views which extend, and this isn't\n  # always what you want from your component.   \n  _inheritEvents: undefined\n\n\n\n# Luca.View decorates Backbone.View with some patterns and conventions.\nview.publicMethods\n  identifier: ()->\n    (@displayName || @type ) + \":\" + (@name || @role || @cid)\n\n  # Calls Backbone.View::remove, and removes the view from the \n  # instance cache.  Triggers a \"before:remove\" event.\n  remove: ()->\n    @trigger(\"before:remove\", @)\n    Luca.remove(@)\n    Backbone.View::remove.apply(@, arguments)\n\n  initialize: (@options={})->\n    @trigger \"before:initialize\", @, @options\n\n    _.extend @, @options\n\n    if @autoBindEventHandlers is true or @bindAllEvents is true\n      bindAllEventHandlers.call(@)\n\n    @cid = _.uniqueId(@name) if @name?\n\n    @$el.attr(\"data-luca-id\", @name || @cid)\n\n    Luca.registry.cacheInstance( @cid, @ )\n\n    @setupHooks _( Luca.View::hooks.concat( @hooks ) ).uniq()\n\n    Luca.concern.setup.call(@)\n\n    @delegateEvents() unless _.isEmpty(@events)\n\n    @trigger \"after:initialize\", @\n\n    _.bindAll(@, @bindMethods...) if @bindMethods?.legth > 0\n\n    unless _.isEmpty(@_inheritEvents)\n      for eventId, handler of @_inheritEvents\n        @registerEvent(eventId, handler)\n\n\n  debug: (args...)->\n    if @debugMode is true or window.LucaDebugMode is true\n      args.unshift @identifier()\n      console.log args...\n\n  trigger: ()->\n    if Luca.enableGlobalObserver\n      if Luca.developmentMode is true or @observeEvents is true\n        Luca.ViewObserver ||= new Luca.Observer(type:\"view\")\n        Luca.ViewObserver.relay @, arguments\n\n    Backbone.View::trigger.apply @, arguments\n\n  # Backbone.View.prototype.make is removed in 0.9.10.\n  # As we happen to rely on this little utility heavily,\n  # we add it to Luca.View\n  make: (tagName, attributes, content)->\n    el = document.createElement(tagName);\n    if (attributes) \n      Backbone.$(el).attr(attributes)\n    if (content != null) \n      Backbone.$(el).html(content)\n      \n    el    \n\n  registerEvent: (selector, handler)->\n    @events ||= {}\n\n    if _.isObject(selector)\n      @events = _.extend(@events, selector)\n    else\n      if _.isFunction(handler) || (_.isString(handler) && @[handler]?)\n        @events[selector] = handler \n\n    @delegateEvents()\n\nview.privateMethods\n  # Returns a reference to the class which this view is an instance of.\n  definitionClass: ()->\n    Luca.util.resolve(@displayName, window)?.prototype\n\n  # Returns a list of all of the collections which are properties on this view.\n  _collections: ()->\n    Luca.util.selectProperties( Luca.isBackboneCollection, @ )\n\n  # Returns a list of all of the models which are properties on this view.\n  _models: ()->\n    Luca.util.selectProperties( Luca.isBackboneModel, @ )\n\n  # Returns a list of all of the views which are properties on this view.\n  _views: ()->\n    Luca.util.selectProperties( Luca.isBackboneView, @ )\n\n  # views which inherit from Luca.View can define hooks\n  # or events which can be emitted from them.  Automatically,\n  # any functions on the view which are named according to the\n  # convention will automatically get run.\n  #\n  # by default, all Luca.View classes come with the following:\n  #\n  # - before:render     : beforeRender()\n  # - after:render      : afterRender()\n  # - after:initialize  : afterInitialize()\n  # - first:activation  : firstActivation()\n  setupHooks: Luca.util.setupHooks\n\n# In order to support some Luca apps which rely\n# on Backbone.View.make.  \nview.afterDefinition ()->\n  if not Backbone.View::make?\n    Backbone.View::make = ()->\n      console.log \"Backbone.View::make has been removed from backbone.  You should use Luca.View::make instead.\"\n      Luca.View::make\n\nview.register()\n\nLuca.View._originalExtend = Backbone.View.extend\n\n# Note:\n#\n# I will be removing this prior to 1.0.  Optimizing for collection based\n# views does not belong in here, so the deferrable / collection binding stuff\n# needs to go.\n#\n# Being able to defer rendering until the firing of an event on another object\n# is something that does ask for some syntactic sugar though, so need to rethink.\n\nLuca.View.renderStrategies =\n  legacy: ( _userSpecifiedMethod )->\n    view = @\n    # if a view has a deferrable property set\n\n    if @deferrable\n      target = @deferrable_target\n\n      unless Luca.isBackboneCollection(@deferrable)\n        @deferrable = @collection\n\n      target ||= @deferrable\n      trigger = if @deferrable_event then @deferrable_event else Luca.View.deferrableEvent\n\n      deferred = ()->\n        _userSpecifiedMethod.call(view)\n        @rendered = true\n        view.trigger(\"after:render\", view)\n\n      view.defer(deferred).until(target, trigger)\n\n      view.trigger \"before:render\", @\n\n      autoTrigger = @deferrable_trigger || @deferUntil\n\n      if !autoTrigger?\n        target[ (@deferrable_method||\"fetch\") ].call(target)\n      else\n        fn = _.once ()=> @deferrable[ (@deferrable_method||\"fetch\") ]?()\n        (@deferrable_target || @ ).bind(@deferrable_trigger, fn)\n\n      return @\n\n    else\n      @trigger \"before:render\", @\n      _userSpecifiedMethod.apply(@, arguments)\n      @rendered = true\n      @trigger \"after:render\", @\n\n      return @\n\n  improved: (_userSpecifiedMethod)->\n    @trigger \"before:render\", @\n\n    deferred = ()=>\n      _userSpecifiedMethod.apply(@, arguments)\n      @trigger \"after:render\", @\n\n    console.log \"doing the improved one\", @deferrable\n\n    if @deferrable? and not _.isString(@deferrable)\n      throw \"Deferrable property is expected to be a event id\"\n\n    if _.isString(@deferrable)\n      console.log \"binding to #{ @deferrable } on #{ @cid }\"\n      view.on @deferrable, ()->\n        console.log \"did the improved one\"\n        deferred.call(view)\n        view.unbind(listenForEvent, @)\n\n    else\n      deferred.call(@)\n\n\n\nLuca.View.renderWrapper = (definition)->\n  _userSpecifiedMethod = definition.render\n\n  _userSpecifiedMethod ||= ()-> @trigger \"empty:render\"\n\n  definition.render = ()->\n    strategy = Luca.View.renderStrategies[ @renderStrategy ||= \"legacy\" ]\n\n    unless _.isFunction(strategy)\n      throw \"Invalid rendering strategy.  Please see Luca.View.renderStrategies\"\n\n    strategy.call(@, _userSpecifiedMethod)\n\n    @\n\n  definition\n\nbindAllEventHandlers = ()->\n  for config in [@events, @componentEvents, @collectionEvents, @applicationEvents] when not _.isEmpty(config)\n    bindEventHandlers.call(@, config)\n\nbindEventHandlers = (events={})->\n  for eventSignature, handler of events\n    if _.isString(handler)\n      try\n        _.bindAll @, handler\n      catch e\n        console.log \"Error binding to handler - #{handler} = #{e} #{@identifier()}\"\n\nLuca.View.deferrableEvent = \"reset\"\n\nLuca.View.extend = (definition={})->\n  definition = Luca.View.renderWrapper( definition )\n  # for backward compatibility\n  definition.concerns ||= definition.concerns if definition.concerns?\n\n  componentClass = Luca.View._originalExtend.call(@, definition)\n\n  if definition.concerns? and _.isArray( definition.concerns )\n    for module in definition.concerns\n      Luca.decorate( componentClass ).with( module )\n\n  componentClass\n\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/development/code_sync_manager.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/development/code_sync_manager.coffee","type":"component_definition","starts_on_line":44,"class_name":"Luca.CodeSyncManager","header_documentation":"<p>The <code>Luca.CodeSyncManager</code> is a client side component that works with the luca\nexecutable that ships with the gem.  It listens for notifications of asset changes\n(scss,coffeescript,templates,etc) in your development directory, and applies them to the running session.\nIt works similar to tools like &#39;LiveReload&#39; but without refreshing the entire page, and with direct integration\nwith your asset pipeline / sprockets configuration.  For Luca apps specifically, it also handles changes to\ncomponent definitions more elegantly by updating live instances of your component prototypes and event handlers\nso that you don&#39;t have to refresh so often.</p>\n\n<h4>Setup</h4>\n\n<p>Run the luca command from your project root, and specify the name of the application you are watching:</p>\n\n<pre><code>  bundle exec luca sync app_name\n</code></pre>\n\n<p>The sync server runs a faye process on port 9295.  You can specify options on the command line.\nIn your browser, you can control various settings by setting the <code>Luca.config</code> values.<br>\n- Luca.config.codeSyncHost\n- Luca.config.codeSyncChannel\n- Luca.config.codeSyncStylesheetMode</p>\n\n<h4>Including in your Development Application</h4>\n\n<p>After your Luca.Application renders, just call the Luca.CodeSyncManager.setup method\nin the context of your application.</p>\n\n<pre><code>app = Luca.getApplication()\napp.on &quot;after:render&quot;, Luca.CodeSyncManager.setup, app\n</code></pre>\n\n<p>Or in the initialize method of your application:\n    ... \n    initialize: ()-&gt;\n      @on &quot;after:render&quot;, Luca.CodeSyncManager.setup, @ \n    ...</p>\n\n<h4>Syncpad</h4>\n\n<p>Any assets named syncpad: syncpad.coffee, syncpad.css.css, syncpad.jst.ejs, etc are treated specially by the\ncode sync utility.  The syncpad assets are used to provide a scratch pad / test environment for your application.\nYou can write coffeescript or sass and have them live evaluated in your running browser.  </p>\n","type_alias":"code_sync_manager","css_class_identifier":"luca-code-sync-manager","defines_methods":{"host":{"defined_on_line":49,"documentation":"<p>What URL will the faye server be available at?</p>\n","arguments":[{"argument":"Luca.config.codeSyncHost ||","value":"\"//localhost:9295/luca\""}]},"channel":{"defined_on_line":53,"documentation":"<p>Which channel does the server side process publish changes to? You shouldn&#39;t need\nto change this ever unless you are using your own faye server.</p>\n","arguments":[{"argument":"Luca.config.codeSyncChannel ||","value":"\"/code-sync\""}]},"styleSheetMode":{"defined_on_line":60,"documentation":"<p>Available options are single, and intelligent.\n- single: loads the stylesheet independently\n- intelligent:  loads the stylesheet, and then finds where in the DOM that stylesheet\nwas loaded and attempts to reload any styles that came after so that\nrules get set appropriately.</p>\n","arguments":[{"argument":"Luca.config.codeSyncStylesheetMode ||","value":"\"single\""}]},"setup":{"defined_on_line":64,"documentation":"<p>The preferred way of including code sync functionality into your application.</p>\n","arguments":[{"argument":"options","value":"{}"}]},"initialize":{"defined_on_line":69,"documentation":"","arguments":[{"argument":"@attributes","value":"{}"}]},"start":{"defined_on_line":76,"documentation":"","arguments":[]},"bindToChannel":{"defined_on_line":79,"documentation":"","arguments":[]},"onChangesNotification":{"defined_on_line":91,"documentation":"<p>changeData is a payload that gets sent over the socket\nwhenever an asset that is being watched changes.\nit is different if the type of file is css or javascript.</p>\n","arguments":[{"argument":"changeData","value":"{}"},{"argument":"applicationName","value":null}]},"rerunSyncPad":{"defined_on_line":113,"documentation":"","arguments":[]},"processTemplate":{"defined_on_line":117,"documentation":"","arguments":[{"argument":"change","value":"{}"}]},"processComponentDefinitionChange":{"defined_on_line":123,"documentation":"","arguments":[{"argument":"change","value":"{}"}]},"processJavascriptChange":{"defined_on_line":133,"documentation":"","arguments":[{"argument":"change","value":"{}"}]},"processStylesheetChange":{"defined_on_line":147,"documentation":"","arguments":[{"argument":"change","value":"{}"}]},"replaceStylesheetAndEverythingAfter":{"defined_on_line":155,"documentation":"","arguments":[{"argument":"path","value":null}]},"syncStylesheet":{"defined_on_line":172,"documentation":"","arguments":[{"argument":"change","value":null}]}},"defines_properties":{"make":{"defined_on_line":183,"documentation":"","default":"Luca.View"}},"source_file_contents":"# The `Luca.CodeSyncManager` is a client side component that works with the luca\n# executable that ships with the gem.  It listens for notifications of asset changes\n# (scss,coffeescript,templates,etc) in your development directory, and applies them to the running session.\n#\n# It works similar to tools like 'LiveReload' but without refreshing the entire page, and with direct integration\n# with your asset pipeline / sprockets configuration.  For Luca apps specifically, it also handles changes to\n# component definitions more elegantly by updating live instances of your component prototypes and event handlers\n# so that you don't have to refresh so often.\n#\n#\n# #### Setup\n#\n# Run the luca command from your project root, and specify the name of the application you are watching:\n#       \n#       bundle exec luca sync app_name\n#       \n# The sync server runs a faye process on port 9295.  You can specify options on the command line.\n#\n# In your browser, you can control various settings by setting the `Luca.config` values.         \n#\n# - Luca.config.codeSyncHost\n# - Luca.config.codeSyncChannel\n# - Luca.config.codeSyncStylesheetMode\n#\n# #### Including in your Development Application \n#\n# After your Luca.Application renders, just call the Luca.CodeSyncManager.setup method\n# in the context of your application.\n# \n#     app = Luca.getApplication()\n#     app.on \"after:render\", Luca.CodeSyncManager.setup, app\n#\n# Or in the initialize method of your application:\n#     ... \n#     initialize: ()->\n#       @on \"after:render\", Luca.CodeSyncManager.setup, @ \n#     ...\n#\n# #### Syncpad\n#\n# Any assets named syncpad: syncpad.coffee, syncpad.css.css, syncpad.jst.ejs, etc are treated specially by the\n# code sync utility.  The syncpad assets are used to provide a scratch pad / test environment for your application.\n# You can write coffeescript or sass and have them live evaluated in your running browser.  \ncodeManager = Luca.register     \"Luca.CodeSyncManager\"\ncodeManager.extends             \"Luca.SocketManager\"\n\ncodeManager.publicConfiguration\n  # What URL will the faye server be available at?\n  host:             (Luca.config.codeSyncHost ||= \"//localhost:9295/luca\")\n\n  # Which channel does the server side process publish changes to? You shouldn't need\n  # to change this ever unless you are using your own faye server.\n  channel:          (Luca.config.codeSyncChannel ||= \"/code-sync\")\n\n  # Available options are single, and intelligent.  \n  #   - single: loads the stylesheet independently\n  #   - intelligent:  loads the stylesheet, and then finds where in the DOM that stylesheet\n  #                   was loaded and attempts to reload any styles that came after so that\n  #                   rules get set appropriately.\n  styleSheetMode:   (Luca.config.codeSyncStylesheetMode ||= \"single\")\n\ncodeManager.classMethods\n  # The preferred way of including code sync functionality into your application.\n  setup: (options={})->\n    @codeSync = new Luca.CodeSyncManager(options) \n    @codeSync.trigger \"ready\"\n\ncodeManager.privateMethods\n  initialize: (@attributes={})->\n    unless @attributes.host?\n      _.extend(@attributes, host: (@host || Luca.config.codeSyncHost))\n\n    Luca.SocketManager::initialize.call(@, @attributes)\n    @bindToChannel()\n\n  start: ()->\n    @trigger \"ready\"\n\n  bindToChannel: ()->\n    if @client?\n      @client.subscribe @channel, ()=>\n        @onChangesNotification.apply(@, arguments)\n    else\n      @on \"change:client\", (socketManager, client)=>\n        @client.subscribe @channel, ()=>\n          @onChangesNotification.apply(@, arguments)    \n\n  # changeData is a payload that gets sent over the socket\n  # whenever an asset that is being watched changes. \n  # it is different if the type of file is css or javascript.\n  onChangesNotification: (changeData={}, applicationName)->\n    return if _.isEmpty(changeData)\n    data = _( changeData ).values()[0] || {}\n\n    if data.type is \"template\"\n      @processTemplate(data)\n      @rerunSyncPad(data.type)\n\n    if data.type is \"component_definition\"\n      @processComponentDefinitionChange(data)\n      @processJavascriptChange(data)\n      \n      _.delay ()=>\n        @rerunSyncPad(data.type)\n      , 25\n\n    if data.type is \"javascript\"\n      @processJavascriptChange(data)\n\n    if data.type is \"stylesheet\" and data?.path\n      @processStylesheetChange(data)\n\n  rerunSyncPad: ()->\n    if last = @get(\"last_syncpad_javascript_payload\")\n      @processJavascriptChange(last)\n\n  processTemplate: (change={})->\n    fn = ()->\n      eval( change.contents )\n\n    fn.apply(window)\n\n  processComponentDefinitionChange: (change={})->\n    return if _.isEmpty(change)\n    @components ||= Luca.collections.Components.generate() \n\n    if change.class_name? \n      component = @components.findByClassName( change.class_name )\n\n      if component && change.source_file_contents?\n        component.set(source_file_contents: change.source_file_contents )\n\n  processJavascriptChange: (change={})->\n    return unless change?.compiled\n    existing = $(\"body script[data-path='#{ change.source }']\")\n\n    # just to be clean\n    if existing.length > 1\n      existing.remove()\n\n    if change.source?.match(/syncpad/) and change?.compiled and true\n      @set(\"last_syncpad_javascript_payload\", change)\n\n    script = @make(\"script\", {\"data-path\": change.source, type:\"text/javascript\"}, change.compiled)\n    $('body').append(script)\n\n  processStylesheetChange: (change={})->\n    return if _.isEmpty(change)\n\n    if change.path?.match(/syncpad/) or @styleSheetMode is \"single\"\n      @syncStylesheet(change)\n    else\n      @replaceStylesheetAndEverythingAfter(change.path)\n\n  replaceStylesheetAndEverythingAfter: (path)->\n    stylesheet  = path.replace('./app/assets/stylesheets', Luca.config.assetsUrlPrefix )\n    stylesheet  = stylesheet.replace('.scss','')\n    existing    = $(\"link[href*='#{ stylesheet }']\")\n    parent      = existing.parent()\n\n    return unless existing.length > 0\n\n    replaced = existing.clone()\n    comesAfter = existing.nextAll('link')\n    cloned = comesAfter.clone()\n\n    $(existing, comesAfter).remove()\n\n    parent.append( replaced )\n    parent.append( cloned )\n\n  syncStylesheet: (change)->\n    existing = $(\"head style[data-file='#{ change.path }']\")\n\n    if existing.length > 0\n      existing.remove()\n\n    if change.compiled? or change.contents?\n      link = @make(\"style\",{\"data-file\":change.path, type:\"text/css\"}, change.compiled || change.contents)\n      $('head').append( link )\n\ncodeManager.defines\n  make: Luca.View::make"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/development/component.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/development/component.coffee","type":"component_definition","starts_on_line":1,"class_name":"Luca.models.Component","header_documentation":"","type_alias":"component","css_class_identifier":"","defines_methods":{"documentation":{"defined_on_line":15,"documentation":"","arguments":[]},"documentationFor":{"defined_on_line":28,"documentation":"","arguments":[{"argument":"methodOrPropertyGroup","value":"\"publicMethods\""}]},"url":{"defined_on_line":41,"documentation":"","arguments":[]},"metaData":{"defined_on_line":44,"documentation":"","arguments":[]},"classNameId":{"defined_on_line":47,"documentation":"","arguments":[]},"componentGroup":{"defined_on_line":50,"documentation":"","arguments":[]},"componentType":{"defined_on_line":54,"documentation":"","arguments":[]},"componentTypeAlias":{"defined_on_line":73,"documentation":"","arguments":[]}},"defines_properties":{"defaults":{"defined_on_line":5,"documentation":"","default":null},"idAttribute":{"defined_on_line":13,"documentation":"","default":"\"class_name\""}},"source_file_contents":"model = Luca.register  \"Luca.models.Component\"\nmodel.extends           \"Luca.Model\"\n\nmodel.configuration\n  defaults:\n    class_name: undefined\n    superClass: undefined\n    asset_id: undefined\n    source_file_contents: \"\"\n    defined_in_file: \"\"\n\nmodel.defines\n  idAttribute: \"class_name\"\n  \n  documentation: ()->\n    base = _( @toJSON() ).pick 'header_documentation', 'class_name', 'defined_in_file'\n\n    _.extend base, @metaData(), \n      componentGroup: @componentGroup() \n      componentType: @componentType() \n      componentTypeAlias: @componentTypeAlias()\n      details:\n        publicMethods:        @documentationFor(\"publicMethods\")\n        privateMethods:       @documentationFor(\"privateMethods\")\n        privateProperties:    @documentationFor(\"privateProperties\")\n        publicProperties:     @documentationFor(\"publicProperties\")\n\n  documentationFor: (methodOrPropertyGroup=\"publicMethods\")->\n    documentationSource = _.extend({}, @get(\"defines_methods\"), @get(\"defines_properties\"))\n\n    result = {}\n\n    if list = @metaData()?[ methodOrPropertyGroup ]?()\n      _(list).reduce (memo, methodOrProperty)->\n        memo[ methodOrProperty ] = documentationSource[ methodOrProperty ]\n        memo\n      , result  \n\n    result\n\n  url: ()->\n    \"/project/components/#{ Luca.namespace }/#{ @classNameId() }\"\n\n  metaData: ()->\n    Luca( @get(\"class_name\") ).prototype.componentMetaData()\n\n  classNameId: ()->\n    @get(\"class_name\").replace(/\\./g,'__')\n\n  componentGroup: ()->\n    parts = @get('class_name').split('.')\n    parts.slice(0,2).join('.')\n\n  componentType: ()->\n    type  = \"view\"\n    parts = @get('class_name').split('.')\n\n    switch group = parts[1]\n      when \"collections\" then \"collection\"\n      when \"models\" then \"model\"\n      when (\"views\" || \"components\" || \"pages\") then \"view\"\n\n    return if group?\n\n    if componentPrototype = Luca.util.resolve( @get(\"class_name\") )\n      return \"view\" if Luca.isViewPrototype( componentPrototype:: )\n      return \"collection\" if Luca.isCollectionPrototype( componentPrototype:: )\n      return \"model\" if Luca.isModelProtoype( componentPrototype:: )\n\n    # meh, but what about Router?\n    \"view\"\n\n  componentTypeAlias: ()->\n    parts = @get('class_name').split('.')\n    name = parts.pop()\n    _.str.underscored( name )\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/development/components.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/development/components.coffee","type":"component_definition","starts_on_line":1,"class_name":"Luca.collections.Components","header_documentation":"","type_alias":"components","css_class_identifier":"","defines_methods":{"generate":{"defined_on_line":9,"documentation":"","arguments":[]},"findByClassName":{"defined_on_line":15,"documentation":"","arguments":[{"argument":"class_name","value":null}]},"filterByNamespace":{"defined_on_line":19,"documentation":"","arguments":[{"argument":"namespace","value":null}]},"classNames":{"defined_on_line":23,"documentation":"","arguments":[]},"groupsInsideOf":{"defined_on_line":26,"documentation":"","arguments":[{"argument":"namespace","value":null}]},"namespaces":{"defined_on_line":36,"documentation":"","arguments":[]},"fetch":{"defined_on_line":42,"documentation":"","arguments":[{"argument":"options","value":"{}"}]},"comparator":{"defined_on_line":45,"documentation":"","arguments":[{"argument":"model","value":null}]},"populateFromRegistry":{"defined_on_line":48,"documentation":"","arguments":[{"argument":"options","value":"{}"}]}},"defines_properties":{"model":{"defined_on_line":5,"documentation":"","default":"Luca.models.Component"},"namespace":{"defined_on_line":6,"documentation":"","default":"\"components\""}},"source_file_contents":"components = Luca.register   \"Luca.collections.Components\"\ncomponents.extends            \"Luca.Collection\"\n\ncomponents.configuration\n  model: Luca.models.Component\n  namespace: \"components\"\n\ncomponents.classMethods\n  generate: ()->\n    @collection = new Luca.collections.Components()\n    @collection.fetch()\n    @collection\n\ncomponents.defines\n  findByClassName: (class_name)->\n    @detect (model)->\n      model.get(\"class_name\") is class_name\n        \n  filterByNamespace: (namespace)->\n    @query\n      class_name: $like: namespace\n\n  classNames: ()->\n    @pluck('class_name')\n\n  groupsInsideOf: (namespace)->\n    classes = @filterByNamespace(namespace)\n    unique = {}\n    \n    for component in classes when not unique[ component.componentGroup() ]?\n      if component.get(\"class_name\")?.split('.')?.length > 2\n        unique[ component.componentGroup() ] = component.componentGroup().split('.')[1] \n\n    _.values(unique)\n\n  namespaces: ()->\n    list = _( @classNames() ).map (className)->\n      className.split('.')[0]\n\n    _( list ).uniq()\n\n  fetch: (options={})->\n    @populateFromRegistry(options)\n\n  comparator: (model)->\n    model.get(\"class_name\")\n      \n  populateFromRegistry: (options={})->\n    registeredClassNames = for class_name in Luca.registry.classes(true)\n      {class_name, name: class_name}\n\n    if options.namespace\n      registeredClassNames = for model in registeredClassNames when model.name.match(options.namespace)\n        model\n\n      \n    @reset(registeredClassNames, options={})\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/development/console.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/development/console.coffee","type":"component_definition","starts_on_line":1,"class_name":"Luca.tools.DevelopmentConsole","header_documentation":"","type_alias":"development_console","css_class_identifier":"luca-tools-development-console","defines_methods":{"afterRender":{"defined_on_line":59,"documentation":"","arguments":[]},"show":{"defined_on_line":66,"documentation":"","arguments":[{"argument":"options","value":"{}"}]},"getContext":{"defined_on_line":70,"documentation":"","arguments":[]},"initialize":{"defined_on_line":73,"documentation":"","arguments":[]},"saveHistory":{"defined_on_line":77,"documentation":"","arguments":[{"argument":"command","value":null}]},"historyUp":{"defined_on_line":81,"documentation":"","arguments":[]},"historyDown":{"defined_on_line":88,"documentation":"","arguments":[]},"append":{"defined_on_line":96,"documentation":"","arguments":[{"argument":"code","value":null},{"argument":"result","value":null},{"argument":"skipFormatting","value":"false"}]},"onSuccess":{"defined_on_line":110,"documentation":"","arguments":[{"argument":"result","value":null},{"argument":"js","value":null},{"argument":"coffee","value":null}]},"onError":{"defined_on_line":122,"documentation":"","arguments":[{"argument":"error","value":null},{"argument":"js","value":null},{"argument":"coffee","value":null}]},"evaluateCode":{"defined_on_line":125,"documentation":"","arguments":[{"argument":"code","value":null},{"argument":"raw","value":null}]},"runCommand":{"defined_on_line":165,"documentation":"","arguments":[]}},"defines_properties":{"className":{"defined_on_line":6,"documentation":"","default":"\"luca-ui-console\""},"name":{"defined_on_line":7,"documentation":"","default":"\"console\""},"history":{"defined_on_line":8,"documentation":"","default":"[]"},"historyIndex":{"defined_on_line":9,"documentation":"","default":"0"},"width":{"defined_on_line":10,"documentation":"","default":"1000"},"componentEvents":{"defined_on_line":12,"documentation":"","default":null},"compileOptions":{"defined_on_line":17,"documentation":"","default":null},"components":{"defined_on_line":20,"documentation":"","default":"["}},"source_file_contents":"developmentConsole = Luca.register    \"Luca.tools.DevelopmentConsole\"\n\ndevelopmentConsole.extends            \"Luca.Container\"\n\ndevelopmentConsole.defines\n  className: \"luca-ui-console\"\n  name: \"console\"\n  history: []\n  historyIndex: 0\n  width: 1000\n\n  componentEvents:\n    \"input key:keyup\"    : \"historyUp\"\n    \"input key:keydown\"  : \"historyDown\"\n    \"input key:enter\"    : \"runCommand\"\n\n  compileOptions:\n    bare: true\n\n  components:[\n    type: \"code_mirror_field\"\n    role: \"code_mirror\"\n    additionalClassNames: \"clearfix\"\n    name: \"code_output\"\n    readOnly: true\n    lineNumbers: false\n    mode: \"javascript\"\n    lineWrapping: true\n    gutter: false\n  ,\n    type: \"text_field\"\n    name: \"code_input\"\n    role: \"input\"\n    lineNumbers: false\n    height: '30px'\n    maxHeight: '30px'\n    gutter: false\n    autoBindEventHandlers: true\n    hideLabel: true\n    prepend: \"Coffee>\"\n    events:\n      \"keypress input\" : \"onKeyEvent\"\n      \"keydown input\" : \"onKeyEvent\"\n\n    onKeyEvent: (keyEvent)->\n      if keyEvent.type is \"keypress\" and keyEvent.keyCode is Luca.keys.ENTER\n        @trigger(\"key:enter\", @getValue())\n\n      if keyEvent.type is \"keydown\" and keyEvent.keyCode is Luca.keys.KEYUP\n        @trigger(\"key:keyup\")\n\n      if keyEvent.type is \"keydown\" and keyEvent.keyCode is Luca.keys.KEYDOWN\n        @trigger(\"key:keydown\")\n\n    afterRender: ()->\n      @$('input').focus()\n  ]\n\n  afterRender: ()->\n    @$container().modal(backdrop: false)\n\n    if @width?\n      marginLeft = parseInt(@width) * 0.5 * -1\n      @$container().css(\"width\", @width).css('margin-left', parseInt(marginLeft) )\n\n  show: (options={})->\n    @$container().modal('show')\n    @\n\n  getContext: ()->\n    window\n\n  initialize: ()->\n    @_super(\"initialize\", @, arguments)\n    _.bindAll @, \"historyUp\", \"historyDown\", \"onSuccess\", \"onError\", \"runCommand\"\n\n  saveHistory: (command)->\n    @history.push( command ) if command?.length > 0\n    @historyIndex = 0\n\n  historyUp: ()->\n    @historyIndex -= 1\n    @historyIndex = 0 if @historyIndex < 0\n\n    currentValue = @getInput().getValue()\n    @getInput().setValue( @history[ @historyIndex ] || currentValue )\n\n  historyDown: ()->\n    @historyIndex += 1\n    @historyIndex = @history.length - 1 if @historyIndex > @history.length - 1\n\n    currentValue = @getInput().getValue()\n\n    @getInput().setValue( @history[ @historyIndex ] || currentValue)\n\n  append: (code, result, skipFormatting=false)->\n    output = @getCodeMirror()\n    current = output.getValue()\n\n    source = \"// #{ code }\" if code?\n\n    payload = if skipFormatting or code.match(/^console\\.log/)\n      [current,result]\n    else\n      [current,source, result]\n\n    output.setValue( _.compact(payload).join(\"\\n\") )\n    output.getCodeMirror().scrollTo(0,90000)\n\n  onSuccess: (result, js, coffee)->\n    @saveHistory(coffee)\n\n    dump = \"\"\n\n    if _.isArray( result ) or _.isObject( result ) or _.isString( result ) or _.isNumber(result)\n      dump = JSON.stringify(result, null, \"\\t\")\n\n    dump ||= result.toString?()\n\n    @append(js, dump || \"undefined\")\n\n  onError: (error, js, coffee)->\n    @append(js, \"// ERROR: #{ error.message }\")\n\n  evaluateCode: (code, raw)->\n    return unless code?.length > 0\n\n    raw = _.string.strip(raw)\n    output = @getCodeMirror()\n    dev = @\n\n    evaluator = ()->\n      old_console = window.console\n\n      console =\n        log: ()->\n          for arg in arguments\n            dev.append(undefined, arg, true)\n\n      log = console.log\n\n      try\n        result = eval( code )\n      catch error\n        window.console = old_console\n        throw(error)\n\n      window.console = old_console\n\n      result\n\n    try\n      result = evaluator.call( @getContext() )\n\n      # capture luca objects for special inspection \n      if Luca.isComponent( result )\n        result = Luca.util.inspectComponent( result )\n      else if Luca.isComponentPrototype( result )\n        result = Luca.util.inspectComponentPrototype( result )\n\n      @onSuccess(result, code, raw) unless raw.match(/^console\\.log/)\n    catch error\n      @onError(error, code, raw)\n\n  runCommand: ()->\n    dev     = @\n    compile = _.bind(Luca.tools.CoffeeEditor::compile, @)\n    raw = @getInput().getValue()\n    compiled = compile raw, (compiled)->\n      dev.evaluateCode(compiled, raw)\n\nLuca.util.launchers ||= {}\n\nLuca.util.inspectComponentPrototype = (componentPrototype)->\n  liveInstances = Luca.registry.findInstancesByClass( componentPrototype )\n\nLuca.util.inspectComponent = (component)->\n  component = Luca(component) if _.isString(component)\n\n  {\n    name:         component.name  \n    instanceOf:   component.displayName \n    subclassOf:   component._superClass()::displayName\n    inheritsFrom: Luca.parentClasses( component )\n  }\n\nLuca.util.launchers.developmentConsole = (name=\"luca-development-console\")->\n  @_lucaDevConsole = Luca name, ()=>\n    @$el.append Luca.View::make(\"div\", id: \"#{ name }-wrapper\", class: \"modal fade large\")\n\n    dconsole = new Luca.tools.DevelopmentConsole\n      name: name\n      container: \"##{ name }-wrapper\"\n\n    dconsole.render()\n    dconsole.getCodeMirror().setHeight(602)\n\n  @_lucaDevConsole.show()\n  Luca(name)\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/managers/socket_manager.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/managers/socket_manager.coffee","type":"component_definition","starts_on_line":8,"class_name":"Luca.SocketManager","header_documentation":"<p>The SocketManager provides communication between a Websocket / Pubsub\nsystem and routes messages through the application to instances\nof a specific view, model, collection, or other Backbone.Events object. \nYou will need to create the socket manager specifying your provider and host:\n      @socket = new Luca.SocketManager(host:&quot;//localhost:9292/faye&quot;)</p>\n","type_alias":"socket_manager","css_class_identifier":"","defines_methods":{"initialize":{"defined_on_line":24,"documentation":"","arguments":[{"argument":"@attributes","value":"{}"}]},"isReady":{"defined_on_line":50,"documentation":"<p>The socket manager is ready once &#39;ready&#39; event has been\ntriggered on it.  ( usually by the application ). and once\nthe provider client library as been loaded.</p>\n","arguments":[]},"providerLibraryIsAvailable":{"defined_on_line":53,"documentation":"","arguments":[]},"connect":{"defined_on_line":62,"documentation":"","arguments":[]},"providerSourceLoaded":{"defined_on_line":70,"documentation":"","arguments":[]},"providerSourceUrl":{"defined_on_line":73,"documentation":"","arguments":[]},"loadProviderSource":{"defined_on_line":78,"documentation":"","arguments":[]}},"defines_properties":{"defaults":{"defined_on_line":18,"documentation":"<p>The SocketManager can be configured with the following options:</p>\n\n<p>autoStart: default(true) immediately begins to load the provider\nscript, setup the connection, etc</p>\n\n<p>provider: faye.js or socket.io</p>\n","default":null}},"source_file_contents":"# The SocketManager provides communication between a Websocket / Pubsub\n# system and routes messages through the application to instances\n# of a specific view, model, collection, or other Backbone.Events object. \n#\n# You will need to create the socket manager specifying your provider and host:\n#       @socket = new Luca.SocketManager(host:\"//localhost:9292/faye\")\n#\nsocketManager = Luca.register \"Luca.SocketManager\"\nsocketManager.extends         \"Luca.Model\"\n\nsocketManager.defines\n  # The SocketManager can be configured with the following options:\n  #\n  # autoStart: default(true) immediately begins to load the provider\n  # script, setup the connection, etc\n  #\n  # provider: faye.js or socket.io\n  defaults:\n    autoStart: true  \n    providerAvailable: false\n    ready: false\n    provider: \"faye.js\"\n\n  initialize: (@attributes={})->\n    unless @providerLibraryIsAvailable()\n      @loadProviderSource() \n\n    Luca.Model::initialize?.apply(@, arguments)\n\n    model = @\n\n    connectOnReady = ()=> \n      @connect() if @isReady()\n\n    model.on \"change:ready\", ()->\n      connectOnReady()\n      model.unbind(\"change:ready\", @)\n\n    model.on \"change:providerAvailable\", ()->\n      connectOnReady()\n      model.unbind(\"change:ready\", @)\n\n    @on \"ready\", _.once ()=> @set('ready', true)\n\n    @trigger \"change\"\n\n  # The socket manager is ready once 'ready' event has been\n  # triggered on it.  ( usually by the application ). and once\n  # the provider client library as been loaded.\n  isReady: ()->\n    @get(\"ready\") is true and @get(\"providerAvailable\") is true\n\n  providerLibraryIsAvailable: ()->\n    providerTest = switch @get('provider')\n      when \"socket.io\"\n        \"io\"\n      when \"faye.js\"\n        \"Faye.Client\"\n\n    !!(Luca.util.resolve(providerTest)?)\n\n  connect: ()->\n    switch @get('provider')\n      when \"socket.io\"\n        @client = io.connect( @get('host') )\n      when \"faye.js\"\n        @client = new Faye.Client(@get('host'))\n        @set(\"client\", @client)\n\n  providerSourceLoaded: ()-> \n    @set \"providerAvailable\", true\n\n  providerSourceUrl: ()->\n    switch @get('provider')\n      when \"socket.io\" then \"#{  @get('host')  }/socket.io/socket.io.js\"\n      when \"faye.js\" then \"#{  @get('host')  }/faye.js\"\n\n  loadProviderSource: ()->\n    script = document.createElement 'script'\n    script.setAttribute \"type\", \"text/javascript\"\n    script.setAttribute \"src\", @providerSourceUrl()\n    script.onload = _.bind(@providerSourceLoaded,@)\n\n    if Luca.util.isIE()\n      script.onreadystatechange = ()=>\n        if script.readyState is \"loaded\"\n          @providerSourceLoaded()\n\n    document.getElementsByTagName('head')[0].appendChild script\n"}];
