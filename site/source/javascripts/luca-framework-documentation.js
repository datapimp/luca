window.Luca = window.Luca || {}; window.Luca.documentation = [{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/application.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/application.coffee","type":"component_definition","class_name":"Luca.Application","header_documentation":"<p>The <code>Luca.Application</code> is the main entry point into your Application.\nIt acts as a global state machine, page controller, and router, in addition\nto providing access to other singletons such as the CollectionManager, and SocketManager.</p>\n\n<p>The structure of a common <code>Luca.Application</code> is that it contains one or many <code>Pages</code> which\nthemselves are made up of the components of your application.  One <code>Page</code> is visible at a time\nand which page is displayed is managed by an instance of the <code>Luca.components.Controller</code> class.</p>\n\n<h3>Example Configuration</h3>\n\n<pre><code>application = Luca.register     &quot;App.Application&quot;\napplication.extends             &quot;Luca.Application&quot;\napplication.defines\n  name: &quot;MyApplication&quot;\n  routes: \n    &quot;&quot; : &quot;home&quot;\n    &quot;standard/backbone/style/:route&quot; : &quot;name_of_page#name_of_method&quot;\n  components:[\n    name: &quot;home&quot;\n  ,\n    type: &quot;your_view&quot;\n    name: &quot;name_of_page&quot;\n    name_of_method: (routeParam)-&gt;\n      @doSomethignToSetupYourPageWithThePassed(routeParam)  \n  ]\n</code></pre>\n\n<p>App.onReady ()-&gt;\n    window.MyApp = new App.Application();\n    window.MyApp.boot() </p>\n\n<h4>@routes and pages</h4>\n\n<p>In the above example, our application contains two pages, one with the name &#39;home&#39;\nand one with the name &#39;name<em>of</em>page&#39;.  It also specifies a <code>@routes</code> property which\nis identical to the configuration you would see in a standard <code>Backbone.Router</code>.\nWhenever the route matches &#39;standard/backbone/style/route&#39; the <code>App.Application</code> instance\nwill send an instruction to the <code>Luca.components.Controller</code> to <code>activate</code> the page whose name\nis passed in the <code>@routes</code> config.</p>\n\n<p>If that page defines a method called <code>@routeHandler</code> it will be called with the parameters\nfrom the route.  In the <code>@routes</code> config you can specify your own route handler method\nby using the rails style <code>page_name#action</code> and it will call the <code>@action</code> method instead\non the view named <code>page_name</code>.\nThe <code>App.Application</code> instance, also accessible by <code>window.MyApp</code>, or through the helper <code>App()</code>\nor <code>Luca.getApplication()</code> maintains the state of which page is active.  You can access this\nin your code by calling <code>App().activePage()</code>.</p>\n\n<h4>Controllers</h4>\n\n<p>The <code>Luca.components.Controller</code> is a special type of component which contains \nother views, or <code>Pages</code> which only one will be visible at any given time.  It expects\nthat each page will have its own unique <code>@name</code> property.  A <code>Luca.components.Controller</code> can\ncontain other controllers, providing you with a way of structuring your application layout\nin an organized, hierarchal fashion. \nBy default, any <code>Luca.Application</code> will have one <code>Luca.components.Controller</code> automatically\ncreated named &#39;main_controller&#39; which is accessible by <code>MyApp.getMainController()</code>.  Any\ncomponents you define on the <code>Luca.Application</code> instance will be wrapped by the main controller\nautomatically unless you specify <code>@useController = false</code> in your Application component definition.</p>\n","type_alias":"application","css_class_identifier":"luca-application","defines_methods":{"initialize":{"defined_on_line":173,"documentation":"<p>Don&#39;t create getters on this component\nfor the nested components</p>\n","arguments":[{"argument":"@options","value":"{}"}]},"activeView":{"defined_on_line":243,"documentation":"<p>@activeView() returns a reference to the instance of the view\nwhich is currently monopolizing the viewport.  In an application\nwhich uses a controller hierarchy, it will be the last controller\nhas activated one of its pages.</p>\n","arguments":[]},"activeSection":{"defined_on_line":250,"documentation":"<p>Returns the name of the active component on the main controller</p>\n","arguments":[]},"activeSubSection":{"defined_on_line":256,"documentation":"<p>Returns the name of the active component on the nested controllers\non the main controller, if there is one.  These get set on the\nstate machine in response to card switch events on the controller component</p>\n","arguments":[]},"activePages":{"defined_on_line":259,"documentation":"","arguments":[]},"boot":{"defined_on_line":270,"documentation":"<p>boot should trigger the ready event, which will call the initial call\nto render() your application, which will have a cascading effect on every\nsubcomponent in the view, recursively rendering everything which is set\nto automatically render (i.e. any non-deferrable components ).</p>\n\n<p>you should use boot to fire up any dependent collections, manager, any\nsort of data processing, whatever your application requires to run outside\nof the views</p>\n","arguments":[]},"collection":{"defined_on_line":277,"documentation":"<p>delegate to the collection manager&#39;s get or create function.\nuse App.collection() to create or access existing collections</p>\n","arguments":[]},"get":{"defined_on_line":280,"documentation":"","arguments":[{"argument":"attribute","value":null}]},"set":{"defined_on_line":283,"documentation":"","arguments":[{"argument":"attribute","value":null},{"argument":"value","value":null},{"argument":"options","value":null}]},"view":{"defined_on_line":286,"documentation":"","arguments":[{"argument":"name","value":null}]},"navigate_to":{"defined_on_line":292,"documentation":"<h3>Navigation Hooks</h3>\n\n<p>delegate to the main controller so that we can switch the active section</p>\n","arguments":[{"argument":"component_name","value":null},{"argument":"callback","value":null}]},"keyHandler":{"defined_on_line":296,"documentation":"","arguments":[{"argument":"e","value":null}]},"setupControllerBindings":{"defined_on_line":321,"documentation":"","arguments":[]},"setupMainController":{"defined_on_line":338,"documentation":"","arguments":[]},"setupCollectionManager":{"defined_on_line":357,"documentation":"","arguments":[]},"setupSocketManager":{"defined_on_line":391,"documentation":"","arguments":[]},"setupRouter":{"defined_on_line":397,"documentation":"","arguments":[]},"setupKeyHandler":{"defined_on_line":427,"documentation":"","arguments":[]},"pageHierarchy":{"defined_on_line":445,"documentation":"<p>Public: For purely informational purposes, describes the structure\nof the Application&#39;s controller views, and any of their nested controllers views.</p>\n","arguments":[]},"registerInstance":{"defined_on_line":464,"documentation":"<p>Private: registers the instance of the Luca.Appliction\nso that it is available via the Luca() helper, or through\na call to Luca.Application.get()</p>\n","arguments":[{"argument":"app","value":null}]},"checkForKeymaster":{"defined_on_line":474,"documentation":"<p>The following special keys can be used for shortcuts:\n<code>backspace</code>, <code>tab</code>, <code>clear</code>, <code>enter</code>, <code>return</code>, <code>esc</code>, <code>escape</code>, <code>space</code>,\n<code>up</code>, <code>down</code>, <code>left</code>, <code>right</code>, <code>home</code>, <code>end</code>, <code>pageup</code>, <code>pagedown</code>, <code>del</code>, <code>delete</code>\nand <code>f1</code> through <code>f19</code>.</p>\n","arguments":[]},"routeTo":{"defined_on_line":489,"documentation":"<p>Private: Recursively navigates down the controller page hierarchy\nto the page you specify by name.  You can specify the\nmethod which is to be called at the end of the chain.</p>\n\n<p>This is used internally by the Application as it sets up\nthe @routes property and uses it to configure the Luca.Router\ninstance for your app.</p>\n","arguments":[{"argument":"pages...","value":null}]},"startHistory":{"defined_on_line":533,"documentation":"<p>Public: you can override Luca.Application.startHistory to\nmodify how Backbone.history.start is called.  This will get called\nby the Application instance in response to the @autoStartHistory property.</p>\n","arguments":[]}},"defines_properties":{"name":{"defined_on_line":70,"documentation":"","default":""},"autoBoot":{"defined_on_line":81,"documentation":"<p>if autoBoot is set to true, the application will\nattempt to boot on document ready.</p>\n","default":""},"autoStartHistory":{"defined_on_line":87,"documentation":"<p>automatically starts the @router if it exists,\nonce the components for the application have\nbeen created.  Pass the event name you want to\nlisten for on this component before you start history</p>\n","default":""},"pushState":{"defined_on_line":90,"documentation":"<p>use Backbone.history push state?</p>\n","default":""},"useCollectionManager":{"defined_on_line":94,"documentation":"<p>we will create a collection manager singleton\nby default unless otherwise specified.</p>\n","default":""},"collectionManagerClass":{"defined_on_line":103,"documentation":"<p>by default we will use the standard collection manager which ships with\nLuca.  If you would like to use your own extension of the collection manager\njust pass a reference to the class you would like to use.</p>\n","default":""},"plugin":{"defined_on_line":108,"documentation":"<p>Luca plugin apps are apps which mount onto existing\nluca apps, and will not have the behavior of a main\napp which acts as a singleton</p>\n","default":""},"useController":{"defined_on_line":114,"documentation":"<p>by default, the application will use a controller\ncomponent, which is a card view container which shows\none view at a time.  this is useful for having an application\nwith several &#39;pages&#39; so to speak</p>\n","default":""},"mainControllerContainer":{"defined_on_line":120,"documentation":"<p>if you have special rendering requirements for\nthe application&#39;s components, you can assign the\nspecific element you want to render the container\nto inside of the #viewport</p>\n","default":""},"useKeyHandler":{"defined_on_line":128,"documentation":"<p>Key Handler</p>\n\n<p>One responsibility of the application, since it is a viewport which monopolizes the entire screen\nis to relay keypress events from the document, to whatever views are interested in responding to them.</p>\n\n<p>This functionality is disabled by default.</p>\n","default":""},"createRoleBasedGetters":{"defined_on_line":163,"documentation":"<p>create getter methods for the various\nroles in the application&#39;s components on the\napplication itself.  false by default.</p>\n","default":""},"useSocketManager":{"defined_on_line":168,"documentation":"<p>create an instance of Luca.SocketManager\nwhich is a Backbone.Events style abstraction that\nsits on top of services like faye, or socket.io</p>\n","default":""}},"source_file_contents":"# The `Luca.Application` is the main entry point into your Application.\n# It acts as a global state machine, page controller, and router, in addition\n# to providing access to other singletons such as the CollectionManager, and SocketManager.\n# \n# The structure of a common `Luca.Application` is that it contains one or many `Pages` which\n# themselves are made up of the components of your application.  One `Page` is visible at a time\n# and which page is displayed is managed by an instance of the `Luca.components.Controller` class.\n#\n# ### Example Configuration  \n#     application = Luca.register     \"App.Application\"\n#     application.extends             \"Luca.Application\"\n#\n#     application.defines\n#       name: \"MyApplication\"\n#       routes: \n#         \"\" : \"home\"\n#         \"standard/backbone/style/:route\" : \"name_of_page#name_of_method\"\n#\n#       components:[\n#         name: \"home\"\n#       ,\n#         type: \"your_view\"\n#         name: \"name_of_page\"\n#         name_of_method: (routeParam)->\n#           @doSomethignToSetupYourPageWithThePassed(routeParam)  \n#       ]\n#\n#   App.onReady ()->\n#     window.MyApp = new App.Application();\n#     window.MyApp.boot() \n#\n# #### @routes and pages\n#\n# In the above example, our application contains two pages, one with the name 'home'\n# and one with the name 'name_of_page'.  It also specifies a `@routes` property which\n# is identical to the configuration you would see in a standard `Backbone.Router`.\n#\n# Whenever the route matches 'standard/backbone/style/route' the `App.Application` instance\n# will send an instruction to the `Luca.components.Controller` to `activate` the page whose name\n# is passed in the `@routes` config.\n# \n# If that page defines a method called `@routeHandler` it will be called with the parameters\n# from the route.  In the `@routes` config you can specify your own route handler method\n# by using the rails style `page_name#action` and it will call the `@action` method instead\n# on the view named `page_name`.\n#\n# The `App.Application` instance, also accessible by `window.MyApp`, or through the helper `App()`\n# or `Luca.getApplication()` maintains the state of which page is active.  You can access this\n# in your code by calling `App().activePage()`.\n#\n# #### Controllers\n# \n# The `Luca.components.Controller` is a special type of component which contains \n# other views, or `Pages` which only one will be visible at any given time.  It expects\n# that each page will have its own unique `@name` property.  A `Luca.components.Controller` can\n# contain other controllers, providing you with a way of structuring your application layout\n# in an organized, hierarchal fashion. \n#\n# By default, any `Luca.Application` will have one `Luca.components.Controller` automatically\n# created named 'main_controller' which is accessible by `MyApp.getMainController()`.  Any\n# components you define on the `Luca.Application` instance will be wrapped by the main controller\n# automatically unless you specify `@useController = false` in your Application component definition.\napplication = Luca.register       \"Luca.Application\"\napplication.extends               \"Luca.containers.Viewport\"\n\napplication.triggers              \"controller:change\",\n                                  \"action:change\"\n\napplication.publicConfiguration\n  name: \"MyApp\"\n\n  # The Application uses a Backbone.Model as a state machine, which\n  # allows you to get / set attributes, persist them somewhere, and\n  # most importantly to bind to change events of certain attributes.\n  #\n  # the @defaultState property will be the default attributes\n  stateful: {}\n\n  # if autoBoot is set to true, the application will\n  # attempt to boot on document ready.\n  autoBoot: false\n\n  # automatically starts the @router if it exists,\n  # once the components for the application have\n  # been created.  Pass the event name you want to\n  # listen for on this component before you start history\n  autoStartHistory: \"before:render\"\n\n  # use Backbone.history push state?\n  pushState: false\n  \n  # we will create a collection manager singleton\n  # by default unless otherwise specified.\n  useCollectionManager: true\n\n  # to pass options to the collection manager, set the @collectionManager\n  # hash which will get passed once the collection manager is created\n  collectionManager: {}\n\n  # by default we will use the standard collection manager which ships with\n  # Luca.  If you would like to use your own extension of the collection manager\n  # just pass a reference to the class you would like to use.\n  collectionManagerClass: \"Luca.CollectionManager\"\n\n  # Luca plugin apps are apps which mount onto existing\n  # luca apps, and will not have the behavior of a main\n  # app which acts as a singleton\n  plugin: false\n\n  # by default, the application will use a controller\n  # component, which is a card view container which shows\n  # one view at a time.  this is useful for having an application\n  # with several 'pages' so to speak\n  useController: true\n\n  # if you have special rendering requirements for\n  # the application's components, you can assign the\n  # specific element you want to render the container\n  # to inside of the #viewport\n  mainControllerContainer: undefined\n\n  # Key Handler\n  #\n  # One responsibility of the application, since it is a viewport which monopolizes the entire screen\n  # is to relay keypress events from the document, to whatever views are interested in responding to them.\n  #\n  # This functionality is disabled by default.\n  useKeyHandler: false\n\n  # You can configure key events by specifying them by their name, as it exists in Luca.keyMap. For example:\n\n  # keyEvents understands the following modifiers:\n  # `\u21e7`, `shift`, `option`, `\u2325`, `alt`, `ctrl`, `control`, `command`, and `\u2318`.\n\n  # The following special keys can be used for shortcuts:\n  # `backspace`, `tab`, `clear`, `enter`, `return`, `esc`, `escape`, `space`,\n  # `up`, `down`, `left`, `right`, `home`, `end`, `pageup`, `pagedown`, `del`, `delete`\n  # and `f1` through `f19`.\n  #\n  # Example:\n  # ```coffeescript\n  #   application.configuration\n  #     keyEvents:\n  #       '\u2318+r, ctrl+r': \"keyHandlerFunction\"\n  #     keyHandlerFunction: -> alert 'something + r was pressed'\n  # ```\n  keyEvents: {}\n\n  # applications have one component, the controller.\n  # any components defined on the application class directly\n  # will get wrapped by the main controller unless you\n  # set useController = false\n  components:[\n    type: 'template'\n    name: 'welcome'\n    template: 'sample/welcome'\n    templateContainer: \"Luca.templates\"\n  ]\n\n  # create getter methods for the various\n  # roles in the application's components on the\n  # application itself.  false by default.\n  createRoleBasedGetters: false\n\n  # create an instance of Luca.SocketManager\n  # which is a Backbone.Events style abstraction that\n  # sits on top of services like faye, or socket.io \n  useSocketManager: false\n  socketManagerOptions: {}\n\n  # Don't create getters on this component\n  # for the nested components\n  initialize: (@options={})->\n    app             = @\n    appName         = @name\n    alreadyRunning  = Luca.getApplication?()\n\n    Luca.Application.registerInstance(@)\n\n    Luca.concerns.StateModel.__initializer.call(@)\n\n    # The Collection Manager is responsible for managing instances \n    # of collections, usually to guarantee only a single collection is\n    # instantiated for a given resource, to maintain 'authoritative' \n    # representations of models.\n    @setupCollectionManager()\n\n    # Socket Manager provides a bridge between remote pub/sub providers and \n    # the backbone.events interface on various components in the system.\n    @setupSocketManager()\n\n    Luca.containers.Viewport::initialize.apply @, arguments\n\n    # The Controller is the piece of the application that handles showing\n    # and hiding 'pages' of the app.  The Application has a navigate_to\n    # method which delegates to the controller, and allows you to navigate\n    # to a given page, or component, by its name.  The controller integrates\n    # with the state machine of the application\n    @setupMainController() if @useController is true \n\n    # we will render when all of the various components\n    # which handle our data dependencies determine that\n    # we are ready\n    @defer(()-> app.render()).until(@, \"ready\")\n\n    # Set up the Backbone Router\n    @setupRouter()\n\n    # the keyHandler allows us to specify\n    # keyEvents on our application with an API very similar\n    # to the DOM events API for Backbone.View\n    #\n    # Example:\n    #\n    # keyEvents:\n    #   meta:\n    #     forwardslash: \"altSlashHandler\"\n    if (@useKeyHandler is true or @useKeyRouter is true) and @keyEvents?\n      @setupKeyHandler() \n\n    # if the application is a plugin designed to modify the behavior\n    # of another app, then don't claim ownership.  otherwise the most common\n    # use-case is that there will be one application instance\n    unless @plugin is true or alreadyRunning\n      Luca.getApplication = (name)=>\n        return app unless name?\n        Luca.Application.instances[ name ]\n\n    if @autoBoot\n      if Luca.util.resolve(@name)\n        throw \"Attempting to override window.#{ @name } when it already exists\"\n\n      $ ->\n        window[ appName ] = app\n        app.boot()\n\n    Luca.trigger \"application:available\", @\n\n  # @activeView() returns a reference to the instance of the view\n  # which is currently monopolizing the viewport.  In an application\n  # which uses a controller hierarchy, it will be the last controller\n  # has activated one of its pages.\n  activeView: ()->\n    if active = @activeSubSection()\n      @view( active )\n    else\n      @view( @activeSection() )\n\n  # Returns the name of the active component on the main controller\n  activeSection: ()->\n    @get(\"active_section\")\n\n  # Returns the name of the active component on the nested controllers\n  # on the main controller, if there is one.  These get set on the\n  # state machine in response to card switch events on the controller component\n  activeSubSection: ()->\n    @get(\"active_sub_section\")\n\n  activePages: ()->\n    @$('.luca-ui-controller').map (index,element)=> $(element).data('active-section')\n\n  # boot should trigger the ready event, which will call the initial call\n  # to render() your application, which will have a cascading effect on every\n  # subcomponent in the view, recursively rendering everything which is set\n  # to automatically render (i.e. any non-deferrable components ).\n  #\n  # you should use boot to fire up any dependent collections, manager, any\n  # sort of data processing, whatever your application requires to run outside\n  # of the views\n  boot: ()->\n    @trigger \"ready\"\n    for service in [@collectionManager, @socket, @router]\n      service?.trigger(\"ready\")\n\n  # delegate to the collection manager's get or create function.\n  # use App.collection() to create or access existing collections\n  collection: ()->\n    @collectionManager.getOrCreate.apply(@collectionManager, arguments)\n\n  get: (attribute)->\n    @state.get(attribute)\n\n  set: (attribute, value, options)->\n    @state.set.apply(@state, arguments)\n\n  view: (name)->\n    Luca.cache(name)\n\n  #### Navigation Hooks\n  #\n  # delegate to the main controller so that we can switch the active section\n  navigate_to: (component_name, callback)->\n    @getMainController().navigate_to(component_name, callback)\n\napplication.privateInterface\n  keyHandler: (e)->\n    return unless e and @keyEvents\n\n    isInputEvent = $(e.target).is('input') || $(e.target).is('textarea')\n\n    return if isInputEvent\n\n    keyname = Luca.keyMap[ e.keyCode ]\n\n    return unless keyname\n\n    meta = e?.metaKey is true\n    control = e?.ctrlKey is true\n\n    source = @keyEvents\n    source = if meta then @keyEvents.meta else source\n    source = if control then @keyEvents.control else source\n    source = if meta and control then @keyEvents.meta_control else source\n\n    if keyEvent = source?[keyname]\n      if @[keyEvent]? and _.isFunction(@[keyEvent])\n        @[keyEvent]?.call(@, e, keyname, keyEvent)\n      else\n        @trigger(keyEvent, e, keyname)\n\n  setupControllerBindings: ()->\n    app = @\n    # any time the main controller card switches we should track\n    # the active card on the global state chart\n    @getMainController()?.bind \"after:card:switch\", (previous,current)=>\n      @state.set(active_section:current.name)\n      app.trigger \"controller:change\", previous.name, current.name\n\n    # any time the card switches on one of the sub controllers\n    # then we should track the active sub section on the global state chart\n    @getMainController()?.each (component)=>\n      type = component.type || component.ctype\n      if type.match(/controller$/)\n        component.bind \"after:card:switch\", (previous,current)=>\n          @state.set(active_sub_section:current.name)\n          app.trigger \"action:change\", previous.name, current.name\n\n  setupMainController: ()->\n    if @useController is true\n      definedComponents = @components || []\n      base =  \n        type: 'controller'\n        name: \"main_controller\"\n        role: \"main_controller\"\n        components: definedComponents\n\n      if @mainControllerContainer?\n        _.extend(base, container: @mainControllerContainer)\n\n      @components = [base]\n    \n    @getMainController = ()=> \n      @findComponentByRole('main_controller')\n\n    @defer( @setupControllerBindings, false ).until(\"after:components\")\n\n  setupCollectionManager: ()->\n    return unless @useCollectionManager is true\n\n    return if @collectionManager? and @collectionManager?.get?\n\n    if _.isString( @collectionManagerClass )\n      @collectionManagerClass = Luca.util.resolve( @collectionManagerClass )\n\n    collectionManagerOptions = @collectionManagerOptions || {}\n\n    # if the collectionManager property is present, and it\n    # isn't a reference to a collection manager instance, then\n    # it is being used as a configuration hash for when we do create\n    # the collection manager. so let's stash it.\n    if _.isObject(@collectionManager) and not _.isFunction( @collectionManager?.get )\n      collectionManagerOptions = @collectionManager\n      @collectionManager = undefined\n\n    # if the collection manager property is a string, then it is a\n    # reference to a name of a collection manager to use.  so let's\n    # stash it\n    if _.isString(@collectionManager)\n      collectionManagerOptions =\n        name: @collectionManager\n\n\n    # let's try and get the collection manager by name if we can\n    @collectionManager = Luca.CollectionManager.get?( collectionManagerOptions.name )\n\n    # if we can't, then we will have to create one ourselves\n    unless _.isFunction(@collectionManager?.get)\n      collectionManagerOptions.autoStart = false\n      @collectionManager = new @collectionManagerClass( collectionManagerOptions )\n\n  setupSocketManager: ()->\n    return if _.isEmpty(@socketManagerOptions)\n    _.extend(@socketManagerOptions, autoStart: false)\n\n    @socket = new Luca.SocketManager(@socketManagerOptions) \n  \n  setupRouter: ()->\n    return if not @router? and not @routes?\n\n    routerClass = Luca.Router\n    routerClass = Luca.util.resolve(@router) if _.isString(@router)\n\n    routerConfig = routerClass.prototype\n    routerConfig.routes ||= {}\n    routerConfig.app = @\n\n    if _.isObject( @routes )\n      for routePattern, endpoint of @routes\n        if endpoint.match(/\\ /)\n          [page, action] = endpoint.split(' ')\n        else if endpoint.match(/\\#/)\n          [page, action] = endpoint.split('#')\n\n        fn = _.uniqueId(page)\n        routerConfig[fn] = Luca.Application.routeTo(page).action(action)\n        routerConfig.routes[ routePattern ] = fn\n\n    @router = new routerClass(routerConfig) \n\n    # if this application has a router associated with it\n    # then we need to start backbone history on a certain event.\n    # you can control which by setting the @startHistoryOn property\n    if @router and @autoStartHistory\n      @autoStartHistory = \"before:render\" if @autoStartHistory is true\n      @defer( Luca.Application.startHistory, false).until(@, @autoStartHistory)\n\n  setupKeyHandler: ()->\n    return unless @keyEvents\n\n    @keyEvents.control_meta ||= {}\n\n    # allow for both meta_control, control_meta for the combo\n    _.extend(@keyEvents.control_meta, @keyEvents.meta_control) if @keyEvents.meta_control\n\n    handler = _.bind(@keyHandler, @)\n\n    for keyEvent in (@keypressEvents || [\"keydown\"])\n      $( document ).on( keyEvent, handler )\n\napplication.classInterface\n  instances:{}\n\n  # Public: For purely informational purposes, describes the structure\n  # of the Application's controller views, and any of their nested controllers views.\n  pageHierarchy: ()->\n    app             = Luca()\n    mainController  = app.getMainController()\n\n    getTree = (node)->  \n      return {} unless node.components? or node.pages?\n\n      # recursively walks the pages on a controller\n      _( node.components || node.pages ).reduce (memo, page)->\n        memo[ page.name ] = page.name\n        memo[ page.name ] = getTree(page) if page.navigate_to?\n        memo\n      , {}\n\n    getTree( mainController )\n\n  # Private: registers the instance of the Luca.Appliction\n  # so that it is available via the Luca() helper, or through\n  # a call to Luca.Application.get()\n  registerInstance: (app)->\n    Luca.Application.instances[ app.name ] = app\n\n  # Keymaster understands the following modifiers:\n  # `\u21e7`, `shift`, `option`, `\u2325`, `alt`, `ctrl`, `control`, `command`, and `\u2318`.\n\n  # The following special keys can be used for shortcuts:\n  # `backspace`, `tab`, `clear`, `enter`, `return`, `esc`, `escape`, `space`,\n  # `up`, `down`, `left`, `right`, `home`, `end`, `pageup`, `pagedown`, `del`, `delete`\n  # and `f1` through `f19`.\n  checkForKeymaster: ()->\n    if window?.key?.noConflict\n      Luca.key = window.key.noConflict()\n\n      Luca.Application::setupKeyHandler = ()->\n        return unless @keyEvents\n        Luca.util.setupKeymaster(@keyEvents, \"all\").on(@)\n\n  # Private: Recursively navigates down the controller page hierarchy\n  # to the page you specify by name.  You can specify the \n  # method which is to be called at the end of the chain.\n  # \n  # This is used internally by the Application as it sets up\n  # the @routes property and uses it to configure the Luca.Router\n  # instance for your app.\n  routeTo: (pages...)->\n    last = _( pages ).last()\n    first = _( pages ).first()\n\n    callback = undefined    \n    specifiedAction = undefined\n\n    routeHelper = (args...)->\n      path = @app || Luca()\n      index = 0\n\n      # we can specify a page by name, and not have to know its full path\n      if pages.length is 1 and target = Luca(first)\n        pages = target.controllerPath()\n\n      # when we do know the full path\n      for page in pages when _.isString(page)\n        nextItem = pages[++index]\n        target = Luca(page)\n\n        if page is last \n          callback = if specifiedAction? and target[ specifiedAction ]?\n            _.bind(target[ specifiedAction ], target)\n          else if target.routeHandler?\n            target.routeHandler  \n\n        callback ||= if _.isFunction(nextItem)\n          _.bind(nextItem, target)\n        else if _.isObject(nextItem) \n          if action = nextItem.action and target[action]?\n            _.bind(target[action], target)\n\n        path = path.navigate_to page, ()->\n          callback?.apply(target, args)\n\n    routeHelper.action = (action)->\n      specifiedAction = action\n      routeHelper\n\n    routeHelper\n\n  # Public: you can override Luca.Application.startHistory to \n  # modify how Backbone.history.start is called.  This will get called\n  # by the Application instance in response to the @autoStartHistory property.\n  startHistory: ()->\n    Backbone.history.start(pushState: @pushState)\n\napplication.afterDefinition ()->\n  Luca.routeHelper = Luca.Application.routeTo\n  Luca.Application.checkForKeymaster()\n\napplication.register()"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/collection_loader_view.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/collection_loader_view.coffee","type":"component_definition","class_name":"Luca.components.CollectionLoaderView","header_documentation":"<p>Collection Loader View is a simple modal view\nYou can provide your own template for the collection loader modal\nif you want to. Default implementation uses twitter bootstrap modal and\nprogress bar (<a href=\"http://twitter.github.com/bootstrap/\">http://twitter.github.com/bootstrap/</a>). You template\nshould contain <code>progress</code>, <code>bar</code> and <code>message</code> classes</p>\n","type_alias":"collection_loader_view","css_class_identifier":"luca-collection-loader-view","defines_methods":{"initialize":{"defined_on_line":14,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"modalContainer":{"defined_on_line":22,"documentation":"","arguments":[]},"setupBindings":{"defined_on_line":25,"documentation":"","arguments":[]}},"defines_properties":{"className":{"defined_on_line":10,"documentation":"","default":""},"template":{"defined_on_line":12,"documentation":"","default":""}},"source_file_contents":"# Collection Loader View is a simple modal view\n# You can provide your own template for the collection loader modal\n# if you want to. Default implementation uses twitter bootstrap modal and\n# progress bar (http://twitter.github.com/bootstrap/). You template\n# should contain `progress`, `bar` and `message` classes\nloaderView = Luca.register        \"Luca.components.CollectionLoaderView\"\nloaderView.extends                \"Luca.View\"\n\nloaderView.defines\n  className: 'luca-ui-collection-loader-view'\n\n  template: \"components/collection_loader_view\"\n\n  initialize: (@options={})->\n    Luca.components.Template::initialize.apply @,arguments\n\n    @container ||= $('body')\n    @manager   ||= Luca.CollectionManager.get()\n\n    @setupBindings()\n\n  modalContainer: ()->\n    $(\"#progress-modal\", @el)\n\n  setupBindings: ()->\n    @manager.bind \"collection_loaded\", (name)=>\n      loaded   = @manager.loadedCollectionsCount()\n      total    = @manager.totalCollectionsCount()\n      progress = parseInt((loaded / total) * 100)\n      collectionName = _.string.titleize( _.string.humanize( name ) )\n\n      @modalContainer().find('.progress .bar').attr(\"style\", \"width: #{progress}%;\")\n      @modalContainer().find('.message').html(\"Loaded #{ collectionName }...\")\n\n    @manager.bind \"all_collections_loaded\", ()=>\n      @modalContainer().find('.message').html(\"All done!\")\n      _.delay ()=>\n        @modalContainer().modal('hide')\n      , 400"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/collection_view.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/collection_view.coffee","type":"component_definition","class_name":"Luca.CollectionView","header_documentation":"<p>The <code>Luca.CollectionView</code> renders models from a <code>Luca.Collection</code> into multiple\nelements, and provides methods for filtering, paginating, sorting the underlying\ncollection and re-rendering the contents of its <code>@el</code> accordingly.</p>\n\n<h4>Basic Example</h4>\n\n<pre><code>collectionView = Luca.register  &quot;App.views.Books&quot;\ncollectionView.extends          &quot;Luca.CollectionView&quot;\ncollectionView.defines\n  itemProperty: &quot;author&quot;\n  collection: new Luca.Collection([\n    author: &quot;George Orwell&quot;\n    title:  &quot;Animal Farm&quot;\n  ,\n    author: &quot;Noam Chomsky&quot;\n    title: &quot;Manufacturing Consent&quot;\n  ])\nview = new App.views.Books()\n</code></pre>\n\n<h4>Extending it to make it Filterable and Paginatable</h4>\n\n<pre><code>filterable = Luca.register    &quot;App.views.FilterableBooks&quot;\nfilterable.extends            &quot;App.views.Books&quot;\nfilterable.defines\n  collection: &quot;books&quot; \n  paginatable: 12\n  filterable:\n    query:\n      author: &quot;George Orwell&quot;\n\n view = new App.views.FilterableBooks()\n</code></pre>\n\n<h4>Filterable Collections</h4>\n\n<p>The <code>Luca.CollectionView</code> will attempt to perform a local query against its\ncollection which behaves like a <code>Backbone.QueryCollection</code>.  It will do this\nby default without making a remote request to the API.  </p>\n\n<p>If you do not want this behavior, you can configure the <code>Luca.CollectionView</code> to \nbehave as if the filtering was happen remotely in your REST API.<br>\n      filterable:\n        options:\n          remote: true</p>\n","type_alias":"collection_view","css_class_identifier":"luca-collection-view","defines_methods":{"initialize":{"defined_on_line":96,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"locateItemElement":{"defined_on_line":135,"documentation":"<p>Given the id of a model, find the underlying DOM element which was rendered by this collection.\nAssumes that the data-model-id attribute is set, which it is by default by @attributesForItem.</p>\n","arguments":[{"argument":"id","value":null}]},"refresh":{"defined_on_line":142,"documentation":"<p>Refresh is responsible for applying any filtering, pagination, or sorting options that may be set\nfrom the various Luca.concerns mixed in by <code>Luca.CollectionView</code> and making a query to the underlying\ncollection.  It will then take the set of models returned by <code>@getModels</code> and pass them through the\nitem rendering pipeline.</p>\n","arguments":[]},"attributesForItem":{"defined_on_line":164,"documentation":"<p>Determines which attributes should be set on the item DOM element.</p>\n","arguments":[{"argument":"item","value":null},{"argument":"model","value":null}]},"contentForItem":{"defined_on_line":169,"documentation":"<p>Determines the content for the item DOM element.  Will use the appropriate options\nspecified by <code>@itemTemplate</code>, <code>@itemRenderer</code>, or <code>@itemProperty</code></p>\n","arguments":[{"argument":"item","value":"{}"}]},"makeItem":{"defined_on_line":182,"documentation":"<p>Uses the various options passed to the <code>CollectionView</code> to assemble a call to <code>Luca.View::make</code>.</p>\n","arguments":[{"argument":"model","value":null},{"argument":"index","value":null}]},"refreshModel":{"defined_on_line":193,"documentation":"<p>Given a model, attempt to re-render the contents of its item in this view&#39;s DOM contents.</p>\n","arguments":[{"argument":"model","value":null}]},"registerEvent":{"defined_on_line":199,"documentation":"","arguments":[{"argument":"domEvent","value":null},{"argument":"selector","value":null},{"argument":"handler","value":null}]}},"defines_properties":{"collection":{"defined_on_line":64,"documentation":"<p>Specify which collection will be used to supply the models to be rendered.\nAccepts either a string alias for the Collection class, or an instance of\nany class which inherits from Backbone.Collection</p>\n","default":""},"tagName":{"defined_on_line":67,"documentation":"<p>By default the CollectionView will be rendered inside of an OL tag.</p>\n","default":""},"bodyClassName":{"defined_on_line":72,"documentation":"<p>The CollectionView behaves as a Luca.Panel which means it has an area for\ntop and bottom toolbars.  The actual content that gets rendered from the\ncollection will be rendered inside an element with the specified class.</p>\n","default":""},"itemTagName":{"defined_on_line":75,"documentation":"<p>Each item from the collection will be rendered inside of an element specified by @itemTagName</p>\n","default":""},"itemClassName":{"defined_on_line":78,"documentation":"<p>Each item element will be assigned a CSS class specified by @itemClassName</p>\n","default":""},"itemTemplate":{"defined_on_line":83,"documentation":"<p>Specify which template should be used to render each item in the collection.\nAccepts a string which will be passed to Luca.template(@itemTemplate).  Your template\ncan expect to be passed an object with the <code>model</code> and <code>index</code> properties on it.</p>\n","default":""},"itemRenderer":{"defined_on_line":87,"documentation":"<p>Accepts a reference to a function, which will be called with an object with the <code>model</code> and <code>index</code>\nproperties on it.  This function should return a String which will be injected into the item DOM element.</p>\n","default":""},"itemProperty":{"defined_on_line":90,"documentation":"<p>Plucks the specified property from the model and inserts it into the item DOM element.</p>\n","default":""},"observeChanges":{"defined_on_line":93,"documentation":"<p>If @observeChanges is set to true, any change in an underlying model will automatically be re-rendered.</p>\n","default":""}},"source_file_contents":"# The `Luca.CollectionView` renders models from a `Luca.Collection` into multiple\n# elements, and provides methods for filtering, paginating, sorting the underlying\n# collection and re-rendering the contents of its `@el` accordingly.\n#\n# #### Basic Example\n#     collectionView = Luca.register  \"App.views.Books\"\n#     collectionView.extends          \"Luca.CollectionView\"\n#\n#     collectionView.defines\n#       itemProperty: \"author\"\n#       collection: new Luca.Collection([\n#         author: \"George Orwell\"\n#         title:  \"Animal Farm\"\n#       ,\n#         author: \"Noam Chomsky\"\n#         title: \"Manufacturing Consent\"\n#       ])\n#\n#     view = new App.views.Books()\n# #### Extending it to make it Filterable and Paginatable\n#     filterable = Luca.register    \"App.views.FilterableBooks\"\n#     filterable.extends            \"App.views.Books\"\n#     filterable.defines\n#       collection: \"books\" \n#       paginatable: 12\n#       filterable:\n#         query:\n#           author: \"George Orwell\"\n#    \n#      view = new App.views.FilterableBooks()\n# #### Filterable Collections\n#\n# The `Luca.CollectionView` will attempt to perform a local query against its\n# collection which behaves like a `Backbone.QueryCollection`.  It will do this\n# by default without making a remote request to the API.  \n# \n# If you do not want this behavior, you can configure the `Luca.CollectionView` to \n# behave as if the filtering was happen remotely in your REST API.  \n#\n#       filterable:\n#         options:\n#           remote: true\ncollectionView = Luca.register      \"Luca.CollectionView\"\n\ncollectionView.extends            \"Luca.Panel\"\n\ncollectionView.replaces           \"Luca.components.CollectionView\"\n\ncollectionView.mixesIn            \"QueryCollectionBindings\", \n                                  \"LoadMaskable\", \n                                  \"Filterable\", \n                                  \"Paginatable\",\n                                  \"Sortable\"\n\ncollectionView.triggers           \"before:refresh\",\n                                  \"after:refresh\",\n                                  \"refresh\",\n                                  \"empty:results\"\n\ncollectionView.publicConfiguration\n  # Specify which collection will be used to supply the models to be rendered.\n  # Accepts either a string alias for the Collection class, or an instance of\n  # any class which inherits from Backbone.Collection\n  collection: undefined\n\n  # By default the CollectionView will be rendered inside of an OL tag.\n  tagName: \"ol\"\n\n  # The CollectionView behaves as a Luca.Panel which means it has an area for\n  # top and bottom toolbars.  The actual content that gets rendered from the \n  # collection will be rendered inside an element with the specified class.\n  bodyClassName: \"collection-ui-panel\"\n\n  # Each item from the collection will be rendered inside of an element specified by @itemTagName\n  itemTagName: 'li'\n\n  # Each item element will be assigned a CSS class specified by @itemClassName \n  itemClassName: 'collection-item'\n\n  # Specify which template should be used to render each item in the collection.  \n  # Accepts a string which will be passed to Luca.template(@itemTemplate).  Your template\n  # can expect to be passed an object with the `model` and `index` properties on it.\n  itemTemplate: undefined\n\n  # Accepts a reference to a function, which will be called with an object with the `model` and `index`\n  # properties on it.  This function should return a String which will be injected into the item DOM element.\n  itemRenderer: undefined\n\n  # Plucks the specified property from the model and inserts it into the item DOM element.\n  itemProperty: undefined\n\n  # If @observeChanges is set to true, any change in an underlying model will automatically be re-rendered.\n  observeChanges: false\n\ncollectionView.publicMethods\n  initialize: (@options={})->\n    _.extend(@, @options)\n    _.bindAll @, \"refresh\"\n\n    unless @collection? or @options.collection\n      console.log \"Error on initialize of collection view\", @\n      throw \"Collection Views must specify a collection\"\n\n    unless @itemTemplate? || @itemRenderer? || @itemProperty?\n      throw \"Collection Views must specify an item template or item renderer function\"\n\n    if _.isString(@collection) \n      if Luca.CollectionManager.get()\n        @collection = Luca.CollectionManager.get().getOrCreate(@collection)\n      else\n        console.log \"String Collection but no collection manager\"\n\n    unless Luca.isBackboneCollection(@collection)\n      console.log \"Missing Collection on #{ @name || @cid }\", @, @collection\n      throw \"Collection Views must have a valid backbone collection\"\n\n    # INVESTIGATE THIS BEING DOUBLE WORK\n    @on \"data:refresh\", @refresh, @\n    @on \"collection:reset\", @refresh, @\n\n    @on \"collection:remove\", @refresh, @\n    @on \"collection:add\", @refresh, @\n    @on \"collection:change\", @refreshModel, @ if @observeChanges is true\n\n    Luca.Panel::initialize.apply(@, arguments)\n\n    view = @\n    if @getCollection()?.length > 0\n      @on \"after:render\", ()->\n        view.refresh()\n        view.unbind \"after:render\", @\n\n  # Given the id of a model, find the underlying DOM element which was rendered by this collection.\n  # Assumes that the data-model-id attribute is set, which it is by default by @attributesForItem.\n  locateItemElement: (id)->\n    @$(\".#{ @itemClassName }[data-model-id='#{ id }']\")\n\n  # Refresh is responsible for applying any filtering, pagination, or sorting options that may be set\n  # from the various Luca.concerns mixed in by `Luca.CollectionView` and making a query to the underlying\n  # collection.  It will then take the set of models returned by `@getModels` and pass them through the\n  # item rendering pipeline.\n  refresh: ()->\n    query = @getLocalQuery()\n    options = @getQueryOptions()\n    models  = @getModels(query, options)\n\n    @$bodyEl().empty()\n\n    @trigger(\"before:refresh\", models, query, options)\n\n    if models.length is 0\n      @trigger(\"empty:results\", query, options)\n\n    index = 0\n    for model in models\n      @$append @makeItem(model, index++)\n\n    @trigger(\"after:refresh\", models, query, options)\n\n    @\n\ncollectionView.privateMethods\n  # Determines which attributes should be set on the item DOM element. \n  attributesForItem: (item, model)->\n    _.extend {}, class: @itemClassName, \"data-index\": item.index, \"data-model-id\": item.model.get('id')\n\n  # Determines the content for the item DOM element.  Will use the appropriate options\n  # specified by `@itemTemplate`, `@itemRenderer`, or `@itemProperty`\n  contentForItem: (item={})->\n    if @itemTemplate? and templateFn = Luca.template(@itemTemplate)\n      return content = templateFn.call(@, item)\n\n    if @itemRenderer? and _.isFunction( @itemRenderer )\n      return content = @itemRenderer.call(@, item, item.model, item.index)\n\n    if @itemProperty and item.model?\n      return content = item.model.read( @itemProperty )\n\n    \"\"\n\n  # Uses the various options passed to the `CollectionView` to assemble a call to `Luca.View::make`.\n  makeItem: (model, index)->\n    item = if @prepareItem? then @prepareItem.call(@, model, index) else (model:model, index: index)\n    attributes = @attributesForItem(item, model) \n    content = @contentForItem(item)\n\n    try\n      Luca.View::make(@itemTagName, attributes, content)\n    catch e\n      console.log \"Error generating DOM element for CollectionView\", @, model, index\n\n  # Given a model, attempt to re-render the contents of its item in this view's DOM contents.\n  refreshModel: (model)->\n    index = @collection.indexOf( model )\n    @locateItemElement(model.get('id')).empty().append( @contentForItem({model,index}, model) )\n    @trigger(\"model:refreshed\", index, model)\n\n\n  registerEvent: (domEvent, selector, handler)->\n    if !handler? and _.isFunction(selector)\n      handler = selector\n      selector = undefined\n\n    eventTrigger = _([domEvent,\"#{ @itemTagName }.#{ @itemClassName }\", selector]).compact().join(\" \")\n    Luca.View::registerEvent(eventTrigger,handler)\n\ncollectionView.register()\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/controller.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/controller.coffee","type":"component_definition","class_name":"Luca.components.Controller","header_documentation":"","type_alias":"controller","css_class_identifier":"luca-controller","defines_methods":{"default":{"defined_on_line":7,"documentation":"","arguments":[{"argument":"callback","value":null}]},"activePage":{"defined_on_line":10,"documentation":"","arguments":[]},"navigate_to":{"defined_on_line":13,"documentation":"","arguments":[{"argument":"section","value":null},{"argument":"callback","value":null}]},"setupComponentKeyEvents":{"defined_on_line":38,"documentation":"","arguments":[]},"controllerPath":{"defined_on_line":43,"documentation":"","arguments":[]},"initialize":{"defined_on_line":64,"documentation":"","arguments":[{"argument":"@options","value":null}]},"each":{"defined_on_line":83,"documentation":"","arguments":[{"argument":"fn","value":null}]},"activeSection":{"defined_on_line":86,"documentation":"","arguments":[]},"pageControllers":{"defined_on_line":89,"documentation":"","arguments":[{"argument":"deep","value":"false"}]},"controllers":{"defined_on_line":92,"documentation":"","arguments":[{"argument":"deep","value":"false"}]},"availablePages":{"defined_on_line":97,"documentation":"","arguments":[]},"availableSections":{"defined_on_line":100,"documentation":"","arguments":[]},"pageNames":{"defined_on_line":109,"documentation":"","arguments":[]},"sectionNames":{"defined_on_line":112,"documentation":"","arguments":[{"argument":"deep","value":"false"}]}},"defines_properties":{"tracker":{"defined_on_line":5,"documentation":"","default":""},"Luca.View":{"defined_on_line":57,"documentation":"","default":""},"additionalClassNames":{"defined_on_line":60,"documentation":"","default":""},"activeAttribute":{"defined_on_line":61,"documentation":"","default":""},"stateful":{"defined_on_line":62,"documentation":"","default":""}},"source_file_contents":"controller = Luca.register        \"Luca.components.Controller\"\ncontroller.extends                \"Luca.containers.CardView\"\n\ncontroller.publicInterface\n  tracker: \"page\"\n\n  default: (callback)->\n    @navigate_to(@defaultPage || @defaultCard, callback)\n\n  activePage: ()-> \n    @activeSection()\n\n  navigate_to: (section, callback)->\n    section ||= @defaultCard\n\n    @activate section, false, (activator, previous,current)=>\n      if current.activatedByController is true\n        current.trigger(\"on:controller:reactivation\")\n      else\n        current.trigger(\"on:controller:reactivation\")\n        current.trigger(\"on:controller:activation\")\n        current.activatedByController = true\n\n      @state.set(active_section: current.name )\n\n      if app = Luca.getApplication?()\n        app.state.set(@tracker, current.name)\n\n      Luca.key?.setScope( current.name )\n\n      if _.isFunction( callback )\n        callback.call(current)\n\n    # return the section we are navigating to\n    @find(section)\n\ncontroller.classMethods\n  setupComponentKeyEvents: ()->\n    @_().each (component)->    \n      if _.isObject(component.keyEvents) and component.name?\n        Luca.util.setupKeymaster(component.keyEvents, component.name).on(component)    \n\n  controllerPath: ()->\n    component = @\n    \n    list = [component.name]\n    atBase = false\n\n    while component and not atBase\n      component = component.getParent?()\n      atBase = true if component?.role is \"main_controller\"\n      list.push( component.name ) if component? and not atBase\n\n    list.reverse()\n\ncontroller.afterDefinition ()->\n  Luca.View::hooks.push \"on:controller:activation\"\n\ncontroller.defines\n  additionalClassNames: 'luca-ui-controller'\n  activeAttribute: \"active-section\"\n  stateful: true\n\n  initialize: (@options)->\n    # let's phase out the 'card' terminology \n    # and 'section' while we're at it.  page is the word.\n    @defaultCard ||= @defaultPage ||= @components[0]?.name || 0\n    @defaultPage ||= @defaultCard \n\n    @defaultState ||= \n      active_section: @defaultPage\n\n    Luca.containers.CardView::initialize.apply @, arguments\n\n    throw \"Controllers must specify a defaultCard property and/or the first component must have a name\" unless @defaultCard?\n\n    @_().each (component)->\n      component.controllerPath = Luca.components.Controller.controllerPath\n\n    @on \"after:render\", @default, @\n    @on \"before:render\", Luca.components.Controller.setupComponentKeyEvents, @\n\n  each: (fn)->\n    _( @components ).each (component)=> fn.call(@,component)\n\n  activeSection: ()->\n    @get(\"active_section\")\n\n  pageControllers: (deep=false)->\n    @controllers.apply(@, arguments)\n\n  controllers:(deep=false)->\n    @select (component)->\n      type = (component.type || component.ctype) \n      type is \"controller\" or type is \"page_controller\"\n\n  availablePages: ()->\n    @availableSections.apply(@, arguments)    \n\n  availableSections: ()->\n    base = {}\n    base[ @name ] = @sectionNames()\n\n    _( @controllers() ).reduce (memo,controller)=>\n      memo[ controller.name ] = controller.sectionNames()  \n      memo\n    , base \n\n  pageNames: ()->\n    @sectionNames()\n\n  sectionNames: (deep=false)->\n    @pluck('name')\n\n\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/base.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/base.coffee","type":"component_definition","class_name":"Luca.core.Field","header_documentation":"","type_alias":"field","css_class_identifier":"luca-core-field","defines_methods":{"disable":{"defined_on_line":19,"documentation":"","arguments":[]},"enable":{"defined_on_line":22,"documentation":"","arguments":[]},"getValue":{"defined_on_line":25,"documentation":"","arguments":[]},"setValue":{"defined_on_line":28,"documentation":"","arguments":[{"argument":"value","value":null}]},"updateState":{"defined_on_line":31,"documentation":"","arguments":[{"argument":"state","value":null}]},"clearErrors":{"defined_on_line":36,"documentation":"","arguments":[]},"displayErrors":{"defined_on_line":39,"documentation":"","arguments":[{"argument":"errors","value":null}]},"getParsedValue":{"defined_on_line":43,"documentation":"","arguments":[{"argument":"raw","value":null}]},"initialize":{"defined_on_line":57,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"beforeRender":{"defined_on_line":81,"documentation":"","arguments":[]},"change_handler":{"defined_on_line":87,"documentation":"","arguments":[{"argument":"e","value":null}]},"getInputElement":{"defined_on_line":90,"documentation":"","arguments":[]}},"defines_properties":{"labelAlign":{"defined_on_line":10,"documentation":"","default":""},"className":{"defined_on_line":11,"documentation":"","default":""},"isField":{"defined_on_line":53,"documentation":"","default":""},"template":{"defined_on_line":54,"documentation":"","default":""}},"source_file_contents":"field = Luca.register         \"Luca.core.Field\"\n\nfield.extends                 \"Luca.View\"\n\nfield.triggers                \"before:validation\",\n                              \"after:validation\",\n                              \"on:change\"\n\nfield.publicConfiguration\n  labelAlign: 'top'\n  className: 'luca-ui-text-field luca-ui-field'\n  statuses: [\n    \"warning\"\n    \"error\"\n    \"success\"\n  ]\n\nfield.publicInterface\n  disable: ()->\n    @getInputElement().attr('disabled', true)\n\n  enable: ()->\n    @getInputElement().attr('disabled', false)\n\n  getValue: ()->\n    @getParsedValue(@getInputElement()?.attr('value'))\n\n  setValue: (value)->\n    @getInputElement()?.attr('value', value)\n\n  updateState: (state)->\n    _( @statuses ).each (cls)=>\n      @$el.removeClass(cls)\n    @$el.addClass(state)\n\n  clearErrors: ()->\n    @$el.removeClass('error')\n\n  displayErrors: (errors)->\n    @updateState('error')\n\nfield.methods\n  getParsedValue: (raw)->\n    return raw if _.str.isBlank( raw )\n\n    switch @valueType\n      when \"integer\" then parseInt(raw)\n      when \"string\" then \"#{ raw }\"\n      when \"float\" then parseFloat(raw)\n      else raw\n\nfield.privateConfiguration\n  isField: true\n  template: 'fields/text_field'\n\nfield.defines\n  initialize: (@options={})->\n    _.extend @, @options\n\n    @input_id ||= _.uniqueId('field')\n    @input_name ||= @name\n    @input_class ||= \"\"\n    @input_type ||= \"\"\n    @helperText ||= \"\"\n    @label = @name if not @label? or @label.length is 0\n    @label ||= \"*#{ @label }\" if @required and not @label?.match(/^\\*/)\n    @inputStyles ||= \"\"\n    @input_value ||= @value || \"\"\n\n    @disable() if @disabled\n\n    @updateState( @state )\n    @placeHolder ||= \"\"\n\n    # In order to support using Luca.View template properties everywhere.\n\n    # Will need to work around how the field classes\n    # apply templates to themselves.\n    Luca.View::initialize.apply(@, arguments)\n\n  beforeRender: ()->\n    if Luca.config.enableBoostrap\n      @$el.addClass('control-group')\n\n    @$el.addClass('required') if @required\n\n  change_handler: (e)->\n    @trigger \"on:change\", @, e\n\n  getInputElement: ()->\n    @input ||= @$('input').eq(0)\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/button_field.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/button_field.coffee","type":"component_definition","class_name":"Luca.fields.ButtonField","header_documentation":"","type_alias":"button_field","css_class_identifier":"luca-fields-button-field","defines_methods":{"click_handler":{"defined_on_line":23,"documentation":"","arguments":[{"argument":"e","value":null}]},"initialize":{"defined_on_line":27,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"afterInitialize":{"defined_on_line":35,"documentation":"","arguments":[]},"setValue":{"defined_on_line":44,"documentation":"","arguments":[]}},"defines_properties":{"readOnly":{"defined_on_line":8,"documentation":"","default":""},"input_value":{"defined_on_line":9,"documentation":"","default":""},"input_type":{"defined_on_line":10,"documentation":"","default":""},"icon_class":{"defined_on_line":11,"documentation":"","default":""},"input_name":{"defined_on_line":12,"documentation":"","default":""},"white":{"defined_on_line":13,"documentation":"","default":""},"isButton":{"defined_on_line":17,"documentation":"","default":""},"template":{"defined_on_line":18,"documentation":"","default":""}},"source_file_contents":"buttonField = Luca.register         \"Luca.fields.ButtonField\"\n\nbuttonField.extends                 \"Luca.core.Field\"\n\nbuttonField.triggers                \"button:click\"\n\nbuttonField.publicConfiguration\n  readOnly:       true\n  input_value:    undefined \n  input_type:     \"button\" \n  icon_class:     undefined\n  input_name:     undefined\n  white:          undefined\n  buttonClasses:  \"\" \n\nbuttonField.privateConfiguration\n  isButton: true\n  template: \"fields/button_field\"\n  events:\n    \"click input\" : \"click_handler\"\n\nbuttonField.privateInterface\n  click_handler: (e)->\n    me = my = $( e.currentTarget )\n    @trigger \"button:click\"\n\n  initialize: (@options={})->\n    _.extend @options\n    _.bindAll @, \"click_handler\"\n\n    Luca.core.Field::initialize.apply @, arguments\n\n    @template = \"fields/button_field_link\" if @icon_class?.length\n\n  afterInitialize: ()->\n    @input_id ||= _.uniqueId('button')\n    @input_name ||= @name ||= @input_id\n    @input_value ||= @label ||= @text\n    @input_class ||= @class ||= @buttonClasses\n    @icon_class ||= \"\"\n    @icon_class = \"icon-#{ @icon_class }\" if @icon_class.length and !@icon_class.match(/^icon-/)\n    @icon_class += \" icon-white\" if @white\n\n  setValue: ()-> true\n\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/checkbox_array.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/checkbox_array.coffee","type":"component_definition","class_name":"Luca.fields.CheckboxArray","header_documentation":"","type_alias":"checkbox_array","css_class_identifier":"luca-fields-checkbox-array","defines_methods":{"initialize":{"defined_on_line":18,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"afterInitialize":{"defined_on_line":31,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"clickHandler":{"defined_on_line":47,"documentation":"","arguments":[{"argument":"event","value":null}]},"controls":{"defined_on_line":56,"documentation":"","arguments":[]},"renderCheckboxes":{"defined_on_line":59,"documentation":"","arguments":[]},"uncheckAll":{"defined_on_line":77,"documentation":"","arguments":[]},"allFields":{"defined_on_line":80,"documentation":"","arguments":[]},"checkSelected":{"defined_on_line":83,"documentation":"","arguments":[{"argument":"items","value":null}]},"getValue":{"defined_on_line":94,"documentation":"","arguments":[]},"setValue":{"defined_on_line":97,"documentation":"","arguments":[{"argument":"items","value":null}]},"getValues":{"defined_on_line":108,"documentation":"","arguments":[]},"setValues":{"defined_on_line":111,"documentation":"","arguments":[{"argument":"items","value":null}]}},"defines_properties":{"version":{"defined_on_line":7,"documentation":"","default":""},"template":{"defined_on_line":9,"documentation":"","default":""},"className":{"defined_on_line":11,"documentation":"","default":""}},"source_file_contents":"make = Luca.View::make\n\ncheckboxArray = Luca.register     \"Luca.fields.CheckboxArray\"\ncheckboxArray.extends             \"Luca.core.Field\"\n\ncheckboxArray.defines\n  version: 2\n\n  template: \"fields/checkbox_array\"\n\n  className: \"luca-ui-checkbox-array\"\n\n  events:\n    \"click input\" : \"clickHandler\"\n\n  selectedItems: []\n\n  initialize: (@options={})->\n    _.extend @, @options\n    _.extend @, Luca.concerns.Deferrable\n    _.bindAll @, \"renderCheckboxes\", \"clickHandler\", \"checkSelected\"\n\n    Luca.core.Field::initialize.apply @, arguments\n\n    @input_id ||= _.uniqueId('field')\n    @input_name ||= @name\n    @label ||= @name\n    @valueField ||= \"id\"\n    @displayField ||= \"name\"\n\n  afterInitialize: (@options={})->\n    try\n      @configure_collection()\n    catch e\n      console.log \"Error Configuring Collection\", @, e.message\n\n    cbArray = @\n\n    unless Luca.isBackboneCollection(@collection)\n      throw \"Checkbox Array Fields must specify a @collection property\"\n      \n    if @collection.length > 0\n      @renderCheckboxes()\n    else\n      @defer(\"renderCheckboxes\").until(@collection,\"reset\")\n\n  clickHandler: (event)->\n    checkbox = $(event.target)\n\n    if checkbox.prop('checked')\n      @selectedItems.push( checkbox.val() )\n    else\n      if _( @selectedItems ).include( checkbox.val() )\n        @selectedItems = _( @selectedItems ).without( checkbox.val() )\n\n  controls: ()->\n    @$('.controls')\n\n  renderCheckboxes: ()->\n    @controls().empty()\n    @selectedItems = []\n\n    @collection.each (model)=>\n      value = model.get(@valueField)\n      label = model.get(@displayField)\n      input_id = _.uniqueId(\"#{ @cid }_checkbox\")\n\n      inputElement = make(\"input\",type:\"checkbox\",class:\"array-checkbox\",name:@input_name,value:value,id: input_id)\n      element = make(\"label\", {for:input_id}, inputElement)\n\n      $( element ).append(\" #{ label }\")\n      @controls().append( element )\n\n    @trigger(\"checkboxes:rendered\", @checkboxesRendered = true)\n    @\n\n  uncheckAll: ()->\n    @allFields().prop('checked', false)\n\n  allFields: ()->\n    @controls().find(\"input[type='checkbox']\")\n\n  checkSelected: (items)->\n    @selectedItems = items if items?\n\n    @uncheckAll()\n\n    for value in @selectedItems\n      checkbox = @controls().find(\"input[value='#{ value }']\")\n      checkbox.prop('checked', true)\n\n    @selectedItems\n\n  getValue: ()->\n    @$(field).val() for field in @allFields() when @$(field).prop('checked')\n\n  setValue: (items)->\n    @selectedItems = items\n\n    if @checkboxesRendered is true\n      @checkSelected(items)\n    else\n      cbArray = @\n      @defer ()->\n        cbArray.checkSelected(items)\n      .until(\"checkboxes:rendered\")\n\n  getValues: ()->\n    @getValue()\n\n  setValues: (items)->\n    @setValue(items)"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/checkbox_field.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/checkbox_field.coffee","type":"component_definition","class_name":"Luca.fields.CheckboxField","header_documentation":"","type_alias":"checkbox_field","css_class_identifier":"luca-fields-checkbox-field","defines_methods":{"change_handler":{"defined_on_line":18,"documentation":"","arguments":[{"argument":"e","value":null}]},"initialize":{"defined_on_line":28,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"setValue":{"defined_on_line":39,"documentation":"","arguments":[{"argument":"checked","value":null}]},"getValue":{"defined_on_line":42,"documentation":"","arguments":[]}},"defines_properties":{"send_blanks":{"defined_on_line":9,"documentation":"","default":""},"input_value":{"defined_on_line":10,"documentation":"","default":""},"template":{"defined_on_line":13,"documentation":"","default":""},"version":{"defined_on_line":46,"documentation":"","default":""}},"source_file_contents":"checkboxField = Luca.register         \"Luca.fields.CheckboxField\"\n\ncheckboxField.extends                 \"Luca.core.Field\"\n\ncheckboxField.triggers                \"checked\",\n                                      \"unchecked\"\n\ncheckboxField.publicConfiguration\n  send_blanks: true\n  input_value: 1\n\ncheckboxField.privateConfiguration\n  template: 'fields/checkbox_field'\n  events:\n    \"change input\" : \"change_handler\"\n\ncheckboxField.privateInterface\n  change_handler: (e)->\n    me = my = $(e.target)\n\n    if me.is(\":checked\")\n      @trigger \"checked\"\n    else\n      @trigger \"unchecked\"\n\n    @trigger \"on:change\", @, e, me.is(\":checked\")\n\n  initialize: (@options={})->\n    _.extend @, @options\n    _.bindAll @, \"change_handler\"\n\n    Luca.core.Field::initialize.apply @, arguments\n\n    @input_id ||= _.uniqueId('field')\n    @input_name ||= @name\n    @label ||= @name\n\ncheckboxField.publicInterface\n  setValue: (checked)->\n    @getInputElement().attr('checked', checked)\n\n  getValue:()->\n    @getInputElement().is(\":checked\")\n\ncheckboxField.defines\n  version: 1"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/file_upload_field.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/file_upload_field.coffee","type":"component_definition","class_name":"Luca.fields.FileUploadField","header_documentation":"","type_alias":"file_upload_field","css_class_identifier":"luca-fields-file-upload-field","defines_methods":{"afterInitialize":{"defined_on_line":9,"documentation":"","arguments":[]}},"defines_properties":{"version":{"defined_on_line":5,"documentation":"","default":""},"template":{"defined_on_line":7,"documentation":"","default":""}},"source_file_contents":"fileUpload = Luca.register              \"Luca.fields.FileUploadField\"\nfileUpload.extends                      \"Luca.core.Field\"\n\nfileUpload.defines\n  version: 1\n\n  template: 'fields/file_upload_field'\n\n  afterInitialize: ()->\n    @input_id ||= _.uniqueId('field')\n    @input_name ||= @name\n    @label ||= @name\n    @helperText ||= \"\"\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/hidden_field.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/hidden_field.coffee","type":"component_definition","class_name":"Luca.fields.HiddenField","header_documentation":"","type_alias":"hidden_field","css_class_identifier":"luca-fields-hidden-field","defines_methods":{"afterInitialize":{"defined_on_line":7,"documentation":"","arguments":[]}},"defines_properties":{"template":{"defined_on_line":5,"documentation":"","default":""}},"source_file_contents":"hiddenField = Luca.register       \"Luca.fields.HiddenField\"\nhiddenField.extends               \"Luca.core.Field\"\n\nhiddenField.defines\n  template: 'fields/hidden_field'\n\n  afterInitialize: ()->\n    @input_id ||= _.uniqueId('field')\n    @input_name ||= @name\n    @input_value ||= @value\n    @label ||= @name"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/label_field.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/label_field.coffee","type":"component_definition","class_name":"Luca.components.LabelField","header_documentation":"","type_alias":"label_field","css_class_identifier":"luca-label-field","defines_methods":{"formatter":{"defined_on_line":5,"documentation":"","arguments":[{"argument":"value","value":null}]},"setValue":{"defined_on_line":9,"documentation":"","arguments":[{"argument":"value","value":null}]}},"defines_properties":{},"source_file_contents":"labelField = Luca.register          \"Luca.components.LabelField\"\nlabelField.extends                  \"Luca.core.Field\"\n\nlabelField.defines\n  formatter: (value)->\n    value ||= @getValue()\n    _.str.titleize( value )\n\n  setValue: (value)->\n    @trigger(\"change\", value, @getValue())\n    @getInputElement().attr('value', value)\n    @$('.value').html( @formatter(value) )\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/select_field.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/select_field.coffee","type":"component_definition","class_name":"Luca.fields.SelectField","header_documentation":"","type_alias":"select_field","css_class_identifier":"luca-fields-select-field","defines_methods":{"setValue":{"defined_on_line":47,"documentation":"<p>sets the value of this select field.</p>\n","arguments":[{"argument":"value","value":null}]},"getValue":{"defined_on_line":54,"documentation":"<p>returns the value of the select field.  runs\nthe value through the getParsedValue method which\nenforces the valueType type conversion.</p>\n","arguments":[]},"initialize":{"defined_on_line":64,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"afterInitialize":{"defined_on_line":80,"documentation":"","arguments":[]},"parseData":{"defined_on_line":99,"documentation":"<p>if the select field is configured with a data property\nthen parse that data into the proper format.  either\nan array of objects with the valueField and displayField\nproperties, or an array of arrays with [valueField, displayField]</p>\n","arguments":[]},"getInputElement":{"defined_on_line":109,"documentation":"","arguments":[]},"afterRender":{"defined_on_line":112,"documentation":"","arguments":[]},"beforeFetch":{"defined_on_line":118,"documentation":"","arguments":[]},"change_handler":{"defined_on_line":121,"documentation":"","arguments":[{"argument":"e","value":null}]},"resetOptions":{"defined_on_line":124,"documentation":"","arguments":[]},"populateOptions":{"defined_on_line":132,"documentation":"","arguments":[]}},"defines_properties":{"allowMultiple":{"defined_on_line":10,"documentation":"<p>Enables multi-select UI element.</p>\n","default":""},"includeBlank":{"defined_on_line":14,"documentation":"<p>Includes a blank option in addition to all of the items\nin the underlying collection.  Defaults to <code>true</code></p>\n","default":""},"blankText":{"defined_on_line":22,"documentation":"<p>Determines the text displayed when\nthe blank option is selected</p>\n","default":""},"maxDisplayLength":{"defined_on_line":28,"documentation":"<p>Specifying a value for maxDisplayLength will truncate\nvalues displayed in the select field when they reach\npast a certain point, using the _.str truncate method.\nLeave at 0 if you want to keep this feature disabled.</p>\n","default":""},"retainValue":{"defined_on_line":34,"documentation":"<p>When the underlying collection is reset and we re-render\nthe options elements, should we keep the value that was set\non this field prior to that? Defaults to <code>true</code> unless otherwise\nspecified.</p>\n","default":""},"label":{"defined_on_line":38,"documentation":"<p>Determines which value is rendered in the label element that gets\nrendered along with this control group.</p>\n","default":""},"template":{"defined_on_line":41,"documentation":"","default":""}},"source_file_contents":"selectField = Luca.register   \"Luca.fields.SelectField\"\n\nselectField.extends           \"Luca.core.Field\"\n\nselectField.triggers          \"after:select\",\n                              \"on:change\"\n\nselectField.publicConfiguration\n  # Enables multi-select UI element.\n  allowMultiple: false\n\n  # Includes a blank option in addition to all of the items\n  # in the underlying collection.  Defaults to `true` \n  includeBlank: true\n\n  # determines which value is sent when \n  # the blank option is selected?\n  blankValue: ''\n\n  # Determines the text displayed when \n  # the blank option is selected \n  blankText: 'Select One'\n\n  # Specifying a value for maxDisplayLength will truncate\n  # values displayed in the select field when they reach \n  # past a certain point, using the _.str truncate method.\n  # Leave at 0 if you want to keep this feature disabled.\n  maxDisplayLength: 0 \n\n  # When the underlying collection is reset and we re-render\n  # the options elements, should we keep the value that was set\n  # on this field prior to that? Defaults to `true` unless otherwise\n  # specified.\n  retainValue: undefined\n\n  # Determines which value is rendered in the label element that gets\n  # rendered along with this control group. \n  label: undefined\n\nselectField.privateConfiguration\n  template: \"fields/select_field\"\n  events:\n    \"change select\" : \"change_handler\"\n\nselectField.publicMethods\n  # sets the value of this select field.\n  setValue: (value)->\n    @currentValue = value\n    Luca.core.Field::setValue.apply @, arguments\n\n  # returns the value of the select field.  runs\n  # the value through the getParsedValue method which\n  # enforces the valueType type conversion.\n  getValue: ()->\n    raw = @getInputElement()?.val()\n\n    if @allowMultiple\n      _.map raw, (value)=>\n        @getParsedValue(value)\n    else\n      @getParsedValue(raw)\n\nselectField.privateMethods\n  initialize: (@options={})->\n    _.extend @, @options\n    _.extend @, Luca.concerns.Deferrable\n    _.bindAll @, \"change_handler\"\n\n    if _.isArray(@collection)\n      @collection = data: @collection\n\n    Luca.core.Field::initialize.apply @, arguments\n\n    @input_id ||= _.uniqueId('field')\n    @input_name ||= @name\n    @valueType ||= Luca.config.idAttributeType if @valueField is \"id\"\n    @label ||= @name\n    @retainValue = true unless @retainValue? \n\n  afterInitialize: ()->\n    if @collection?.data\n      @valueField ||= \"id\"\n      @displayField ||= \"name\"\n      @sortOptionsBy ||= @displayField\n      @parseData()\n\n    try\n      @configure_collection( @setAsDeferrable )\n    catch e\n      console.log \"Error Configuring Collection\", @, e.message\n\n    @collection?.bind \"before:fetch\", @beforeFetch, @\n    @collection?.bind \"reset\", @populateOptions, @\n\n  # if the select field is configured with a data property\n  # then parse that data into the proper format.  either\n  # an array of objects with the valueField and displayField\n  # properties, or an array of arrays with [valueField, displayField]\n  parseData: ()->\n    @collection.data = _( @collection.data ).map (record)=>\n      return record if not _.isArray( record )\n\n      hash = {}\n      hash[ @valueField ] = record[0]\n      hash[ @displayField ] = record[1] || record[0]\n\n      hash\n\n  getInputElement: ()->\n    @input ||= @$('select').eq(0)\n\n  afterRender: ()->\n    if @collection?.models?.length > 0\n      @populateOptions()\n    else\n      @collection?.trigger(\"reset\")\n\n  beforeFetch: ()->\n    @resetOptions()\n\n  change_handler: (e)->\n    @trigger \"on:change\", @, e\n\n  resetOptions: ()->\n    @getInputElement().html('')\n\n    if @allowMultiple\n      @getInputElement().attr(multiple: true)\n    else if @includeBlank\n      @getInputElement().append(\"<option value='#{ @blankValue }'>#{ @blankText }</option>\")\n\n  populateOptions: ()->\n    @resetOptions()\n\n    if @collection?.length > 0\n      if @sortOptionsBy?\n        models = @collection.sortBy (model)=>\n          if model.read?\n            model.read( @sortOptionsBy )\n          else\n            model.get( @sortOptionsBy )\n      else\n        models = @collection.models\n\n      for model in models\n        v = model.read?( @valueField ) || model.get(@valueField)\n        d = model.read?( @displayField ) || model.get(@displayField)\n\n        if @maxDisplayLength and @maxDisplayLength > 0\n          d = _.str.truncate(d, @maxDisplayLength)\n\n        selected = \"selected\" if @selected and v is @selected\n        option = \"<option #{ selected } value='#{ v }'>#{ d }</option>\"\n        @getInputElement().append( option )\n\n    @trigger \"after:populate:options\", @\n    @setValue( @currentValue )\n\nselectField.register()"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/text_area_field.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/text_area_field.coffee","type":"component_definition","class_name":"Luca.fields.TextAreaField","header_documentation":"","type_alias":"text_area_field","css_class_identifier":"luca-fields-text-area-field","defines_methods":{"initialize":{"defined_on_line":16,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"setValue":{"defined_on_line":35,"documentation":"","arguments":[{"argument":"value","value":null}]},"getValue":{"defined_on_line":38,"documentation":"","arguments":[]},"field":{"defined_on_line":41,"documentation":"","arguments":[]},"keyup_handler":{"defined_on_line":44,"documentation":"","arguments":[{"argument":"e","value":null}]},"blur_handler":{"defined_on_line":50,"documentation":"","arguments":[{"argument":"e","value":null}]},"focus_handler":{"defined_on_line":53,"documentation":"","arguments":[{"argument":"e","value":null}]},"change_handler":{"defined_on_line":56,"documentation":"","arguments":[{"argument":"e","value":null}]}},"defines_properties":{"autoBindEventHandlers":{"defined_on_line":4,"documentation":"","default":""},"template":{"defined_on_line":10,"documentation":"","default":""},"height":{"defined_on_line":12,"documentation":"","default":""},"width":{"defined_on_line":13,"documentation":"","default":""},"keyEventThrottle":{"defined_on_line":14,"documentation":"","default":""}},"source_file_contents":"textArea = Luca.register          \"Luca.fields.TextAreaField\"\ntextArea.extends                  \"Luca.core.Field\"\ntextArea.defines\n  autoBindEventHandlers: true\n\n  events:\n    \"blur textarea\" : \"blur_handler\"\n    \"focus textarea\" : \"focus_handler\"\n\n  template: 'fields/text_area_field'\n\n  height: \"200px\"\n  width: \"90%\"\n  keyEventThrottle: 300\n\n  initialize: (@options={})->\n\n    @input_id ||= _.uniqueId('field')\n    @input_name ||= @name\n    @label ||= @name\n    @input_class ||= @class\n    @input_value ||= \"\"\n    @inputStyles ||= \"height:#{ @height };width:#{ @width }\"\n    @placeHolder ||= \"\"\n\n    Luca.core.Field::initialize.apply @, arguments\n\n    if @enableKeyEvents is true\n      @keyup_handler = _.debounce(@keyup_handler, @keyEventThrottle || 10)\n\n      console.log \"Registering Key Events\"\n      @registerEvent(\"keyup textarea\",\"keyup_handler\")     \n      @registerEvent(\"keydown textarea\",\"keyup_handler\")     \n\n  setValue: (value)->\n    $( @field() ).val(value)\n\n  getValue: ()->\n    $( @field() ).val()\n\n  field: ()->\n    @input = @$(\"textarea\")\n\n  keyup_handler: (e)->\n    # TODO: Should ignore certain keyup events\n    # which would not indicate a change\n    @trigger \"on:change\", @, e\n    @trigger \"on:keyup\", @, e\n\n  blur_handler: (e)->\n    @trigger \"on:blur\", @, e\n\n  focus_handler: (e)->\n    @trigger \"on:focus\", @, e\n\n  change_handler: (e)-> \n    @trigger \"on:change\", @, e"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/text_field.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/text_field.coffee","type":"component_definition","class_name":"Luca.fields.TextField","header_documentation":"","type_alias":"text_field","css_class_identifier":"luca-fields-text-field","defines_methods":{"initialize":{"defined_on_line":18,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"keyup_handler":{"defined_on_line":43,"documentation":"","arguments":[{"argument":"e","value":null}]},"blur_handler":{"defined_on_line":49,"documentation":"","arguments":[{"argument":"e","value":null}]},"focus_handler":{"defined_on_line":52,"documentation":"","arguments":[{"argument":"e","value":null}]},"change_handler":{"defined_on_line":55,"documentation":"","arguments":[{"argument":"e","value":null}]}},"defines_properties":{"template":{"defined_on_line":10,"documentation":"","default":""},"autoBindEventHandlers":{"defined_on_line":12,"documentation":"","default":""},"send_blanks":{"defined_on_line":14,"documentation":"","default":""},"keyEventThrottle":{"defined_on_line":16,"documentation":"","default":""}},"source_file_contents":"textField = Luca.register     'Luca.fields.TextField'\ntextField.extends             'Luca.core.Field'\n\ntextField.defines\n  _events:\n    \"blur input\" : \"blur_handler\"\n    \"focus input\" : \"focus_handler\"\n    \"change input\" : \"change_handler\"\n\n  template: 'fields/text_field'\n\n  autoBindEventHandlers: true\n\n  send_blanks: true\n\n  keyEventThrottle: 300\n\n  initialize: (@options={})->\n    if @enableKeyEvents\n      if @keyEventThrottle\n        @keyup_handler = _.debounce(@keyup_handler, @keyEventThrottle)\n        \n      @registerEvent(\"keyup input\",\"keyup_handler\")     \n\n    @input_id ||= _.uniqueId('field')\n    @input_name ||= @name\n    @label ||= @name\n    @input_class ||= @class\n    @input_value ||= @value || \"\" \n    \n    if @prepend\n      @$el.addClass 'input-prepend'\n      @addOn = @prepend\n\n    if @append\n      @$el.addClass 'input-append'\n      @addOn = @append\n\n    @placeHolder ||= \"\"\n\n    Luca.core.Field::initialize.apply @, arguments\n\n  keyup_handler: (e)->\n    # TODO: Should ignore certain keyup events\n    # which would not indicate a change\n    @trigger \"on:change\", @, e\n    @trigger \"on:keyup\", @, e\n\n  blur_handler: (e)->\n    @trigger \"on:blur\", @, e\n\n  focus_handler: (e)->\n    @trigger \"on:focus\", @, e\n\n  change_handler: (e)-> \n    @trigger \"on:change\", @, e\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/type_ahead_field.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/type_ahead_field.coffee","type":"component_definition","class_name":"Luca.fields.TypeAheadField","header_documentation":"","type_alias":"type_ahead_field","css_class_identifier":"luca-fields-type-ahead-field","defines_methods":{"getSource":{"defined_on_line":6,"documentation":"","arguments":[]},"matcher":{"defined_on_line":9,"documentation":"","arguments":[{"argument":"item","value":null}]},"beforeRender":{"defined_on_line":12,"documentation":"","arguments":[]},"afterRender":{"defined_on_line":16,"documentation":"","arguments":[]}},"defines_properties":{},"source_file_contents":"typeAheadField = Luca.register      \"Luca.fields.TypeAheadField\"\ntypeAheadField.extends              \"Luca.fields.TextField\" \n\n\ntypeAheadField.defines\n  getSource: ()->\n    Luca.util.read(@source) || []\n\n  matcher: (item)->\n    true\n\n  beforeRender: ()->\n    Luca.fields.TextField::beforeRender.apply(@, arguments)\n    @getInputElement().attr('data-provide','typeahead')\n\n  afterRender: ()->\n    Luca.fields.TextField::afterRender.apply(@, arguments)\n    @getInputElement().typeahead\n      matcher: @matcher\n      source: @getSource()"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/form_view.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/form_view.coffee","type":"component_definition","class_name":"Luca.components.FormView","header_documentation":"<p>The FormView component is a special container which provides functionality\naround the components inside which extend from the Luca.core.Field class.\nThe FormView component integrates well with Luca.Models and can control\nthe attributes on that model, respond to validations, and submit changes\nto an API.</p>\n","type_alias":"form_view","css_class_identifier":"luca-form-view","defines_methods":{"initialize":{"defined_on_line":110,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"onFieldChange":{"defined_on_line":138,"documentation":"","arguments":[{"argument":"field","value":null},{"argument":"e","value":null}]},"getDefaultToolbar":{"defined_on_line":142,"documentation":"","arguments":[]},"applyStyleClasses":{"defined_on_line":146,"documentation":"","arguments":[]},"applyBootstrapStyleClasses":{"defined_on_line":153,"documentation":"","arguments":[]},"resetHandler":{"defined_on_line":161,"documentation":"","arguments":[{"argument":"e","value":null}]},"submitHandler":{"defined_on_line":170,"documentation":"","arguments":[{"argument":"e","value":null}]},"afterComponents":{"defined_on_line":180,"documentation":"","arguments":[]},"eachField":{"defined_on_line":188,"documentation":"","arguments":[{"argument":"iterator","value":null}]},"getField":{"defined_on_line":191,"documentation":"","arguments":[{"argument":"name","value":null}]},"getFields":{"defined_on_line":197,"documentation":"","arguments":[{"argument":"attr","value":null},{"argument":"value","value":null}]},"loadModel":{"defined_on_line":208,"documentation":"","arguments":[{"argument":"model","value":null}]},"reset":{"defined_on_line":230,"documentation":"","arguments":[]},"clear":{"defined_on_line":233,"documentation":"","arguments":[]},"isDirty":{"defined_on_line":242,"documentation":"","arguments":[]},"setValues":{"defined_on_line":247,"documentation":"<p>set the values on the form\nwithout syncing</p>\n","arguments":[{"argument":"source","value":null},{"argument":"options","value":"{}"}]},"getValues":{"defined_on_line":270,"documentation":"<p>Public: returns a hash of values for the form fields in this view.</p>\n\n<p>options - An options Hash to control the behavior of values returned (default: {}):\nreject<em>blank: don&#39;t include values which are blank (default: true)\nskip</em>buttons: don&#39;t include button fields (default: true)\nblanks: an inverse alias for reject_blank (default: false)</p>\n","arguments":[{"argument":"options","value":"{}"}]},"removeErrors":{"defined_on_line":309,"documentation":"","arguments":[]},"displayErrors":{"defined_on_line":316,"documentation":"","arguments":[{"argument":"errors","value":null}]},"displayValidationErrorsMessage":{"defined_on_line":326,"documentation":"","arguments":[]},"submit_success_handler":{"defined_on_line":329,"documentation":"","arguments":[{"argument":"model","value":null},{"argument":"response","value":null},{"argument":"xhr","value":null}]},"submit_fatal_error_handler":{"defined_on_line":338,"documentation":"","arguments":[{"argument":"model","value":null},{"argument":"response","value":null},{"argument":"xhr","value":null}]},"submit":{"defined_on_line":348,"documentation":"","arguments":[{"argument":"save","value":"true"},{"argument":"saveOptions","value":"{}"}]},"hasModel":{"defined_on_line":359,"documentation":"","arguments":[]},"currentModel":{"defined_on_line":362,"documentation":"","arguments":[{"argument":"options","value":"{}"}]},"applyFormValuesToModel":{"defined_on_line":368,"documentation":"","arguments":[{"argument":"options","value":null}]},"setLegend":{"defined_on_line":371,"documentation":"","arguments":[{"argument":"@legend","value":null}]},"flash":{"defined_on_line":374,"documentation":"","arguments":[{"argument":"message","value":null}]},"successMessage":{"defined_on_line":382,"documentation":"","arguments":[{"argument":"message","value":null}]},"errorMessage":{"defined_on_line":389,"documentation":"","arguments":[{"argument":"message","value":null}]},"setupToolbar":{"defined_on_line":394,"documentation":"","arguments":[]}},"defines_properties":{"trackDirtyState":{"defined_on_line":35,"documentation":"<p>track dirty state will bind to change events\non all of the underlying fields, and set a\nflag whenever one of them changes</p>\n","default":""},"trackModelChanges":{"defined_on_line":38,"documentation":"<p>don&#39;t setup two way binding to the model</p>\n","default":""},"labelAlign":{"defined_on_line":42,"documentation":"<p>should the label display above, or to the\nside of the fields</p>\n","default":""},"fieldLayoutClass":{"defined_on_line":46,"documentation":"<p>specifying this class gives you the ability\nto layout the nested fields accordingly.</p>\n","default":""},"toolbar":{"defined_on_line":55,"documentation":"<p>available options are true, false, &quot;top&quot;, &quot;bottom&quot;, or &quot;both&quot;\nthe component configuration for the toolbar can be controlled\nby specifying a name of a property that contains a valid\ncomponent reference ( either hash w/ type reference )</p>\n","default":""},"toolbarConfig":{"defined_on_line":60,"documentation":"<p>the name of the property which contains the configuration\nfor the buttons that will go in this toolbar.  Specify\na string so it can be lazily evaluated at initialization.</p>\n","default":""},"defaultToolbar":{"defined_on_line":66,"documentation":"<p>the default toolbar definition that will be created if\nthe form is configured to have a toolbar on it.  this value\nwill be resolved at initialization, so pass a string identifying\nan object in memory.</p>\n","default":""},"loadMask":{"defined_on_line":71,"documentation":"<p>if this form will be submitting values to a RESTful API and you\nwant to show a loading indicator or progress bar, configure the\n@loadMask property.</p>\n","default":""},"well":{"defined_on_line":75,"documentation":"<p>Applies the twitter bootstrap well class to this form.\n@$el.addClass(&#39;well&#39;) if @well</p>\n","default":""},"searchForm":{"defined_on_line":79,"documentation":"<p>Applies the twitter bootstrap form-search class to this form.\n@$el.addClass(&#39;form-search&#39;) if @searchForm</p>\n","default":""},"horizontalForm":{"defined_on_line":83,"documentation":"<p>Applies the twitter bootstrap horizontal form class to this form.\n@$el.addClass(&#39;form-horizontal&#39;) if @horizontalForm</p>\n","default":""},"inlineForm":{"defined_on_line":87,"documentation":"<p>Applies the twitter bootstrap inline form class to this form.\n@$el.addClass(&#39;form-inline&#39;) if @inlineForm</p>\n","default":""},"includeBlankValues":{"defined_on_line":91,"documentation":"<p>if we should always include blank values\nregardless of how the field is configured</p>\n","default":""},"tagName":{"defined_on_line":94,"documentation":"","default":""},"bodyClassName":{"defined_on_line":103,"documentation":"","default":""},"successFlashDelay":{"defined_on_line":380,"documentation":"","default":""},"version":{"defined_on_line":420,"documentation":"","default":""}},"source_file_contents":"# The FormView component is a special container which provides functionality\n# around the components inside which extend from the Luca.core.Field class.\n#\n# The FormView component integrates well with Luca.Models and can control\n# the attributes on that model, respond to validations, and submit changes\n# to an API.\nformView = Luca.register        \"Luca.components.FormView\"\n\nformView.extends                \"Luca.Container\"\n\nformView.mixesIn                \"LoadMaskable\",\n                                \"FormModelBindings\"\n\nformView.triggers               \"before:submit\",\n                                \"before:reset\",\n                                \"before:load\",\n                                \"before:load:new\",\n                                \"before:load:existing\",\n                                \"after:submit\",\n                                \"after:reset\",\n                                \"after:load\",\n                                \"after:load:new\",\n                                \"after:load:existing\",\n                                \"after:submit:success\",\n                                \"after:submit:fatal_error\",\n                                \"after:submit:error\",\n                                \"state:change:dirty\"\n\n\n\nformView.publicConfiguration\n  # track dirty state will bind to change events\n  # on all of the underlying fields, and set a\n  # flag whenever one of them changes\n  trackDirtyState: false\n\n  # don't setup two way binding to the model\n  trackModelChanges: false\n\n  # should the label display above, or to the\n  # side of the fields\n  labelAlign: undefined\n\n  # specifying this class gives you the ability\n  # to layout the nested fields accordingly.\n  fieldLayoutClass: undefined\n\n  # should this form have a legend?\n  legend: \"\"\n\n  # available options are true, false, \"top\", \"bottom\", or \"both\"\n  # the component configuration for the toolbar can be controlled\n  # by specifying a name of a property that contains a valid\n  # component reference ( either hash w/ type reference )\n  toolbar: true\n\n  # the name of the property which contains the configuration\n  # for the buttons that will go in this toolbar.  Specify\n  # a string so it can be lazily evaluated at initialization.\n  toolbarConfig: undefined\n\n  # the default toolbar definition that will be created if\n  # the form is configured to have a toolbar on it.  this value\n  # will be resolved at initialization, so pass a string identifying\n  # an object in memory.\n  defaultToolbar: \"Luca.components.FormView.defaultToolbar\"\n\n  # if this form will be submitting values to a RESTful API and you\n  # want to show a loading indicator or progress bar, configure the\n  # @loadMask property.\n  loadMask: true\n\n  # Applies the twitter bootstrap well class to this form.\n  # @$el.addClass('well') if @well\n  well: false\n\n  # Applies the twitter bootstrap form-search class to this form.\n  # @$el.addClass('form-search') if @searchForm\n  searchForm: false\n\n  # Applies the twitter bootstrap horizontal form class to this form.\n  # @$el.addClass('form-horizontal') if @horizontalForm\n  horizontalForm: false\n\n  # Applies the twitter bootstrap inline form class to this form.\n  # @$el.addClass('form-inline') if @inlineForm\n  inlineForm: false\n\n  # if we should always include blank values\n  # regardless of how the field is configured\n  includeBlankValues: undefined\n\nformView.privateConfiguration\n  tagName: 'form'\n\n  # These events will get registered on the component\n  # but still leave the @events property open to extend\n  # for any component which inherits from us.\n  _events:\n    \"click .submit-button\" : \"submitHandler\"\n    \"click .reset-button\" : \"resetHandler\"\n\n  bodyClassName: \"form-view-body\"\n\n  stateful:\n    dirty: false\n    currentModel: undefined\n\nformView.privateMethods\n  initialize: (@options={})->\n    form = @\n\n    @loadMask = Luca.config.enableBoostrap unless @loadMask?\n\n    Luca.Container::initialize.apply @, arguments\n\n    @components ||= @fields\n\n    _.bindAll @, \"submitHandler\", \"resetHandler\", \"renderToolbars\"\n\n    # have our events be internal to the view, and not\n    # part of the normal @events chain, so they can be inherited\n    for eventId, handler of @_events\n      @registerEvent(eventId, handler)\n\n    if @trackDirtyState is true\n      @on \"after:components\", ()->\n        for field in @getFields()\n          field.on \"on:change\", @onFieldChange, form\n      , form\n\n    @setupHooks( @hooks )\n\n    @applyStyleClasses()\n\n    Luca.components.FormView.setupToolbar.call(@)\n\n  onFieldChange: (field, e)->\n    @trigger \"field:change\", field, e\n    @state.set('dirty', true)\n\n  getDefaultToolbar: ()->\n    config = @toolbarConfig || @defaultToolbar\n    Luca.util.resolve( Luca.util.read(config) )\n\n  applyStyleClasses: ()->\n    if Luca.config.enableBoostrap\n      @applyBootstrapStyleClasses()\n\n    @$el.addClass( \"label-align-#{ @labelAlign }\") if @labelAlign\n    @$el.addClass( @fieldLayoutClass ) if @fieldLayoutClass\n\n  applyBootstrapStyleClasses: ()->\n    @inlineForm = true if @labelAlign is \"left\"\n\n    @$el.addClass('well') if @well\n    @$el.addClass('form-search') if @searchForm\n    @$el.addClass('form-horizontal') if @horizontalForm\n    @$el.addClass('form-inline') if @inlineForm\n\n  resetHandler: (e)->\n    me = my = $( e?.target )\n    if @beforeReset?\n      result = @beforeReset()\n      return if result is false\n\n    @reset()\n    @trigger \"after:reset\", @\n\n  submitHandler: (e)->\n    if @beforeSubmit?\n      result = @beforeSubmit()\n      return if result is false\n    else\n      @trigger \"before:submit\", @\n\n    @trigger \"enable:loadmask\", @ if @loadMask is true\n    @submit() if @hasModel()\n\n  afterComponents: ()->\n    Luca.Container::afterComponents?.apply(@, arguments)\n\n    form = @\n    @eachField (field)->\n      field.getForm = ()=> form\n      field.getModel = ()=> form.currentModel()\n\n  eachField: (iterator)->\n    _( @getFields() ).map( iterator )\n\n  getField: (name)->\n    passOne = _( @getFields('name', name) ).first()\n    return passOne if passOne?\n\n    _( @getFields('input_name', name) ).first()\n\n  getFields: (attr,value)->\n    fields = @selectByAttribute(\"isField\", true, true)\n\n    if attr? and value?\n      fields = _(fields).select (field)->\n        property  = field[ attr ]\n        property  = property.call(field) if _.isFunction(property)\n        property is value\n\n    fields\n\n  loadModel: (model)->\n    form = @\n    fields = @getFields()\n\n    @state.set('dirty', false)\n\n    @trigger \"before:load\", @, model\n\n    if model\n      model.beforeFormLoad?.apply(model, @)\n      event = \"before:load:#{ (if model.isNew() then \"new\" else \"existing\")}\"\n      @trigger event, @, model\n\n    @state.set('currentModel', model)\n\n    @setValues(model || {}, silent: true)\n\n    @trigger \"after:load\", @, model\n\n    if model\n      @trigger \"after:load:#{ (if model.isNew() then \"new\" else \"existing\")}\", @, model\n\n  reset: ()->\n    @loadModel( @state.get('currentModel') )\n\n  clear: ()->\n    @state.set('currentModel', @defaultModel?() )\n\n    _( @getFields() ).each (field)=>\n      try\n        field.setValue('')\n      catch e\n        console.log \"Error Clearing\", @, field\n\n  isDirty: ()->\n    !!@state.get('dirty')\n\n  # set the values on the form\n  # without syncing\n  setValues: (source, options={})->\n    source ||= @currentModel()\n    fields = @getFields()\n\n    _( fields ).each (field) =>\n      field_name = field.input_name || field.name\n\n      if source?[field_name]\n        value = Luca.util.read( source[field_name] )\n\n      if !value and Luca.isBackboneModel(source)\n        value = source.get(field_name)\n\n      field?.setValue( value ) unless field.readOnly is true\n\n    @applyFormValuesToModel() unless options.silent? is true\n\n  # Public: returns a hash of values for the form fields in this view.\n  #\n  # options - An options Hash to control the behavior of values returned (default: {}):\n  #           reject_blank: don't include values which are blank (default: true)\n  #           skip_buttons: don't include button fields (default: true)\n  #           blanks: an inverse alias for reject_blank (default: false)\n  getValues: (options={})->\n    options.reject_blank = true unless options.reject_blank?\n    options.skip_buttons = true unless options.skip_buttons?\n    options.reject_blank = true if options.blanks is false\n\n    values = _( @getFields() ).inject (memo,field)=>\n      value   = field.getValue()\n      key     = field.input_name || field.name\n\n      valueIsBlank      = !!(_.str.isBlank( value ) || _.isUndefined( value ))\n\n      allowBlankValues  = not options.reject_blank and not field.send_blanks\n      allowBlankValues = true if field.includeBlank is true or @includeBlankValues is true\n\n\n      if options.debug\n        console.log \"#{ key } Options\", options, \"Value\", value, \"Value Is Blank?\", valueIsBlank, \"Allow Blanks?\", allowBlankValues\n\n      if options.skip_buttons and field.isButton\n        skip = true\n      else\n        if valueIsBlank and allowBlankValues is false\n          skip = true\n\n        if field.input_name is \"id\" and valueIsBlank is true\n          skip = true\n\n      if options.debug\n        console.log \"Skip is true on #{ key }\"\n\n      if skip isnt true\n        memo[ key ] = value\n\n      memo\n\n    , (options.defaults || {})\n\n    values\n\n  removeErrors: ()->\n    @$('.alert.alert-error').remove()\n    @$el.removeClass('error')\n\n    for field in @getFields()\n      field.clearErrors()\n\n  displayErrors: (errors)->\n    has_errors = false\n    for field in @getFields()\n      for field_name, field_errors of errors when field_name is field.input_name\n        field.displayErrors(field_errors)\n        has_errors = true\n\n    if has_errors\n      @$el.addClass('error')\n\n  displayValidationErrorsMessage: ()->\n    @errorMessage('Please fix the fields with errors')\n\n  submit_success_handler: (model, response, xhr)->\n    @trigger \"after:submit\", @, model, response\n    @trigger \"disable:loadmask\", @ if @loadMask is true\n\n    if response and response?.success is true\n      @trigger \"after:submit:success\", @, model, response\n    else\n      @trigger \"after:submit:error\", @, model, response\n\n  submit_fatal_error_handler: (model, response, xhr)->\n    @trigger \"after:submit\", @, model, response\n    @trigger \"after:submit:fatal_error\", @, model, response\n\n    try\n      json = $.parseJSON(response.responseText)\n      if !json.success && json.errors?\n        @displayValidationErrorsMessage()\n        @displayErrors(json.errors)\n\n  submit: (save=true, saveOptions={})->\n    _.bindAll @, \"submit_success_handler\", \"submit_fatal_error_handler\"\n\n    saveOptions.success ||= @submit_success_handler\n    saveOptions.error ||= @submit_fatal_error_handler\n\n    @removeErrors()\n    @applyFormValuesToModel()\n    return unless save\n    @currentModel()?.save( @currentModel().toJSON(), saveOptions )\n\n  hasModel: ()->\n    @currentModel()?\n\n  currentModel: (options={})->\n    if options is true or options?.refresh is true\n      @applyFormValuesToModel()\n\n    @state.get('currentModel')\n\n  applyFormValuesToModel: (options)->\n    @currentModel()?.set( @getValues(), options )\n\n  setLegend: (@legend)->\n    $('fieldset legend', @el).first().html(@legend)\n\n  flash: (message)->\n    if @$('.toolbar-container.top').length > 0\n      @$('.toolbar-container.top').after(message)\n    else\n      @$bodyEl().prepend(message)\n\n  successFlashDelay: 1500\n\n  successMessage: (message)->\n    @$('.alert.alert-success').remove()\n    @flash Luca.template(\"components/form_alert\", className:\"alert alert-success\", message: message)\n    _.delay ()=>\n      @$('.alert.alert-success').fadeOut()\n    , @successFlashDelay || 0\n\n  errorMessage: (message)->\n    @$('.alert.alert-error').remove()\n    @flash Luca.template(\"components/form_alert\", className:\"alert alert-error\", message: message)\n\nformView.classInterface\n  setupToolbar: ()->\n    if @toolbar isnt false and (not @topToolbar and not @bottomToolbar)\n      if @toolbar is \"both\" or @toolbar is \"top\"\n        @topToolbar = _.clone( @getDefaultToolbar() )\n\n      unless @toolbar is \"top\"\n        @bottomToolbar = _.clone( @getDefaultToolbar() )\n\n  defaultToolbar:\n    buttons:[\n      icon:\"remove-sign\"\n      label: \"Reset\"\n      eventId: \"click:reset\"\n      className:\"reset-button\"\n      align: 'right'\n    ,\n      icon:\"ok-sign\"\n      white: true\n      label: \"Save Changes\"\n      eventId: \"click:submit\"\n      color: \"success\"\n      className: 'submit-button'\n      align: 'right'\n    ]\n\nformView.defines\n  version: 2\n\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/grid_layout_view.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/grid_layout_view.coffee","type":"component_definition","class_name":"Luca.components.GridLayoutView","header_documentation":"","type_alias":"grid_layout_view","css_class_identifier":"luca-grid-layout-view","defines_methods":{"attributesForItem":{"defined_on_line":19,"documentation":"<p>adds the bootstrap span class to each collection-item,\nwhere span class is equal to the 12 column grid / @itemsPerRow.\nfor example, each item would receive a span4 class when @itemsPerRow = 3</p>\n","arguments":[]},"renderModels":{"defined_on_line":29,"documentation":"<p>wraps every N number of rows, where N = @itemsPerRow\nin a row-fluid wrapper, and appends it to the view</p>\n","arguments":[{"argument":"models","value":null}]}},"defines_properties":{"itemsPerRow":{"defined_on_line":8,"documentation":"<p>how many items do you wish to render per row?\nassuming a 12 column grid, each item will receive\nan equal amount of grid span/columns.</p>\n","default":""},"className":{"defined_on_line":11,"documentation":"","default":""},"tagName":{"defined_on_line":12,"documentation":"","default":""},"itemTagName":{"defined_on_line":13,"documentation":"","default":""}},"source_file_contents":"gridView = Luca.register    \"Luca.components.GridLayoutView\"\ngridView.extends            \"Luca.CollectionView\"\n\ngridView.publicConfiguration\n  # how many items do you wish to render per row?\n  # assuming a 12 column grid, each item will receive\n  # an equal amount of grid span/columns.\n  itemsPerRow: 3\n\ngridView.privateConfiguration\n  className: \"grid-layout-view\"\n  tagName: \"div\"\n  itemTagName: \"div\"\n\ngridView.privateMethods\n  # adds the bootstrap span class to each collection-item,\n  # where span class is equal to the 12 column grid / @itemsPerRow.\n  # for example, each item would receive a span4 class when @itemsPerRow = 3\n  attributesForItem: ()->\n    base = Luca.CollectionView::attributesForItem.apply(@, arguments)\n    @itemsPerRow = 3 unless _.isNumber(@itemsPerRow) and @itemsPerRow > 1\n    columns = parseInt(12 / @itemsPerRow)\n    base.class += \" span#{ columns }\"\n\n    base\n\n  # wraps every N number of rows, where N = @itemsPerRow\n  # in a row-fluid wrapper, and appends it to the view\n  renderModels: (models)->\n    index = 0\n    rowIndex = 0\n\n    rows = for model in models\n      row = @make(\"div\", class:\"row-fluid\") if rowIndex++ is 0\n      $(row).append @makeItem(model,index++)\n      rowIndex = 0 if index > 0 and index % @itemsPerRow is 0\n      row\n\n    console.log \"Appending rows\", rows\n    for row in rows\n      @$append(row) \n\ngridView.register()\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/load_mask.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/load_mask.coffee","type":"component_definition","class_name":"Luca.components.LoadMask","header_documentation":"<p>#_.def(&quot;Luca.components.LoadMask&quot;).extends(&quot;Luca.View&quot;).with</p>\n","type_alias":"load_mask","css_class_identifier":"luca-load-mask","defines_methods":{},"defines_properties":{"className":{"defined_on_line":7,"documentation":"","default":""},"bodyTemplate":{"defined_on_line":8,"documentation":"","default":""}},"source_file_contents":"#_.def(\"Luca.components.LoadMask\").extends(\"Luca.View\").with\nloadMask = Luca.register  \"Luca.components.LoadMask\"\n\nloadMask.extends          \"Luca.View\"\n\nloadMask.defines\n  className: \"luca-ui-load-mask\"\n  bodyTemplate:\"components/load_mask\"\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/multi_collection_view.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/multi_collection_view.coffee","type":"component_definition","class_name":"Luca.components.MultiCollectionView","header_documentation":"","type_alias":"multi_collection_view","css_class_identifier":"luca-multi-collection-view","defines_methods":{"initialize":{"defined_on_line":42,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"relayAfterRefresh":{"defined_on_line":54,"documentation":"","arguments":[{"argument":"models","value":null},{"argument":"query","value":null},{"argument":"options","value":null}]},"refresh":{"defined_on_line":57,"documentation":"","arguments":[]},"propagateCollectionComponents":{"defined_on_line":61,"documentation":"","arguments":[]},"validateComponent":{"defined_on_line":81,"documentation":"","arguments":[{"argument":"component","value":null}]}},"defines_properties":{"version":{"defined_on_line":92,"documentation":"","default":""}},"source_file_contents":"multiView = Luca.register     \"Luca.components.MultiCollectionView\"\n\n# The CollectionMultiView is a collection view with multiple renderings\n# of the list.  ( e.g. Icons, Table, List ).  It works by maintaining\n# a current view, and rendering that view.  It refreshes the views\n# whenever they are activated. \n#\n# The MultiView allows you to share one collection, filter, pagination setup\n# but render multiple versions of a model.  To do this, you  are expected to\n# define one or more objects in the @views property of the component.\n\n# Example:\n#   multiView = new Luca.components.MultiCollectionView\n#     collection: \"my_collection\"\n#     paginatable:\n#       page: 1\n#       limit: 20\n#     views:[\n#       type:           \"table\"\n#       columns:[\n#         header: \"Header\"\n#         reader: \"attribute\"\n#       ]\n#     ]\nmultiView.extends           \"Luca.containers.CardView\"\n\nmultiView.mixesIn           \"QueryCollectionBindings\", \n                            \"LoadMaskable\",\n                            \"Filterable\",\n                            \"Paginatable\",\n                            \"Sortable\"\n\nmultiView.triggers          \"before:refresh\",\n                            \"after:refresh\",\n                            \"refresh\",\n                            \"empty:results\"\n\nmultiView.private\n  stateful:\n    activeView: 0\n\n  initialize: (@options={})->\n    @components ||= @views\n\n    for view in @components    \n      Luca.components.MultiCollectionView.validateComponent( view ) \n\n    Luca.containers.CardView::initialize.apply(@, arguments) \n\n    @on \"data:refresh\", @refresh, @\n    @on \"after:card:switch\", @refresh, @\n    @on \"after:components\", Luca.components.MultiCollectionView.propagateCollectionComponents, @\n\n  relayAfterRefresh: (models,query,options)->\n    @trigger \"after:refresh\", models, query, options\n\n  refresh: ()->\n    @activeComponent()?.refresh()\n\nmultiView.classMethods\n  propagateCollectionComponents: ()->\n    container = @\n\n    # in the multi view will share the same\n    # collection, filter state, pagination options, etc\n    for component in @components\n\n      component.on \"after:refresh\", (models,query,options)=> \n        @debug \"collection member after refresh\"\n        @trigger(\"after:refresh\",models,query,options)\n\n      _.extend component, \n        collection: container.getCollection() \n        getQuery: _.bind(container.getQuery, container)\n        getQueryOptions: _.bind(container.getQueryOptions, container)\n\n      if container.prepareQuery?\n        _.extend component,\n          prepareQuery: _.bind(container.prepareQuery, container)\n\n  validateComponent: (component)->\n    type = (component.type || component.ctype)\n\n    return if  type is \"collection\" or \n               type is \"collection_view\" or\n               type is \"table\" or\n               type is \"table_view\" \n\n    throw \"The MultiCollectionView expects to contain multiple collection views\" \n\nmultiView.defines\n  version: 3\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/nav_bar.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/nav_bar.coffee","type":"component_definition","class_name":"Luca.components.NavBar","header_documentation":"<p>A Twitter Bootstrap compatible navigation bar.  The Luca.Application\nand Luca.containers.Viewport class both have configuration options for\ncreating navbar components in the header and footer of the viewport.</p>\n\n<h4>Example of an Application with a Navbar</h4>\n\n<h5>Component Definition</h5>\n\n<pre><code>  # Navigation Component\n  navBar = Luca.register  &quot;App.views.TopNavigation&quot;\n  navBar.extends          &quot;Luca.components.NavBar&quot;\n  navBar.defines\n    brand: &quot;My App&quot;\n    # for white on black\n    inverse: true\n</code></pre>\n\n<p>We are able to reference the component we just defined in the\nconfiguration of the Application, simply by using it&#39;s \ntype alias <code>top_navigation</code>\n      # Application Component\n      app = Luca.register       &quot;App.Application&quot;\n      app.extends               &quot;Luca.Application&quot;\n      app.defines\n        topNav: &quot;top_navigation&quot;</p>\n","type_alias":"nav_bar","css_class_identifier":"luca-nav-bar","defines_methods":{"beforeRender":{"defined_on_line":54,"documentation":"","arguments":[]},"render":{"defined_on_line":70,"documentation":"","arguments":[]},"navContainer":{"defined_on_line":73,"documentation":"","arguments":[]},"content":{"defined_on_line":76,"documentation":"","arguments":[]}},"defines_properties":{"fixed":{"defined_on_line":31,"documentation":"<p>Specify whether the navbar is supposed to be fixed\nthe way Twitter bootstrap navbar can be.</p>\n","default":""},"position":{"defined_on_line":34,"documentation":"<p>Valid options are &#39;top&#39;, &#39;bottom&#39;.  Only valid when <code>@fixed is true</code></p>\n","default":""},"fluid":{"defined_on_line":38,"documentation":"<p>Specify whether the navbar should use the fluid grid.\nUsually the same as your Viewport setting.</p>\n","default":""},"brand":{"defined_on_line":42,"documentation":"<p>What content do you want to show in the logo area of the\nstandard bootstrap nav</p>\n","default":""},"template":{"defined_on_line":47,"documentation":"<p>Specifies an optional template to use for the navigation menu\ncontent.  Whatever you specify will be rendered inside of the\ncollapsible container inside of the standard bootstrap nav.</p>\n","default":""},"className":{"defined_on_line":50,"documentation":"","default":""},"bodyTemplate":{"defined_on_line":51,"documentation":"","default":""},"bodyClassName":{"defined_on_line":52,"documentation":"","default":""}},"source_file_contents":"# A Twitter Bootstrap compatible navigation bar.  The Luca.Application\n# and Luca.containers.Viewport class both have configuration options for\n# creating navbar components in the header and footer of the viewport.\n#\n# #### Example of an Application with a Navbar\n# ##### Component Definition\n#       # Navigation Component\n#       navBar = Luca.register  \"App.views.TopNavigation\"\n#       navBar.extends          \"Luca.components.NavBar\"\n#       navBar.defines\n#         brand: \"My App\"\n#         # for white on black\n#         inverse: true\n#\n# We are able to reference the component we just defined in the\n# configuration of the Application, simply by using it's \n# type alias `top_navigation`\n#\n#       # Application Component\n#       app = Luca.register       \"App.Application\"\n#       app.extends               \"Luca.Application\"\n#       app.defines\n#         topNav: \"top_navigation\"\n#\nnavBar = Luca.register \"Luca.components.NavBar\"\nnavBar.extends         \"Luca.View\"\n\nnavBar.publicConfiguration\n  # Specify whether the navbar is supposed to be fixed\n  # the way Twitter bootstrap navbar can be.\n  fixed: true\n\n  # Valid options are 'top', 'bottom'.  Only valid when `@fixed is true`\n  position: 'top'\n\n  # Specify whether the navbar should use the fluid grid. \n  # Usually the same as your Viewport setting.\n  fluid: undefined\n\n  # What content do you want to show in the logo area of the\n  # standard bootstrap nav\n  brand: \"Luca.js\"\n\n  # Specifies an optional template to use for the navigation menu\n  # content.  Whatever you specify will be rendered inside of the \n  # collapsible container inside of the standard bootstrap nav.\n  template: undefined\n\nnavBar.privateConfiguration\n  className: 'navbar'\n  bodyTemplate: 'nav_bar'\n  bodyClassName: 'luca-ui-navbar-body'\n\n  beforeRender: ()->\n    @$el.addClass \"navbar-fixed-#{ @position }\" if @fixed\n    @$el.addClass \"navbar-inverse\" if @inverse is true\n\n    if @brand?\n      @$('.brand').attr('href', @homeLink || '#')\n      @$('.brand').html(@brand)\n\n    if @template\n      @navContainer().html Luca.template(@template, @)\n\n    if !!(@fluid || Luca.getApplication()?.fluid)\n      @content().addClass( Luca.config.fluidWrapperClass )\n    else\n      @content().addClass( Luca.config.wrapperClass )\n\n  render: ()->\n    @\n\n  navContainer: ()->\n    @$('.luca-ui-navbar-body .nav-collapse')\n\n  content: ()->\n    @$('.luca-ui-navbar-body').eq(0)\n\n\nnavBar.register()"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/page.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/page.coffee","type":"component_definition","class_name":"Luca.components.Page","header_documentation":"<p>The <code>Page</code> is a type of <code>Container</code> that has\nall of its subcomponents visible at one time, \nand assigned to various <code>@regions</code> that exist\nin the <code>@layout</code> template which provide its \ninternal dom structure.</p>\n\n<h4>Example Template (haml):</h4>\n\n<pre><code>  .page.layout.row-fluid{&quot;data-layout&quot;=&gt;&quot;layouts/left_nav_grid&quot;}\n    .span3.region{&quot;data-region&quot;=&gt;&quot;left&quot;}\n    .span9.region{&quot;data-region&quot;=&gt;&quot;right&quot;}\n</code></pre>\n\n<h3>Example Page Configuration</h3>\n\n<pre><code>page = new Luca.components.Page\n  layout: &quot;layouts/left_nav_grid&quot;\n  regions:\n    left: \n      type: &quot;navigation&quot;\n    right:\n      type: &quot;details&quot;\n</code></pre>\n","type_alias":"page","css_class_identifier":"luca-page","defines_methods":{"initialize":{"defined_on_line":26,"documentation":"<p><code>Page</code>s are typically instantiated by a <code>Luca.components.Controller</code></p>\n","arguments":[{"argument":"@options","value":"{}"}]},"assignComponentsToRegions":{"defined_on_line":33,"documentation":"<p>Takes the configuration specified in @regions\nand creates a components hash out of them.</p>\n","arguments":[]}},"defines_properties":{"layout":{"defined_on_line":53,"documentation":"","default":""}},"source_file_contents":"# The `Page` is a type of `Container` that has\n# all of its subcomponents visible at one time, \n# and assigned to various `@regions` that exist\n# in the `@layout` template which provide its \n# internal dom structure.\n#\n# #### Example Template (haml):\n#       .page.layout.row-fluid{\"data-layout\"=>\"layouts/left_nav_grid\"}\n#         .span3.region{\"data-region\"=>\"left\"}\n#         .span9.region{\"data-region\"=>\"right\"}\n#\n# ### Example Page Configuration\n#     page = new Luca.components.Page\n#       layout: \"layouts/left_nav_grid\"\n#       regions:\n#         left: \n#           type: \"navigation\"\n#         right:\n#           type: \"details\"\n#\npage = Luca.register       \"Luca.components.Page\"\npage.extends               \"Luca.Container\"\n\npage.privateMethods\n  # `Page`s are typically instantiated by a `Luca.components.Controller`\n  initialize: (@options={})->\n    @assignComponentsToRegions()\n    @bodyTemplate = @options.layout || @layout\n    Luca.Container::initialize.apply(@, arguments)\n\n  # Takes the configuration specified in @regions\n  # and creates a components hash out of them.\n  assignComponentsToRegions: ()->\n    @components ||= []\n\n    assigned = for regionId, regionAssignment of @regions\n      if _.isString(regionAssignment) and componentClass = Luca.registry.lookup( regionAssignment )\n        regionAssignment = \n          component: regionAssignment\n      else if _.isString(regionAssignment) and Luca.template(regionAssignment)\n        regionAssignment = \n          bodyTemplate: regionAssignment\n\n      _.extend(regionAssignment, container: \"[data-region='#{ regionId }']\")\n\n    @components = assigned\n\npage.publicConfiguration\n  # The `@layout` property is the equivalent to specifying @bodyTemplate\n  # but more semantic.  A `@layout` template is expected to contain DOM \n  # elements with a data attribute named `region` on it.  \n\n  layout: undefined\n  # The @regions property assigns containers ( by their type alias )\n  # to DOM elements identified as regions within a layout template.\n  #\n  # #### Example:\n  #     new Luca.components.Page\n  #       regions: \n  #         left: \"my_component\"\n  #         right: \n  #           type: \"my_other_component\"\n  #           role: \"component_role\"\n  #\n  #   This will render an instance of MyComponent to this\n  #   page's @$('[data-region-id=\"right\"]') DOM element.\n  regions: {}\n\npage.register()\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/page_controller.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/page_controller.coffee","type":"component_definition","class_name":"Luca.PageController","header_documentation":"","type_alias":"page_controller","css_class_identifier":"luca-page-controller","defines_methods":{},"defines_properties":{},"source_file_contents":"pageController = Luca.register  \"Luca.PageController\"\npageController.extends          \"Luca.components.Controller\"\npageController.register()\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/pagination_control.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/pagination_control.coffee","type":"component_definition","class_name":"Luca.components.PaginationControl","header_documentation":"","type_alias":"pagination_control","css_class_identifier":"luca-pagination-control","defines_methods":{"onPageCountChange":{"defined_on_line":20,"documentation":"","arguments":[]},"limit":{"defined_on_line":23,"documentation":"","arguments":[]},"page":{"defined_on_line":26,"documentation":"","arguments":[]},"nextPage":{"defined_on_line":29,"documentation":"","arguments":[]},"previousPage":{"defined_on_line":33,"documentation":"","arguments":[]},"selectPage":{"defined_on_line":37,"documentation":"","arguments":[{"argument":"e","value":null}]},"setPage":{"defined_on_line":46,"documentation":"","arguments":[{"argument":"page","value":"1"},{"argument":"options","value":"{}"}]},"setLimit":{"defined_on_line":49,"documentation":"","arguments":[{"argument":"limit","value":"1"},{"argument":"options","value":"{}"}]},"pageButtonContainer":{"defined_on_line":52,"documentation":"","arguments":[]},"previousEnabled":{"defined_on_line":55,"documentation":"","arguments":[]},"nextEnabled":{"defined_on_line":58,"documentation":"","arguments":[]},"previousButton":{"defined_on_line":61,"documentation":"","arguments":[]},"nextButton":{"defined_on_line":64,"documentation":"","arguments":[]},"pageButtons":{"defined_on_line":67,"documentation":"","arguments":[]},"updateWithPageCount":{"defined_on_line":70,"documentation":"","arguments":[{"argument":"@pageCount","value":null},{"argument":"models","value":"[]"}]},"toggleNavigationButtons":{"defined_on_line":85,"documentation":"","arguments":[]},"selectActivePageButton":{"defined_on_line":90,"documentation":"","arguments":[]},"activePageButton":{"defined_on_line":93,"documentation":"","arguments":[]},"totalPages":{"defined_on_line":96,"documentation":"","arguments":[]},"totalItems":{"defined_on_line":99,"documentation":"","arguments":[]},"itemsPerPage":{"defined_on_line":102,"documentation":"","arguments":[{"argument":"value","value":null},{"argument":"options","value":"{}"}]}},"defines_properties":{"template":{"defined_on_line":6,"documentation":"","default":""},"stateful":{"defined_on_line":8,"documentation":"","default":""},"autoBindEventHandlers":{"defined_on_line":13,"documentation":"","default":""}},"source_file_contents":"paginationControl = Luca.register   \"Luca.components.PaginationControl\"\n\npaginationControl.extends           \"Luca.View\"\n\npaginationControl.defines\n  template: \"components/pagination\"\n\n  stateful: true\n\n  stateChangeEvents:\n    \"numberOfPages\" : \"onPageCountChange\"\n\n  autoBindEventHandlers: true\n\n  events:\n    \"click a[data-page-number]\" : \"selectPage\"\n    \"click a.next\"              : \"nextPage\"\n    \"click a.prev\"              : \"previousPage\"\n\n  onPageCountChange: ()->\n    @updateWithPageCount( @get('numberOfPages') )\n\n  limit: ()->\n    parseInt (@get('limit') || @collection?.length)\n\n  page: ()->\n    parseInt (@get('page') || 1)\n\n  nextPage: ()->\n    return unless @nextEnabled()\n    @set('page', @page() + 1 )\n\n  previousPage: ()->\n    return unless @previousEnabled()\n    @set('page', @page() - 1 )\n\n  selectPage: (e)->\n    me = my = @$( e.target )\n    me = my = my.closest('a.page') unless me.is('a.page')\n\n    my.siblings().removeClass('is-selected')\n    me.addClass('is-selected')\n\n    @setPage( my.data('page-number') )\n\n  setPage: (page=1,options={})->\n    @set('page', page, options)\n\n  setLimit: (limit=1,options={})->\n    @set('limit', limit, options)\n\n  pageButtonContainer: ()->\n    @$ '.group'\n\n  previousEnabled: ()->\n    @page() > 1\n\n  nextEnabled: ()->\n    @page() < @totalPages()\n\n  previousButton: ()->\n    @$ 'a.page.prev'\n\n  nextButton: ()->\n    @$ 'a.page.next'\n\n  pageButtons: ()->\n    @$ 'a[data-page-number]', @pageButtonContainer()\n\n  updateWithPageCount: (@pageCount, models=[])->\n    modelCount = models.length\n\n    @pageButtonContainer().empty()\n\n    _( @pageCount ).times (index)=>\n      page = index + 1\n      button = @make(\"a\",\"data-page-number\":page, class:\"page\", page )\n      @pageButtonContainer().append(button)\n\n    @toggleNavigationButtons()\n    @selectActivePageButton()\n\n    @\n\n  toggleNavigationButtons: ()->\n    @$('a.next, a.prev').addClass('disabled')\n    @nextButton().removeClass('disabled') if @nextEnabled()\n    @previousButton().removeClass('disabled') if @previousEnabled()\n\n  selectActivePageButton: ()->\n    @activePageButton().addClass('is-selected')\n\n  activePageButton: ()->\n    @pageButtons().filter(\"[data-page-number='#{ @page() }']\")\n\n  totalPages: ()->\n    @pageCount\n\n  totalItems: ()->\n    parseInt @collection?.length || 0\n\n  itemsPerPage: (value, options={})->\n    @set(\"limit\", value, options) if value?\n    parseInt @get(\"limit\")\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/router.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/router.coffee","type":"component_definition","class_name":"Luca.Router","header_documentation":"<p>#_.def(&quot;Luca.Router&quot;).extends(&quot;Backbone.Router&quot;).with</p>\n","type_alias":"router","css_class_identifier":"luca-router","defines_methods":{"initialize":{"defined_on_line":8,"documentation":"","arguments":[{"argument":"@options","value":null}]},"navigate":{"defined_on_line":26,"documentation":"<p>Intercept calls to Backbone.Router.navigate so that we can at least\nbuild a path from the route, even if we don&#39;t trigger the route handler</p>\n","arguments":[{"argument":"route","value":null},{"argument":"triggerRoute","value":"false"}]},"buildPathFrom":{"defined_on_line":34,"documentation":"<p>given a url fragment, construct an argument chain similar to what would be\nemitted from a normal route:#{ name } event that gets triggered\nwhen a route is actually fired.  This is used to trap route changes that happen\nthrough calls to @navigate()</p>\n","arguments":[{"argument":"matchedRoute","value":null}]}},"defines_properties":{},"source_file_contents":"#_.def(\"Luca.Router\").extends(\"Backbone.Router\").with\nrouter = Luca.register  \"Luca.Router\"\nrouter.extends          \"Backbone.Router\"\nrouter.defines\n  routes:\n    \"\" : \"default\"\n\n  initialize: (@options)->\n    _.extend @, @options\n\n    @routeHandlers = _( @routes ).values()\n\n    # when a route handler is fired, the route:route_name event is triggered by the router\n    # unfortunately this doesn't apply to calls to @navigate() so we override Backbone.Router.navigate\n    # and trigger an event separately.\n    _( @routeHandlers ).each (route_id) =>\n      @bind \"route:#{ route_id }\", ()=>\n        @trigger.apply @, [\"change:navigation\", route_id  ].concat( _( arguments ).flatten() )\n\n    Backbone.Router.initialize?.apply(@, arguments)\n\n  #### Router Functions\n\n  # Intercept calls to Backbone.Router.navigate so that we can at least\n  # build a path from the route, even if we don't trigger the route handler\n  navigate: (route, triggerRoute=false)->\n    Backbone.Router.prototype.navigate.apply @, arguments\n    @buildPathFrom( Backbone.history.getFragment() )\n\n  # given a url fragment, construct an argument chain similar to what would be\n  # emitted from a normal route:#{ name } event that gets triggered\n  # when a route is actually fired.  This is used to trap route changes that happen\n  # through calls to @navigate()\n  buildPathFrom: (matchedRoute)->\n    _(@routes).each (route_id, route)=>\n      regex = @_routeToRegExp(route)\n      if regex.test(matchedRoute)\n        args = @_extractParameters(regex, matchedRoute)\n        @trigger.apply @, [\"change:navigation\", route_id].concat( args )\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/simple_collection_view.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/simple_collection_view.coffee","type":"component_definition","class_name":"Luca.components.SimpleCollectionView","header_documentation":"<p>The SimpleCollectionView class is a CollectionView without any of the\nbells and whistles ( filtering, pagination, sorting, etc )</p>\n","type_alias":"simple_collection_view","css_class_identifier":"luca-simple-collection-view","defines_methods":{},"defines_properties":{"filterable":{"defined_on_line":7,"documentation":"","default":""},"paginatable":{"defined_on_line":8,"documentation":"","default":""},"sortable":{"defined_on_line":9,"documentation":"","default":""},"loadMask":{"defined_on_line":10,"documentation":"","default":""}},"source_file_contents":"# The SimpleCollectionView class is a CollectionView without any of the\n# bells and whistles ( filtering, pagination, sorting, etc )\nsimple = Luca.register    \"Luca.components.SimpleCollectionView\"\nsimple.extends            \"Luca.CollectionView\"\n\nsimple.defines\n  filterable: false\n  paginatable: false\n  sortable: false\n  loadMask: false"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/table_view.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/table_view.coffee","type":"component_definition","class_name":"Luca.components.TableView","header_documentation":"","type_alias":"table_view","css_class_identifier":"luca-table-view","defines_methods":{"lastColumn":{"defined_on_line":21,"documentation":"","arguments":[]},"eachColumn":{"defined_on_line":24,"documentation":"","arguments":[{"argument":"fn","value":null},{"argument":"scope","value":"@"}]},"itemRenderer":{"defined_on_line":29,"documentation":"","arguments":[{"argument":"item","value":null},{"argument":"model","value":null}]},"initialize":{"defined_on_line":32,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"rowRenderer":{"defined_on_line":80,"documentation":"","arguments":[{"argument":"item","value":null},{"argument":"model","value":null},{"argument":"index","value":null}]}},"defines_properties":{"emptyText":{"defined_on_line":7,"documentation":"","default":""},"additionalClassNames":{"defined_on_line":10,"documentation":"","default":""},"tagName":{"defined_on_line":11,"documentation":"","default":""},"bodyTemplate":{"defined_on_line":12,"documentation":"","default":""},"bodyTagName":{"defined_on_line":13,"documentation":"","default":""},"bodyClassName":{"defined_on_line":14,"documentation":"","default":""},"stateful":{"defined_on_line":15,"documentation":"","default":""},"itemTagName":{"defined_on_line":16,"documentation":"","default":""},"observeChanges":{"defined_on_line":17,"documentation":"","default":""}},"source_file_contents":"tableView = Luca.register     \"Luca.components.TableView\"\ntableView.extends             \"Luca.CollectionView\"\n\ntableView.publicConfiguration\n  widths: []\n  columns:[]\n  emptyText: \"There are no results to display\"\n\ntableView.privateConfiguration\n  additionalClassNames: \"table\"\n  tagName: \"table\"\n  bodyTemplate: \"table_view\"\n  bodyTagName: \"tbody\"\n  bodyClassName: \"table-body\"\n  stateful: true\n  itemTagName: \"tr\"\n  observeChanges: true\n\ntableView.privateMethods\n\n  lastColumn: ()->\n    @columns[ @columns.length - 1 ]\n\n  eachColumn: (fn, scope=@)->\n    index = 0\n    for col in @columns  \n      fn.call(scope, col, index++, @)\n\n  itemRenderer: (item, model)->\n    Luca.components.TableView.rowRenderer.call(@, item, model)\n\n  initialize: (@options={})->\n    Luca.components.CollectionView::initialize.apply(@, arguments)\n\n    index = 0\n    @columns = for column in @columns\n      if width = @widths[ index ]\n        column.width = width\n\n      if _.isString(column)\n        column = reader: column\n\n      if !column.header?\n        column.header = _.str.titleize(_.str.humanize(column.reader))\n\n      index++\n      column\n\n    @defer ()=> \n      Luca.components.TableView.renderHeader.call(@, @columns, @$('thead') )\n    .until(\"after:render\")\n\ntableView.classMethods\n  renderHeader : (columns, targetElement)->\n    index = 0\n\n    @$( targetElement ).append(\"<tr></tr>\")\n\n    for column in columns\n      attrs = \"data-col-index\": index++\n\n      if column.sortable\n        attrs.class = \"sortable-toggle\"\n        attrs[\"data-sortable-sort-by\"] = column.sortBy || column.sortable\n        attrs[\"data-sortable-order\"] = column.order\n\n      content = column.header \n      content = \"<a class='link'>#{ column.header }</a>\" if column.sortable\n\n      @$(targetElement).find('tr').append( Luca.View::make \"th\", attrs, content )\n\n\n    index = 0\n\n    for column in columns when column.width?\n      th = @$(\"th[data-col-index='#{ index++ }']\",targetElement)\n      th.css('width', column.width)\n\n\n  rowRenderer: (item, model, index)->\n    colIndex = 0\n    for columnConfig in @columns\n      Luca.components.TableView.renderColumn.call(@, columnConfig, item, model, colIndex++) \n\n  renderColumn : (column, item, model, index)->\n    cellValue = model.read( column.reader )\n\n    if _.isFunction( column.renderer )\n      cellValue = column.renderer.call @, cellValue, model, column \n\n    Luca.View::make(\"td\", {\"data-col-index\":index}, cellValue)\n\ntableView.register()"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/table_view_scrollable.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/table_view_scrollable.coffee","type":"component_definition","class_name":"Luca.components.ScrollableTable","header_documentation":"","type_alias":"scrollable_table","css_class_identifier":"luca-scrollable-table","defines_methods":{"$scrollableWrapperEl":{"defined_on_line":11,"documentation":"","arguments":[]},"setMaxHeight":{"defined_on_line":14,"documentation":"","arguments":[]},"afterRender":{"defined_on_line":18,"documentation":"","arguments":[]}},"defines_properties":{"maxHeight":{"defined_on_line":8,"documentation":"","default":""},"version":{"defined_on_line":23,"documentation":"","default":""}},"source_file_contents":"scrollable = Luca.register      'Luca.components.ScrollableTable'\n\nscrollable.extends              'Luca.components.TableView'\n\nscrollable.replaces             'Luca.components.GridView'\n\nscrollable.publicConfiguration\n  maxHeight: undefined\n\nscrollable.privateMethods\n  $scrollableWrapperEl: ()->\n    @$el.parent('.scrollable-wrapper')\n\n  setMaxHeight: ()->\n    parent = @$scrollableWrapperEl()\n    parent.css('overflow':'auto', 'max-height': @maxHeight)\n\n  afterRender: ()->\n    @$wrap 'scrollable-wrapper'\n    @setMaxHeight()\n\nscrollable.defines\n  version: 1"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/container.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/container.coffee","type":"component_definition","class_name":"Luca.Container","header_documentation":"<p>The Luca.Container is the heart and soul of the Luca framework \nand the component driven design philosophy.  The central idea\nis that every component should be designed as an isolated unit\nwhich completely encapsulates its features.  It should not know about\nother components outside of it.</p>\n\n<p>It is the responsibility of a <code>Luca.Container</code> to define its \nchild <code>@components</code>, render them, and broker communication between them\nin response to events which occur in the user interface.<br>\nA common use case for this would be a page which has a filter form, and\na grid of search results.  The fields in the filter form are used to \nfilter the table.  Neither the form or the table know about each other, \nsince both can be used in other contexts.  A <code>Luca.Container</code> would be used\nto relay events from the form to the table, and in doing so create a higher\nlevel component which can be extended and re-used. </p>\n\n<h4>Using a container to combine a Filter View and Results Table</h4>\n\n<pre><code>    form = Luca.register    &quot;App.views.FilterForm&quot;\n    form.extends            &quot;Luca.components.FormView&quot;\n    form.contains\n      type:   &quot;text&quot;\n      label:  &quot;Filter by&quot;\n      name:   &quot;filter_text&quot;\n    ,\n      type:   &quot;button&quot;\n      className: &quot;filter&quot;\n      value:  &quot;Filter&quot;          \n    form.defines\n      toolbar: false \n</code></pre>\n\n<p>Elsewhere, we have a table that lists records in a collection:</p>\n\n<pre><code>    table = Luca.register     &quot;App.views.ResultsTable&quot;\n    table.extends             &quot;Luca.components.TableView&quot;\n    table.defines \n      striped: true\n      collection: &quot;components&quot;\n      columns:[\n        header: &quot;Component Class&quot;\n        reader: &quot;class_name&quot;\n      ,\n        header: &quot;Component Type Alias&quot;\n        reader: &quot;type_alias&quot;\n      ]\n</code></pre>\n\n<p>We can join these two components together by declaring their relationship\nin a <code>Luca.Container</code>.  Remember the components we defined above are just\nprototypes.  We can override specific instance configuration and properties \nin our container.</p>\n\n<h4>Container Example</h4>\n\n<pre><code>    container = Luca.register     &quot;App.views.ComponentFinder&quot;\n    container.extends             &quot;Luca.Container&quot;\n\n  # This is the same as defining a components property on the component.\n  # The type alias is derived from the name of the component.  It is \n  # a short hand way of referencing a component you might reuse a lot.\n  container.contains\n    type: &quot;filter_form&quot;\n    role: &quot;filter&quot;\n  ,\n    type: &quot;results_table&quot;\n    # change the prototype&#39;s default \n    striped: false\n    role: &quot;results&quot;\n    filterable: true\n  # A Container will generally define some component event bindings\n  # and handler methods to handle the communication between its sub\n  # components.  By default a container is able to access events\n  # from all of its descendants in the hierarchy. \n  container.defines\n    # These will be applied to each of our components.\n    defaults:\n      attributes:\n        &quot;data-attribute&quot;: &quot;whatever&quot;\n    componentEvents:\n      # Any time any of our child components emit\n      # the on:change event, pass it to the filterTable method\n      &quot;* on:change&quot; : &quot;filterTable&quot;\n    # Communicates between the filter and the table&#39;s\n    # underlying collection.  NOtice the use of the @role\n    # property.  It automatically creates getter helpers for us.\n    filterTable: ()-&gt;\n      filter = @getFilter()\n      results = @getResults()\n      # filter.getValues() is a hash of each field and its value\n      results.applyFilter( filter.getValues() )\n</code></pre>\n\n<h3>DOM Layout Configuration</h3>\n\n<p>Another responsibility of the container is to structurally layout its\nchild components in the DOM.  There are a number of different \noptions available depending on how you need to do this.  By default,\na <code>Luca.Container</code> will simply append the @$el of all of its views\nto its own.\nThe <code>Luca.components.Controller</code> is a container which hides every page\nbut the active page.  Similarly, there is the <code>Luca.containers.TabView</code>\nwhich does the same thing, but renders a tab selector menu for you.  You\ncan create any type of interface you want using containers. \nTo make this easy for you, you can do a few different things:</p>\n\n<h4>Use the Twitter Bootstrap Fluid Grid</h4>\n\n<pre><code>    container = Luca.register &quot;App.views.ColumnLayout&quot; \n    container.extends         &quot;App.views.ComponentFinder&quot;\n    container.contains\n      span: 4\n      type: &quot;filter_form&quot;\n      role: &quot;filter&quot;\n    ,\n      span: 8\n      type: &quot;results_table&quot;\n      role: &quot;results&quot;\n    container.defines\n      rowFluid: true\n</code></pre>\n\n<h4>Using a layout template with CSS Selectors</h4>\n\n<pre><code>    ... \n    container.contains\n      role: &quot;filter&quot;\n      container: &quot;#filter-wrapper-dom-selector&quot;\n    ,\n      role: &quot;results&quot;\n      container: &quot;#results-wrapper-dom-selector&quot;\n    ...\n    container.defines\n      # assumes the template will provide the CSS selectors used above \n      bodyTemplate: &quot;layouts/custom_template&quot;\n</code></pre>\n","type_alias":"container","css_class_identifier":"luca-container","defines_methods":{"initialize":{"defined_on_line":183,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"remove":{"defined_on_line":202,"documentation":"","arguments":[]},"beforeRender":{"defined_on_line":207,"documentation":"","arguments":[]},"customizeContainerEl":{"defined_on_line":216,"documentation":"<p>Components which inherit from Luca.Container can implement\ntheir own versions of this method, if they need to apply any sort\nof additional styling / configuration for the DOM elements that\nare created to wrap each container.</p>\n","arguments":[{"argument":"containerEl","value":null},{"argument":"panel","value":null},{"argument":"panelIndex","value":null}]},"prepareLayout":{"defined_on_line":219,"documentation":"","arguments":[]},"prepareComponents":{"defined_on_line":242,"documentation":"","arguments":[]},"createComponents":{"defined_on_line":285,"documentation":"<p>create components is responsible for turning the JSON syntax of the\ncontainer&#39;s definition into live objects against a given Luca Component\ntype.</p>\n\n<p>In addition to this, a container builds an index of the components\nwhich belong to it, so that they can easily be looked up by name</p>\n","arguments":[]},"renderComponents":{"defined_on_line":349,"documentation":"<p>Trigger the Rendering Pipeline process on all of the nested\ncomponents</p>\n","arguments":[{"argument":"@debugMode","value":"\"\""}]},"firstActivation":{"defined_on_line":395,"documentation":"<h3>Container Activation</h3>\n\n<p>When a container is first activated is a good time to perform\noperations which are not needed unless that component becomes\nvisible.  This first activation event should be relayed to all\nof the nested components.  Components which hide / display\nother components, such as a CardView or TabContainer\nwill trigger first:activation on the components as they become\ndisplayed.</p>\n","arguments":[]},"_":{"defined_on_line":405,"documentation":"<h3>Underscore Methods For Working with Components</h3>\n","arguments":[{"argument":")-> _( @components","value":null}]},"pluck":{"defined_on_line":407,"documentation":"","arguments":[{"argument":"attribute","value":null}]},"invoke":{"defined_on_line":410,"documentation":"","arguments":[{"argument":"method","value":null}]},"select":{"defined_on_line":413,"documentation":"","arguments":[{"argument":"fn","value":null}]},"detect":{"defined_on_line":416,"documentation":"","arguments":[{"argument":"fn","value":null}]},"reject":{"defined_on_line":419,"documentation":"","arguments":[{"argument":"fn","value":null}]},"map":{"defined_on_line":422,"documentation":"","arguments":[{"argument":"fn","value":null}]},"registerComponentEvents":{"defined_on_line":425,"documentation":"","arguments":[{"argument":"eventList","value":null},{"argument":"direction","value":"\"on\""}]},"subContainers":{"defined_on_line":447,"documentation":"","arguments":[]},"roles":{"defined_on_line":451,"documentation":"","arguments":[]},"allChildren":{"defined_on_line":454,"documentation":"","arguments":[]},"findComponentForEventBinding":{"defined_on_line":462,"documentation":"","arguments":[{"argument":"nameRoleOrGetter","value":null},{"argument":"deep","value":"true"}]},"findComponentByGetter":{"defined_on_line":465,"documentation":"","arguments":[{"argument":"getter","value":null},{"argument":"deep","value":"false"}]},"findComponentByRole":{"defined_on_line":469,"documentation":"","arguments":[{"argument":"role","value":null},{"argument":"deep","value":"false"}]},"findComponentByType":{"defined_on_line":473,"documentation":"","arguments":[{"argument":"desired","value":null},{"argument":"deep","value":"false"}]},"findComponentByName":{"defined_on_line":477,"documentation":"","arguments":[{"argument":"name","value":null},{"argument":"deep","value":"false"}]},"findComponentById":{"defined_on_line":481,"documentation":"","arguments":[{"argument":"id","value":null},{"argument":"deep","value":"false"}]},"findComponent":{"defined_on_line":484,"documentation":"","arguments":[{"argument":"needle","value":null},{"argument":"haystack","value":"\"name\""},{"argument":"deep","value":"false"}]},"each":{"defined_on_line":498,"documentation":"","arguments":[{"argument":"fn","value":null}]},"eachComponent":{"defined_on_line":504,"documentation":"<p>run a function for each component in this container\nand any nested containers in those components, recursively\npass false as the second argument to skip the deep recursion</p>\n","arguments":[{"argument":"fn","value":null},{"argument":"deep","value":"true"}]},"indexOf":{"defined_on_line":509,"documentation":"","arguments":[{"argument":"name","value":null}]},"activeComponent":{"defined_on_line":513,"documentation":"","arguments":[]},"componentElements":{"defined_on_line":517,"documentation":"","arguments":[]},"getComponent":{"defined_on_line":520,"documentation":"","arguments":[{"argument":"needle","value":null}]},"isRootComponent":{"defined_on_line":523,"documentation":"","arguments":[]},"getRootComponent":{"defined_on_line":526,"documentation":"","arguments":[]},"selectByAttribute":{"defined_on_line":530,"documentation":"","arguments":[{"argument":"attribute","value":null},{"argument":"value","value":"undefined"},{"argument":"deep","value":"false"}]},"at":{"defined_on_line":624,"documentation":"","arguments":[{"argument":"index","value":null}]}},"defines_properties":{"emptyContainerElements":{"defined_on_line":159,"documentation":"","default":""},"className":{"defined_on_line":160,"documentation":"","default":""},"componentTag":{"defined_on_line":161,"documentation":"","default":""},"componentClass":{"defined_on_line":162,"documentation":"","default":""},"isContainer":{"defined_on_line":163,"documentation":"","default":""},"rendered":{"defined_on_line":164,"documentation":"","default":""},"@trigger \"before":{"defined_on_line":558,"documentation":"","default":""},"@trigger \"after":{"defined_on_line":560,"documentation":"","default":""},"style_declarations.push \"height":{"defined_on_line":565,"documentation":"","default":""},"style_declarations.push \"width":{"defined_on_line":566,"documentation":"","default":""},"style_declarations.push \"float":{"defined_on_line":567,"documentation":"","default":""}},"source_file_contents":"# The Luca.Container is the heart and soul of the Luca framework \n# and the component driven design philosophy.  The central idea\n# is that every component should be designed as an isolated unit\n# which completely encapsulates its features.  It should not know about\n# other components outside of it.\n# \n# It is the responsibility of a `Luca.Container` to define its \n# child `@components`, render them, and broker communication between them\n# in response to events which occur in the user interface.  \n#\n# A common use case for this would be a page which has a filter form, and\n# a grid of search results.  The fields in the filter form are used to \n# filter the table.  Neither the form or the table know about each other, \n# since both can be used in other contexts.  A `Luca.Container` would be used\n# to relay events from the form to the table, and in doing so create a higher\n# level component which can be extended and re-used. \n#\n# #### Using a container to combine a Filter View and Results Table \n#\n#         form = Luca.register    \"App.views.FilterForm\"\n#         form.extends            \"Luca.components.FormView\"\n#\n#         form.contains\n#           type:   \"text\"\n#           label:  \"Filter by\"\n#           name:   \"filter_text\"\n#         ,\n#           type:   \"button\"\n#           className: \"filter\"\n#           value:  \"Filter\"          \n#\n#\n#         form.defines\n#           toolbar: false \n# \n# Elsewhere, we have a table that lists records in a collection:\n#         \n#         table = Luca.register     \"App.views.ResultsTable\"\n#         table.extends             \"Luca.components.TableView\"\n#         table.defines \n#           striped: true\n#           collection: \"components\"\n#           columns:[\n#             header: \"Component Class\"\n#             reader: \"class_name\"\n#           ,\n#             header: \"Component Type Alias\"\n#             reader: \"type_alias\"\n#           ]\n#\n# We can join these two components together by declaring their relationship\n# in a `Luca.Container`.  Remember the components we defined above are just\n# prototypes.  We can override specific instance configuration and properties \n# in our container.\n#\n# #### Container Example\n#\n#         container = Luca.register     \"App.views.ComponentFinder\"\n#         container.extends             \"Luca.Container\"\n#       \n#       # This is the same as defining a components property on the component.\n#       # The type alias is derived from the name of the component.  It is \n#       # a short hand way of referencing a component you might reuse a lot.\n#       container.contains\n#         type: \"filter_form\"\n#         role: \"filter\"\n#       ,\n#         type: \"results_table\"\n#         # change the prototype's default \n#         striped: false\n#         role: \"results\"\n#         filterable: true\n#\n#       # A Container will generally define some component event bindings\n#       # and handler methods to handle the communication between its sub\n#       # components.  By default a container is able to access events\n#       # from all of its descendants in the hierarchy. \n#       container.defines\n#         # These will be applied to each of our components.\n#         defaults:\n#           attributes:\n#             \"data-attribute\": \"whatever\"\n#\n#         componentEvents:\n#           # Any time any of our child components emit\n#           # the on:change event, pass it to the filterTable method\n#           \"* on:change\" : \"filterTable\"\n#\n#         # Communicates between the filter and the table's\n#         # underlying collection.  NOtice the use of the @role\n#         # property.  It automatically creates getter helpers for us.\n#         filterTable: ()->\n#           filter = @getFilter()\n#           results = @getResults()\n#           # filter.getValues() is a hash of each field and its value\n#           results.applyFilter( filter.getValues() )\n#         \n# ### DOM Layout Configuration\n#\n# Another responsibility of the container is to structurally layout its\n# child components in the DOM.  There are a number of different \n# options available depending on how you need to do this.  By default,\n# a `Luca.Container` will simply append the @$el of all of its views\n# to its own.\n#\n# The `Luca.components.Controller` is a container which hides every page\n# but the active page.  Similarly, there is the `Luca.containers.TabView`\n# which does the same thing, but renders a tab selector menu for you.  You\n# can create any type of interface you want using containers. \n#\n# To make this easy for you, you can do a few different things:\n#\n# #### Use the Twitter Bootstrap Fluid Grid\n#\n#         container = Luca.register \"App.views.ColumnLayout\" \n#         container.extends         \"App.views.ComponentFinder\"\n#\n#         container.contains\n#           span: 4\n#           type: \"filter_form\"\n#           role: \"filter\"\n#         ,\n#           span: 8\n#           type: \"results_table\"\n#           role: \"results\"\n#\n#         container.defines\n#           rowFluid: true\n#\n# #### Using a layout template with CSS Selectors\n#         ... \n#         container.contains\n#           role: \"filter\"\n#           container: \"#filter-wrapper-dom-selector\"\n#         ,\n#           role: \"results\"\n#           container: \"#results-wrapper-dom-selector\"\n#         ...\n#         container.defines\n#           # assumes the template will provide the CSS selectors used above \n#           bodyTemplate: \"layouts/custom_template\"\ncontainer = Luca.register         \"Luca.Container\"\n\ncontainer.extends                 \"Luca.Panel\"\n\ncontainer.triggers                \"before:components\",\n                                  \"before:render:components\",\n                                  \"before:layout\",\n                                  \"after:components\",\n                                  \"after:layout\",\n                                  \"first:activation\"\n\ncontainer.replaces                \"Luca.Container\"\n\ncontainer.publicConfiguration\n  components:[]\n\ncontainer.privateConfiguration\n  emptyContainerElements: false\n  className: 'luca-ui-container'\n  componentTag: 'div'\n  componentClass: 'luca-ui-panel'\n  isContainer: true\n  rendered: false\n\n  # @componentEvents provides declarative syntax for responding to events on\n  # the components in this container.  the format of the syntax is very similar\n  # to the other event binding helpers:\n  #\n  #   component_accessor component:trigger\n  #\n  # where component_accessor is either the name of the role, or a method on the container\n  # which will find the component in question.\n  #\n  # myContainer = new Luca.Container\n  #   componentEvents:\n  #     \"name component:trigger\"    : \"handler\"\n  #     \"role component:trigger\"    : \"handler\"\n  #     \"getter component:trigger\"  : \"handler\"\n  #\n  componentEvents: {}\n\n  initialize: (@options={})->\n    _.extend @, @options\n\n    # aliases for the components property\n    @components ||= @fields ||= @pages ||= @cards ||= @views\n    \n    # accept components as an array of strings representing\n    # the luca component type\n    for component in @components when _.isString(component)\n      component = (type: component, role: component, name: component)\n\n    _.bindAll(@, \"beforeRender\")\n\n    @setupHooks( Luca.Container::hooks )\n\n    validateContainerConfiguration(@)\n\n    Luca.View::initialize.apply @, arguments\n\n  remove: ()->\n    Luca.View::remove.apply(@, arguments)\n    @eachComponent (component)->\n      component.remove?()\n      \n  beforeRender: ()->\n    doLayout.call(@)\n    doComponents.call(@)\n    Luca.Panel::beforeRender?.apply(@, arguments)\n\n  # Components which inherit from Luca.Container can implement\n  # their own versions of this method, if they need to apply any sort\n  # of additional styling / configuration for the DOM elements that\n  # are created to wrap each container.\n  customizeContainerEl: (containerEl, panel, panelIndex)->\n    containerEl\n\n  prepareLayout: ()->\n    container = @\n    @componentContainers = _( @components ).map (component, index)->\n      applyDOMConfig.call(container, component, index)\n\n    componentsWithClassBasedAssignment = @_().select (component)->\n      _.isString(component.container) and component.container?.match(/^\\./) and container.$( component.container ).length > 0\n\n    # TEMP / HACK / Workaround\n    #\n    # Containers with components assigned to .class-based-containers\n    # seem to get double rendered in the renderComponents() method.\n    #\n    # So here I am uniquely identifying the containers in a way that is not possible\n    # in the templates ( since we want to be able to inherit templates and component assignments )\n    if componentsWithClassBasedAssignment.length > 0\n      for specialComponent in componentsWithClassBasedAssignment\n        containerAssignment = _.uniqueId('container')\n        targetEl = container.$( specialComponent.container )\n        if targetEl.length > 0\n          $(targetEl).attr('data-container-assignment', containerAssignment)\n          specialComponent.container += \"[data-container-assignment='#{ containerAssignment }']\"\n\n  prepareComponents: ()->\n    container = @\n\n    _( @components ).each (component, index)=>\n      ce = componentContainerElement = @componentContainers?[index]\n\n      # support a variety of the bad naming conventions\n      ce.class = ce.class || ce.className || ce.classes\n\n      if @generateComponentElements\n        panel = @make(@componentTag, componentContainerElement, '')\n        @$append( panel )\n\n      # if the container defines a @defaults property\n      # then we should make sure our child components inherit\n      # these values unless specifically defined\n      if container.defaults?\n        component = _.defaults(component, (container.defaults || {}))\n\n      # if the container defines an @extensions property as an array of\n      # configuration objects, then we will extend the component config with\n      # the object in the matching position of the @extensions array.\n      if _.isArray(container.extensions) and _.isObject(container.extensions?[ index ])\n        componentExtension = container.extensions[index]\n        component = _.extend(component, componentExtension)\n\n      # if the container defines an @extensions property as an object of nested hashes,\n      # then extensions is a key/value pair whose key represents the role of the component\n      # that we wish to extend / customize \n      if component.role? and _.isObject(container.extensions) and _.isObject(container.extensions[component.role])\n        componentExtension = container.extensions[component.role]\n        component = _.extend(component, componentExtension)\n        \n      unless component.container?\n        component.container = \"##{ componentContainerElement.id }\" if @generateComponentElements\n        component.container ||= @$bodyEl()\n\n  # create components is responsible for turning the JSON syntax of the\n  # container's definition into live objects against a given Luca Component\n  # type.\n  #\n  # In addition to this, a container builds an index of the components\n  # which belong to it, so that they can easily be looked up by name\n  createComponents: ()->\n    return if @componentsCreated is true\n\n    map = @componentIndex =\n      name_index: {}\n      cid_index: {}\n      role_index: {}\n\n    container   = @\n\n    @components = _( @components ).map (object, index)=>\n\n      # you can include normal backbone views as components\n      # you will want to make sure your render method handles\n      # adding the views @$el to the appropriate @container.\n\n      # you can also just pass a string representing the component_type\n      component = if Luca.isComponent( object )\n        object\n      else\n        # if a component is tagged with a @component property\n        # we assume this is the kind of singleton component\n        # and set the type, role and name to the same value (if they're blank)\n        if object.component? and not (object.type || object.ctype)\n          object.type = object.component\n          object.name ||= object.component\n          object.role ||= object.component\n\n        object.type ||= object.ctype\n\n        # guess the type based on the properties\n        if !object.type?\n          # TODO\n          # Add support for all of the various components property aliases\n          if object.components?\n            object.type = object.ctype = 'container'\n          else\n            object.type = object.ctype = Luca.defaultComponentType\n\n        object._parentCid ||= container.cid\n        created = Luca.util.lazyComponent( object )\n\n      # if we're using base backbone views, then they don't extend themselves\n      # with their passed options, so this is a workaround to get them to\n      # pick up the container config property\n      if !component.container and component.options?.container\n        component.container = component.options.container\n\n      component.getParent ||= ()-> Luca( component._parentCid )\n\n      if not component.container?\n        console.log component,index,@\n        console.error \"could not assign container property to component on container #{ @name || @cid }\"\n\n      indexComponent( component ).at(index).in( @componentIndex )\n\n      component\n\n    @componentsCreated = true\n\n    map\n\n  # Trigger the Rendering Pipeline process on all of the nested\n  # components\n  renderComponents: (@debugMode=\"\")->\n    @debug \"container render components\"\n\n    container = @\n\n    _(@components).each (component)->\n      try\n        component.trigger \"before:attach\"\n\n        containerElement = container.$(component.container)\n\n        if containerElement.length is 0\n          if _.isString( component.container )\n            # the container trying to assign this component to is not in the dom\n            1\n\n          # try in the window context.  this is almost always certainly a bug\n          # so look into wtf is going on and which components are problematic\n          containerElement = @$( component.container ).eq(0) if containerElement.length is 0\n\n        if @emptyContainerElements is true\n          containerElement.empty()\n\n        containerElement.append( component.el )\n\n        component.trigger \"after:attach\"\n        component.render()\n        component.rendered = true\n      catch e\n        console.log \"Error Rendering Component #{ component.name || component.cid }\", component\n\n        if _.isObject(e)\n          console.log e.message\n          console.log e.stack\n\n        throw e unless Luca.silenceRenderErrors? is true\n\n  #### Container Activation\n  #\n  # When a container is first activated is a good time to perform\n  # operations which are not needed unless that component becomes\n  # visible.  This first activation event should be relayed to all\n  # of the nested components.  Components which hide / display\n  # other components, such as a CardView or TabContainer\n  # will trigger first:activation on the components as they become\n  # displayed.\n  firstActivation: ()->\n    activator = @\n    @each (component, index)->\n      # apply the first:activation trigger on the component, in the context of the component\n      # passing as arguments the component itself, and the component doing the activation\n      unless component?.previously_activated is true\n        component?.trigger?.call component, \"first:activation\", component, activator\n        component.previously_activated = true\n\n  #### Underscore Methods For Working with Components\n  _: ()-> _( @components )\n\n  pluck: (attribute)->\n    @_().pluck(attribute)\n\n  invoke: (method)->\n    @_().invoke(method)\n\n  select: (fn)->\n    @_().select(fn)\n\n  detect: (fn)->\n    @_().detect(attribute)\n\n  reject: (fn)->\n    @_().reject(fn)\n\n  map: (fn)->\n    @_().map(fn)\n\n  registerComponentEvents: (eventList, direction=\"on\")->\n    container = @\n\n    for listener, handler of (eventList || @componentEvents||{})\n      [componentNameOrRole,eventId] = listener.split(' ')\n\n      unless _.isFunction( @[handler] )\n        console.log \"Error registering component event\", listener, componentNameOrRole, eventId\n        throw \"Invalid component event definition #{ listener }. Specified handler is not a method on the container\"\n\n      if componentNameOrRole is \"*\"\n        @eachComponent (component)=> component.on(eventId, @[handler], container)\n      else\n        component = @findComponentForEventBinding( componentNameOrRole )\n\n        unless component? and Luca.isComponent(component)\n          console.log \"Error registering component event\", listener, componentNameOrRole, eventId\n          throw \"Invalid component event definition: #{ componentNameOrRole }\"\n\n        component[direction](eventId, @[handler], container)\n\n\n  subContainers: ()->\n    @select (component)->\n      component.isContainer is true\n\n  roles: ()->\n    _( @allChildren() ).pluck('role')\n\n  allChildren: ()->\n    children = @components\n\n    grandchildren = _( @subContainers() ).map (component)->\n      component?.allChildren?()\n\n    _([children,grandchildren]).chain().compact().flatten().value()\n\n  findComponentForEventBinding: (nameRoleOrGetter, deep=true)->\n    @findComponentByName(nameRoleOrGetter, deep) || @findComponentByGetter( nameRoleOrGetter, deep ) || @findComponentByRole( nameRoleOrGetter, deep )\n\n  findComponentByGetter: (getter, deep=false)->\n    _( @allChildren() ).detect (component)->\n      component?.getter is getter\n\n  findComponentByRole: (role,deep=false)->\n    _( @allChildren() ).detect (component)->\n      component?.role is role or component?.type is role or component?.ctype is role\n\n  findComponentByType: (desired,deep=false)->\n    _( @allChildren() ).detect (component)->\n      desired is (component.type || component.ctype)\n\n  findComponentByName: (name, deep=false)->\n    _( @allChildren() ).detect (component)->\n      component.name is name\n\n  findComponentById: (id, deep=false)->\n    @findComponent(id, \"cid_index\", deep)\n\n  findComponent: (needle, haystack=\"name\", deep=false)->\n    @createComponents() unless @componentsCreated is true\n\n    position = @componentIndex?[ haystack ][ needle ]\n    component = @components[ position ]\n\n    return component if component\n\n    if deep is true\n      sub_container = _( @components ).detect (component)->\n        component?.findComponent?(needle, haystack, true)\n\n      sub_container?.findComponent?(needle, haystack, true)\n\n  each: (fn)->\n    @eachComponent(fn, false)\n\n  # run a function for each component in this container\n  # and any nested containers in those components, recursively\n  # pass false as the second argument to skip the deep recursion\n  eachComponent: (fn, deep=true)->\n    _( @components ).each (component, index)=>\n      fn.call component, component, index\n      component?.eachComponent?.apply component, [fn,deep] if deep\n\n  indexOf: (name)->\n    names = _( @components ).pluck('name')\n    _( names ).indexOf(name)\n\n  activeComponent: ()->\n    return @ unless @activeItem\n    return @components[ @activeItem ]\n\n  componentElements: ()->\n    @$(\"[data-luca-parent='#{ @name || @cid }']\")\n\n  getComponent: (needle)->\n    @components[ needle ]\n\n  isRootComponent:()->\n    @rootComponent is true || !@getParent?\n\n  getRootComponent: ()->\n    if @isRootComponent() then @ else @getParent().getRootComponent()\n\n\n  selectByAttribute: (attribute, value=undefined, deep=false)->\n    components = _( @components ).map (component)->\n      matches = []\n      test = component[ attribute ]\n\n      matches.push( component ) if test is value or (not value? and test?)\n\n      # recursively traverse our components\n      matches.push component.selectByAttribute?(attribute, value, true) if deep is true\n\n      _.compact matches\n\n    _.flatten( components )\n\n\ncontainer.register()\n\n# This is the method by which a container injects the rendered child views\n# into the DOM.  It will get passed the container object, and the component\n# that is being rendered.\nLuca.Container.componentRenderer = (container, component)->\n  attachMethod = $( component.container )[ component.attachWith || \"append\" ]\n  attachMethod( component.render().el )\n\n\n#### Private Helpers\n\ndoLayout = ()->\n  @trigger \"before:layout\", @\n  @prepareLayout()\n  @trigger \"after:layout\", @\n\napplyDOMConfig = (panel, panelIndex)->\n  style_declarations = []\n\n  style_declarations.push \"height: #{ (if _.isNumber(panel.height) then panel.height + 'px' else panel.height ) }\" if panel.height?\n  style_declarations.push \"width: #{ (if _.isNumber(panel.width) then panel.width + 'px' else panel.width ) }\" if panel.width?\n  style_declarations.push \"float: #{ panel.float }\" if panel.float\n\n  config =\n    class: panel?.classes || @componentClass\n    id: \"#{ @cid }-#{ panelIndex }\"\n    style: style_declarations.join(';')\n    \"data-luca-parent\" : @name || @cid\n\n  if @customizeContainerEl?\n   config = @customizeContainerEl( config, panel, panelIndex )\n\n  config\n\n\n\ncreateGetterMethods = ()->\n  container = @\n\n  childrenWithGetter = _( @allChildren() ).select (component)->\n    component?.getter?\n\n  _( childrenWithGetter ).each (component)->\n    container[ component.getter ] ||= ()-> component\n\ncreateMethodsToGetComponentsByRole = ()->\n  container = @\n\n  childrenWithRole = _( @allChildren() ).select (component)->\n    component?.role?\n\n  _( childrenWithRole ).each (component)->\n    getter = _.str.camelize( \"get_\" + component.role )\n    getterFn = ()-> component\n    container[ getter ] ||= _.bind(getterFn, container) \n\ndoComponents = ()->\n  @trigger \"before:components\", @, @components\n  @prepareComponents()\n  @trigger \"before:create:components\", @, @components\n  @createComponents()\n  @trigger \"before:render:components\", @, @components\n  @renderComponents()\n  @trigger \"after:components\", @, @components\n\n  unless @skipGetterMethods is true\n    createGetterMethods.call(@)\n    createMethodsToGetComponentsByRole.call(@)\n\n  @registerComponentEvents()\n\nvalidateContainerConfiguration = ()->\n  true\n\n# Private Helpers\n#\n# indexComponent( component ).at( index ).in( componentsInternalIndexMap )\nindexComponent = (component)->\n  at: (index)->\n    in: (map)->\n      if component.cid?\n        map.cid_index[ component.cid ] = index\n      if component.role?\n        map.role_index[ component.role ] = index\n      if component.name?\n        map.name_index[ component.name ] = index\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/panel_toolbar.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/panel_toolbar.coffee","type":"component_definition","class_name":"Luca.PanelToolbar","header_documentation":"<p>The Panel Toolbar is a collection of buttons and / or dropdowns</p>\n","type_alias":"panel_toolbar","css_class_identifier":"luca-panel-toolbar","defines_methods":{"initialize":{"defined_on_line":29,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"clickHandler":{"defined_on_line":43,"documentation":"<p>The Toolbar behaves by triggering events on the components which they\nbelong to. Combined with Luca.View::setupHooks it is a clean way\nto organize actions</p>\n","arguments":[{"argument":"e","value":null}]},"beforeRender":{"defined_on_line":61,"documentation":"","arguments":[]},"render":{"defined_on_line":72,"documentation":"","arguments":[]}},"defines_properties":{"orientation":{"defined_on_line":22,"documentation":"","default":""},"autoBindEventHandlers":{"defined_on_line":24,"documentation":"","default":""}},"source_file_contents":"panelToolbar = Luca.register        \"Luca.PanelToolbar\"\n# The Panel Toolbar is a collection of buttons and / or dropdowns\n# which are automatically created by BasicPanel classes, or can be\n# added to any other view component.\npanelToolbar.extends                \"Luca.View\"\n\n\npanelToolbar.defines\n  # @buttons is an array of button config objects\n  # button config accepts the following paramters:\n  #\n  # label       what should the button say\n  # eventId     what event should the button trigger\n  # dropdown    an array of arrays: [eventId, label]\n  # group       an array of button configs\n  # wrapper     a css class, in addition to btn-group\n  # icon        which icon do you want to use on this button?\n  # white       true or false: is it a white colored text?\n  # color       options are primary, info, success, warning, danger, inverse\n  buttons:[]\n\n  orientation: 'top'\n\n  autoBindEventHandlers: true\n\n  events:\n    \"click a.btn, click .dropdown-menu li\" : \"clickHandler\"\n\n  initialize: (@options={})->\n    @_super(\"initialize\", @, arguments)\n\n    # if the toolbar consists of a single button group\n    # don't make the developer specify buttons = {buttons:[group:true, buttons:[...]]}\n    if @group is true and @buttons?.length >= 0\n      @buttons = [\n        group: true\n        buttons: @buttons\n      ]\n\n  # The Toolbar behaves by triggering events on the components which they\n  # belong to. Combined with Luca.View::setupHooks it is a clean way\n  # to organize actions\n  clickHandler: (e)->\n    me = my = $( e.target )\n    me = my = $( e.target ).parent() if me.is('i')\n\n    if @selectable is true\n      my.siblings().removeClass(\"is-selected\")\n      me.addClass('is-selected')\n\n    return unless eventId = my.data('eventid')\n\n    hook = Luca.util.hook( eventId )\n\n    source = @parent || @\n    if _.isFunction( source[hook] )\n      source[ hook ].call(@, me, e)\n    else\n      source.trigger(eventId, me, e)\n\n  beforeRender:()->\n    @_super(\"beforeRender\", @, arguments)\n\n    if @well is true\n      @$el.addClass 'well'\n\n    @$el.addClass 'btn-selectable' if @selectable is true\n    @$el.addClass \"toolbar-#{ @orientation }\"\n    @$el.addClass \"pull-right\" if @align is \"right\"\n    @$el.addClass \"pull-left\" if @align is \"left\"\n\n  render: ()->\n    @$el.empty()\n    @$el.append( element ) for element in prepareButtons(@buttons)\n    @\n\n\nmake = Luca.View::make\n\nbuildButton = (config, wrap=true)->\n  if config.ctype? or config.type?\n    config.className ||= \"\"\n    config.className += 'toolbar-component'\n\n    object = Luca(config).render()\n\n    if Luca.isBackboneView(object)\n      return object.$el\n\n  if config.spacer\n    return make \"div\", class: \"spacer #{ config.spacer }\"\n\n  if config.text\n    return make \"div\", {class: \"toolbar-text\"}, config.text\n\n  wrapper = 'btn-group'\n  wrapper += \"#{ config.wrapper }\" if config.wrapper?\n  wrapper += \"pull-#{ config.align } align-#{ config.align }\" if config.align?\n  wrapper += 'btn-selectable' if config.selectable is true\n\n  # if we're passed a group, then we need to just\n  # wrap the contents of the buttons property in that group\n  # skipping the btn-group wrapping that takes place for\n  # individual buttons\n  if config.group? and config.buttons?\n    buttons = prepareButtons( config.buttons, false )\n    return make \"div\", class: wrapper, buttons\n\n  # if it is a normal button, and not a button group\n  else\n    label = config.label ||= \"\"\n\n    config.eventId ||= _.string.dasherize( config.label.toLowerCase() )\n\n    if config.icon\n      label = \" \" if _.string.isBlank( label )\n      white = \"icon-white\" if config.white\n      label = \"<i class='#{ white || \"\" } icon-#{ config.icon }' /> #{ label }\"\n\n    buttonAttributes =\n      class: _.compact([\"btn\",config.classes,config.className]).join(\" \")\n      \"data-eventId\" : config.eventId\n      title: config.title || config.description\n\n    buttonAttributes[\"class\"] += \" btn-#{ config.color }\" if config.color?\n    buttonAttributes[\"class\"] += \" is-selected\" if config.selected?\n\n    if config.dropdown\n      label = \"#{ label } <span class='caret'></span>\"\n      buttonAttributes[\"class\"] += \" dropdown-toggle\"\n      buttonAttributes[\"data-toggle\"] = \"dropdown\"\n\n      dropdownItems = for dropdownItem in config.dropdown\n        if _.isObject(dropdownItem)\n          dropdownItem = _.values(dropdownItem).reverse()\n\n        link = make \"a\", {}, dropdownItem[1]\n        make \"li\", {\"data-eventId\": dropdownItem[0]}, link\n\n      dropdownEl = make \"ul\", {class:\"dropdown-menu\"}, dropdownItems\n\n    buttonEl = make \"a\", buttonAttributes, label\n\n    # needs to be wrapped for proper rendering, but not\n    # if it already is part of a group\n    autoWrapClass = \"btn-group\"\n    autoWrapClass += \" align-#{ config.align }\" if config.align?\n\n    if wrap is true\n      return make \"div\", {class: autoWrapClass}, [buttonEl,dropdownEl]\n    else\n      # for buttons which are already part f a group\n      buttonEl\n\nprepareButtons = (buttons=[], wrap=true)->\n  buildButton(button, wrap) for  button in buttons\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/tab_view.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/tab_view.coffee","type":"component_definition","class_name":"Luca.containers.TabView","header_documentation":"","type_alias":"tab_view","css_class_identifier":"luca-containers-tab-view","defines_methods":{"initialize":{"defined_on_line":19,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"activeTabSelector":{"defined_on_line":30,"documentation":"","arguments":[]},"beforeLayout":{"defined_on_line":33,"documentation":"","arguments":[]},"afterRender":{"defined_on_line":41,"documentation":"","arguments":[]},"createTabSelectors":{"defined_on_line":50,"documentation":"","arguments":[]},"highlightSelectedTab":{"defined_on_line":63,"documentation":"","arguments":[]},"tabSelectClickHandler":{"defined_on_line":67,"documentation":"","arguments":[{"argument":"e","value":null}]},"select":{"defined_on_line":75,"documentation":"","arguments":[{"argument":"tabName","value":"0"}]},"componentElements":{"defined_on_line":80,"documentation":"","arguments":[]},"tabContentWrapper":{"defined_on_line":83,"documentation":"","arguments":[]},"tabContainerWrapper":{"defined_on_line":86,"documentation":"","arguments":[]},"tabContainer":{"defined_on_line":89,"documentation":"","arguments":[]},"tabSelectors":{"defined_on_line":92,"documentation":"","arguments":[]},"bodyTemplateVars":{"defined_on_line":95,"documentation":"","arguments":[]}},"defines_properties":{"tab_position":{"defined_on_line":8,"documentation":"","default":""},"tabVerticalOffset":{"defined_on_line":9,"documentation":"","default":""},"additionalClassNames":{"defined_on_line":12,"documentation":"","default":""},"navClass":{"defined_on_line":13,"documentation":"","default":""},"bodyTemplate":{"defined_on_line":14,"documentation":"","default":""},"bodyClassName":{"defined_on_line":15,"documentation":"","default":""},"skipGetterMethods":{"defined_on_line":16,"documentation":"","default":""}},"source_file_contents":"tabView = Luca.register       \"Luca.containers.TabView\"\ntabView.extends               \"Luca.containers.CardView\"\n\ntabView.triggers              \"before:select\",\n                              \"after:select\"\n\ntabView.publicConfiguration\n  tab_position: 'top'\n  tabVerticalOffset: '50px'\n\ntabView.privateConfiguration\n  additionalClassNames: 'tabbable'\n  navClass: \"nav-tabs\"\n  bodyTemplate: \"containers/tab_view\"\n  bodyClassName: \"tab-content\"\n  skipGetterMethods: true\n\ntabView.defines\n  initialize: (@options={})->\n    @navClass = \"nav-list\"if @navStyle is \"list\"\n\n    Luca.containers.CardView::initialize.apply @, arguments\n\n    _.bindAll @, \"select\", \"highlightSelectedTab\"\n\n    @setupHooks( @hooks )\n\n    @bind \"after:card:switch\", @highlightSelectedTab\n\n  activeTabSelector: ()->\n    @tabSelectors().eq( @activeCard || @activeTab || @activeItem )\n\n  beforeLayout: ()->\n    @$el.addClass(\"tabs-#{ @tab_position }\")\n    @activeTabSelector().addClass 'active'\n\n    @createTabSelectors()\n\n    Luca.containers.CardView::beforeLayout?.apply @, arguments\n\n  afterRender: ()->\n    Luca.containers.CardView::afterRender?.apply @, arguments\n    tabContainerId = @tabContainer().attr(\"id\")\n    @registerEvent(\"click ##{ tabContainerId } li a\", \"tabSelectClickHandler\")\n\n    if Luca.config.enableBootstrap and (@tab_position is \"left\" or @tab_position is \"right\")\n      @tabContainerWrapper().addClass(\"span2\")\n      @tabContentWrapper().addClass(\"span9\")\n\n  createTabSelectors: ()->\n    tabView = @\n    @each (component,index)->\n      icon = \"<i class='icon-#{ component.tabIcon }'></i>\" if component.tabIcon\n      link = \"<a href='#'>#{ icon || ''} #{ component.title }</a>\"\n      selector = tabView.make(\"li\",{class:\"tab-selector\",\"data-target\":index}, link)\n      tabView.tabContainer().append(selector)\n\n      if component.navHeading? and not tabView.navHeadings?[ component.navHeading ]\n        $( selector ).before( tabView.make('li',{class:\"nav-header\"}, component.navHeading))\n        tabView.navHeadings ||= {}\n        tabView.navHeadings[ component.navHeading ] = true\n\n  highlightSelectedTab: ()->\n    @tabSelectors().removeClass('active')\n    @activeTabSelector().addClass('active')\n\n  tabSelectClickHandler: (e)->\n    e?.preventDefault()\n    me = my = $( e.target )\n    me = my ||= @tabSelectors()[0]\n    tabName = my.parent().data('target')\n\n    @select(tabName)\n\n  select: (tabName=0)->\n    @trigger \"before:select\", @\n    @activate(tabName)\n    @trigger \"after:select\", @\n\n  componentElements: ()->\n    @$(\">.tab-content >.#{ @componentClass }\")\n\n  tabContentWrapper: ()->\n    $(\"##{ @cid }-tab-view-content\")\n\n  tabContainerWrapper: ()->\n    $(\"##{ @cid }-tabs-selector\")\n\n  tabContainer: ()->\n    @$(\"ul.#{ @navClass }\", @tabContainerWrapper() )\n\n  tabSelectors: ()->\n    @$( 'li.tab-selector', @tabContainer() )\n\n  bodyTemplateVars: ()->\n    cid: @cid  \n    navClass: @navClass"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/viewport.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/viewport.coffee","type":"component_definition","class_name":"Luca.containers.Viewport","header_documentation":"","type_alias":"viewport","css_class_identifier":"luca-containers-viewport","defines_methods":{"initialize":{"defined_on_line":10,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"enableFluid":{"defined_on_line":21,"documentation":"","arguments":[{"argument":")-> @enableWrapper(","value":null}]},"disableFluid":{"defined_on_line":23,"documentation":"","arguments":[{"argument":")-> @disableWrapper(","value":null}]},"enableWrapper":{"defined_on_line":25,"documentation":"","arguments":[]},"disableWrapper":{"defined_on_line":29,"documentation":"","arguments":[]},"enableFullscreen":{"defined_on_line":33,"documentation":"","arguments":[]},"disableFullscreen":{"defined_on_line":37,"documentation":"","arguments":[]},"beforeRender":{"defined_on_line":41,"documentation":"","arguments":[]},"height":{"defined_on_line":50,"documentation":"","arguments":[]},"width":{"defined_on_line":53,"documentation":"","arguments":[]},"afterRender":{"defined_on_line":56,"documentation":"","arguments":[]},"renderTopNavigation":{"defined_on_line":62,"documentation":"","arguments":[]},"renderBottomNavigation":{"defined_on_line":77,"documentation":"","arguments":[]}},"defines_properties":{"fullscreen":{"defined_on_line":5,"documentation":"","default":""},"fluid":{"defined_on_line":6,"documentation":"","default":""},"applyWrapper":{"defined_on_line":8,"documentation":"","default":""}},"source_file_contents":"viewport = Luca.register    \"Luca.containers.Viewport\"\nviewport.extends            \"Luca.Container\"\n\nviewport.defines\n  fullscreen: true\n  fluid: false\n\n  applyWrapper: true\n\n  initialize: (@options={})->\n    _.extend @, @options\n\n    if Luca.config.enableBoostrap is true and @applyWrapper is true\n      @wrapperClass = if @fluid is true then Luca.config.fluidWrapperClass else Luca.config.wrapperClass\n\n    Luca.Container::initialize.apply(@, arguments)\n\n    if @fullscreen is true\n      @enableFullscreen() \n\n  enableFluid: ()-> @enableWrapper()\n\n  disableFluid: ()-> @disableWrapper()\n   \n  enableWrapper: ()->\n    if @wrapperClass?\n      @$el.parent().addClass( @wrapperClass ) \n\n  disableWrapper: ()->\n    if @wrapperClass?\n      @$el.parent().removeClass( @wrapperClass ) \n\n  enableFullscreen: ()->\n    $('html,body').addClass('luca-ui-fullscreen')\n    @$el.addClass('fullscreen-enabled')\n\n  disableFullscreen: ()->\n    $('html,body').removeClass('luca-ui-fullscreen')\n    @$el.removeClass('fullscreen-enabled')\n\n  beforeRender: ()->\n    Luca.containers.CardView::beforeRender?.apply(@, arguments)\n\n    #if Luca.config.enableBoostrap and @topNav and @fullscreen\n    #  $('body').css('padding','40px')\n\n    @renderTopNavigation() if @topNav?\n    @renderBottomNavigation() if @bottomNav?\n\n  height: ()->\n    @$el.height()\n\n  width: ()->\n    @$el.width()\n\n  afterRender: ()->\n    Luca.containers.CardView::after?.apply(@, arguments)\n\n    if Luca.config.enableBoostrap is true and @containerClassName\n      @$el.children().wrap('<div class=\"#{ containerClassName }\" />')\n\n  renderTopNavigation: ()->\n    return unless @topNav?\n\n    if _.isString( @topNav )\n      @topNav = Luca.util.lazyComponent(@topNav)\n\n    if _.isObject( @topNav )\n      @topNav.ctype ||= @topNav.type || \"nav_bar\"\n      unless Luca.isBackboneView(@topNav)\n        @topNav = Luca.util.lazyComponent( @topNav )\n\n    @topNav.app = @\n\n    $('body').prepend( @topNav.render().el )\n\n  renderBottomNavigation: ()->\n    # IMPLEMENT\n\n\nLuca.containers.Viewport.defaultWrapperClass  = Luca.config.wrapperClass || 'container'\nLuca.containers.Viewport.fluidWrapperClass    = Luca.config.fluidWrapperClass || 'container-fluid'\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/application.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/application.coffee","type":"component_definition","class_name":"Luca.Application","header_documentation":"<p>The <code>Luca.Application</code> is the main entry point into your Application.\nIt acts as a global state machine, page controller, and router, in addition\nto providing access to other singletons such as the CollectionManager, and SocketManager.</p>\n\n<p>The structure of a common <code>Luca.Application</code> is that it contains one or many <code>Pages</code> which\nthemselves are made up of the components of your application.  One <code>Page</code> is visible at a time\nand which page is displayed is managed by an instance of the <code>Luca.components.Controller</code> class.</p>\n\n<h3>Example Configuration</h3>\n\n<pre><code>application = Luca.register     &quot;App.Application&quot;\napplication.extends             &quot;Luca.Application&quot;\napplication.defines\n  name: &quot;MyApplication&quot;\n  routes: \n    &quot;&quot; : &quot;home&quot;\n    &quot;standard/backbone/style/:route&quot; : &quot;name_of_page#name_of_method&quot;\n  components:[\n    name: &quot;home&quot;\n  ,\n    type: &quot;your_view&quot;\n    name: &quot;name_of_page&quot;\n    name_of_method: (routeParam)-&gt;\n      @doSomethignToSetupYourPageWithThePassed(routeParam)  \n  ]\n</code></pre>\n\n<p>App.onReady ()-&gt;\n    window.MyApp = new App.Application();\n    window.MyApp.boot() </p>\n\n<h4>@routes and pages</h4>\n\n<p>In the above example, our application contains two pages, one with the name &#39;home&#39;\nand one with the name &#39;name<em>of</em>page&#39;.  It also specifies a <code>@routes</code> property which\nis identical to the configuration you would see in a standard <code>Backbone.Router</code>.\nWhenever the route matches &#39;standard/backbone/style/route&#39; the <code>App.Application</code> instance\nwill send an instruction to the <code>Luca.components.Controller</code> to <code>activate</code> the page whose name\nis passed in the <code>@routes</code> config.</p>\n\n<p>If that page defines a method called <code>@routeHandler</code> it will be called with the parameters\nfrom the route.  In the <code>@routes</code> config you can specify your own route handler method\nby using the rails style <code>page_name#action</code> and it will call the <code>@action</code> method instead\non the view named <code>page_name</code>.\nThe <code>App.Application</code> instance, also accessible by <code>window.MyApp</code>, or through the helper <code>App()</code>\nor <code>Luca.getApplication()</code> maintains the state of which page is active.  You can access this\nin your code by calling <code>App().activePage()</code>.</p>\n\n<h4>Controllers</h4>\n\n<p>The <code>Luca.components.Controller</code> is a special type of component which contains \nother views, or <code>Pages</code> which only one will be visible at any given time.  It expects\nthat each page will have its own unique <code>@name</code> property.  A <code>Luca.components.Controller</code> can\ncontain other controllers, providing you with a way of structuring your application layout\nin an organized, hierarchal fashion. \nBy default, any <code>Luca.Application</code> will have one <code>Luca.components.Controller</code> automatically\ncreated named &#39;main_controller&#39; which is accessible by <code>MyApp.getMainController()</code>.  Any\ncomponents you define on the <code>Luca.Application</code> instance will be wrapped by the main controller\nautomatically unless you specify <code>@useController = false</code> in your Application component definition.</p>\n","type_alias":"application","css_class_identifier":"luca-application","defines_methods":{"initialize":{"defined_on_line":173,"documentation":"<p>Don&#39;t create getters on this component\nfor the nested components</p>\n","arguments":[{"argument":"@options","value":"{}"}]},"activeView":{"defined_on_line":243,"documentation":"<p>@activeView() returns a reference to the instance of the view\nwhich is currently monopolizing the viewport.  In an application\nwhich uses a controller hierarchy, it will be the last controller\nhas activated one of its pages.</p>\n","arguments":[]},"activeSection":{"defined_on_line":250,"documentation":"<p>Returns the name of the active component on the main controller</p>\n","arguments":[]},"activeSubSection":{"defined_on_line":256,"documentation":"<p>Returns the name of the active component on the nested controllers\non the main controller, if there is one.  These get set on the\nstate machine in response to card switch events on the controller component</p>\n","arguments":[]},"activePages":{"defined_on_line":259,"documentation":"","arguments":[]},"boot":{"defined_on_line":270,"documentation":"<p>boot should trigger the ready event, which will call the initial call\nto render() your application, which will have a cascading effect on every\nsubcomponent in the view, recursively rendering everything which is set\nto automatically render (i.e. any non-deferrable components ).</p>\n\n<p>you should use boot to fire up any dependent collections, manager, any\nsort of data processing, whatever your application requires to run outside\nof the views</p>\n","arguments":[]},"collection":{"defined_on_line":277,"documentation":"<p>delegate to the collection manager&#39;s get or create function.\nuse App.collection() to create or access existing collections</p>\n","arguments":[]},"get":{"defined_on_line":280,"documentation":"","arguments":[{"argument":"attribute","value":null}]},"set":{"defined_on_line":283,"documentation":"","arguments":[{"argument":"attribute","value":null},{"argument":"value","value":null},{"argument":"options","value":null}]},"view":{"defined_on_line":286,"documentation":"","arguments":[{"argument":"name","value":null}]},"navigate_to":{"defined_on_line":292,"documentation":"<h3>Navigation Hooks</h3>\n\n<p>delegate to the main controller so that we can switch the active section</p>\n","arguments":[{"argument":"component_name","value":null},{"argument":"callback","value":null}]},"keyHandler":{"defined_on_line":296,"documentation":"","arguments":[{"argument":"e","value":null}]},"setupControllerBindings":{"defined_on_line":321,"documentation":"","arguments":[]},"setupMainController":{"defined_on_line":338,"documentation":"","arguments":[]},"setupCollectionManager":{"defined_on_line":357,"documentation":"","arguments":[]},"setupSocketManager":{"defined_on_line":391,"documentation":"","arguments":[]},"setupRouter":{"defined_on_line":397,"documentation":"","arguments":[]},"setupKeyHandler":{"defined_on_line":427,"documentation":"","arguments":[]},"pageHierarchy":{"defined_on_line":445,"documentation":"<p>Public: For purely informational purposes, describes the structure\nof the Application&#39;s controller views, and any of their nested controllers views.</p>\n","arguments":[]},"registerInstance":{"defined_on_line":464,"documentation":"<p>Private: registers the instance of the Luca.Appliction\nso that it is available via the Luca() helper, or through\na call to Luca.Application.get()</p>\n","arguments":[{"argument":"app","value":null}]},"checkForKeymaster":{"defined_on_line":474,"documentation":"<p>The following special keys can be used for shortcuts:\n<code>backspace</code>, <code>tab</code>, <code>clear</code>, <code>enter</code>, <code>return</code>, <code>esc</code>, <code>escape</code>, <code>space</code>,\n<code>up</code>, <code>down</code>, <code>left</code>, <code>right</code>, <code>home</code>, <code>end</code>, <code>pageup</code>, <code>pagedown</code>, <code>del</code>, <code>delete</code>\nand <code>f1</code> through <code>f19</code>.</p>\n","arguments":[]},"routeTo":{"defined_on_line":489,"documentation":"<p>Private: Recursively navigates down the controller page hierarchy\nto the page you specify by name.  You can specify the\nmethod which is to be called at the end of the chain.</p>\n\n<p>This is used internally by the Application as it sets up\nthe @routes property and uses it to configure the Luca.Router\ninstance for your app.</p>\n","arguments":[{"argument":"pages...","value":null}]},"startHistory":{"defined_on_line":533,"documentation":"<p>Public: you can override Luca.Application.startHistory to\nmodify how Backbone.history.start is called.  This will get called\nby the Application instance in response to the @autoStartHistory property.</p>\n","arguments":[]}},"defines_properties":{"name":{"defined_on_line":70,"documentation":"","default":""},"autoBoot":{"defined_on_line":81,"documentation":"<p>if autoBoot is set to true, the application will\nattempt to boot on document ready.</p>\n","default":""},"autoStartHistory":{"defined_on_line":87,"documentation":"<p>automatically starts the @router if it exists,\nonce the components for the application have\nbeen created.  Pass the event name you want to\nlisten for on this component before you start history</p>\n","default":""},"pushState":{"defined_on_line":90,"documentation":"<p>use Backbone.history push state?</p>\n","default":""},"useCollectionManager":{"defined_on_line":94,"documentation":"<p>we will create a collection manager singleton\nby default unless otherwise specified.</p>\n","default":""},"collectionManagerClass":{"defined_on_line":103,"documentation":"<p>by default we will use the standard collection manager which ships with\nLuca.  If you would like to use your own extension of the collection manager\njust pass a reference to the class you would like to use.</p>\n","default":""},"plugin":{"defined_on_line":108,"documentation":"<p>Luca plugin apps are apps which mount onto existing\nluca apps, and will not have the behavior of a main\napp which acts as a singleton</p>\n","default":""},"useController":{"defined_on_line":114,"documentation":"<p>by default, the application will use a controller\ncomponent, which is a card view container which shows\none view at a time.  this is useful for having an application\nwith several &#39;pages&#39; so to speak</p>\n","default":""},"mainControllerContainer":{"defined_on_line":120,"documentation":"<p>if you have special rendering requirements for\nthe application&#39;s components, you can assign the\nspecific element you want to render the container\nto inside of the #viewport</p>\n","default":""},"useKeyHandler":{"defined_on_line":128,"documentation":"<p>Key Handler</p>\n\n<p>One responsibility of the application, since it is a viewport which monopolizes the entire screen\nis to relay keypress events from the document, to whatever views are interested in responding to them.</p>\n\n<p>This functionality is disabled by default.</p>\n","default":""},"createRoleBasedGetters":{"defined_on_line":163,"documentation":"<p>create getter methods for the various\nroles in the application&#39;s components on the\napplication itself.  false by default.</p>\n","default":""},"useSocketManager":{"defined_on_line":168,"documentation":"<p>create an instance of Luca.SocketManager\nwhich is a Backbone.Events style abstraction that\nsits on top of services like faye, or socket.io</p>\n","default":""}},"source_file_contents":"# The `Luca.Application` is the main entry point into your Application.\n# It acts as a global state machine, page controller, and router, in addition\n# to providing access to other singletons such as the CollectionManager, and SocketManager.\n# \n# The structure of a common `Luca.Application` is that it contains one or many `Pages` which\n# themselves are made up of the components of your application.  One `Page` is visible at a time\n# and which page is displayed is managed by an instance of the `Luca.components.Controller` class.\n#\n# ### Example Configuration  \n#     application = Luca.register     \"App.Application\"\n#     application.extends             \"Luca.Application\"\n#\n#     application.defines\n#       name: \"MyApplication\"\n#       routes: \n#         \"\" : \"home\"\n#         \"standard/backbone/style/:route\" : \"name_of_page#name_of_method\"\n#\n#       components:[\n#         name: \"home\"\n#       ,\n#         type: \"your_view\"\n#         name: \"name_of_page\"\n#         name_of_method: (routeParam)->\n#           @doSomethignToSetupYourPageWithThePassed(routeParam)  \n#       ]\n#\n#   App.onReady ()->\n#     window.MyApp = new App.Application();\n#     window.MyApp.boot() \n#\n# #### @routes and pages\n#\n# In the above example, our application contains two pages, one with the name 'home'\n# and one with the name 'name_of_page'.  It also specifies a `@routes` property which\n# is identical to the configuration you would see in a standard `Backbone.Router`.\n#\n# Whenever the route matches 'standard/backbone/style/route' the `App.Application` instance\n# will send an instruction to the `Luca.components.Controller` to `activate` the page whose name\n# is passed in the `@routes` config.\n# \n# If that page defines a method called `@routeHandler` it will be called with the parameters\n# from the route.  In the `@routes` config you can specify your own route handler method\n# by using the rails style `page_name#action` and it will call the `@action` method instead\n# on the view named `page_name`.\n#\n# The `App.Application` instance, also accessible by `window.MyApp`, or through the helper `App()`\n# or `Luca.getApplication()` maintains the state of which page is active.  You can access this\n# in your code by calling `App().activePage()`.\n#\n# #### Controllers\n# \n# The `Luca.components.Controller` is a special type of component which contains \n# other views, or `Pages` which only one will be visible at any given time.  It expects\n# that each page will have its own unique `@name` property.  A `Luca.components.Controller` can\n# contain other controllers, providing you with a way of structuring your application layout\n# in an organized, hierarchal fashion. \n#\n# By default, any `Luca.Application` will have one `Luca.components.Controller` automatically\n# created named 'main_controller' which is accessible by `MyApp.getMainController()`.  Any\n# components you define on the `Luca.Application` instance will be wrapped by the main controller\n# automatically unless you specify `@useController = false` in your Application component definition.\napplication = Luca.register       \"Luca.Application\"\napplication.extends               \"Luca.containers.Viewport\"\n\napplication.triggers              \"controller:change\",\n                                  \"action:change\"\n\napplication.publicConfiguration\n  name: \"MyApp\"\n\n  # The Application uses a Backbone.Model as a state machine, which\n  # allows you to get / set attributes, persist them somewhere, and\n  # most importantly to bind to change events of certain attributes.\n  #\n  # the @defaultState property will be the default attributes\n  stateful: {}\n\n  # if autoBoot is set to true, the application will\n  # attempt to boot on document ready.\n  autoBoot: false\n\n  # automatically starts the @router if it exists,\n  # once the components for the application have\n  # been created.  Pass the event name you want to\n  # listen for on this component before you start history\n  autoStartHistory: \"before:render\"\n\n  # use Backbone.history push state?\n  pushState: false\n  \n  # we will create a collection manager singleton\n  # by default unless otherwise specified.\n  useCollectionManager: true\n\n  # to pass options to the collection manager, set the @collectionManager\n  # hash which will get passed once the collection manager is created\n  collectionManager: {}\n\n  # by default we will use the standard collection manager which ships with\n  # Luca.  If you would like to use your own extension of the collection manager\n  # just pass a reference to the class you would like to use.\n  collectionManagerClass: \"Luca.CollectionManager\"\n\n  # Luca plugin apps are apps which mount onto existing\n  # luca apps, and will not have the behavior of a main\n  # app which acts as a singleton\n  plugin: false\n\n  # by default, the application will use a controller\n  # component, which is a card view container which shows\n  # one view at a time.  this is useful for having an application\n  # with several 'pages' so to speak\n  useController: true\n\n  # if you have special rendering requirements for\n  # the application's components, you can assign the\n  # specific element you want to render the container\n  # to inside of the #viewport\n  mainControllerContainer: undefined\n\n  # Key Handler\n  #\n  # One responsibility of the application, since it is a viewport which monopolizes the entire screen\n  # is to relay keypress events from the document, to whatever views are interested in responding to them.\n  #\n  # This functionality is disabled by default.\n  useKeyHandler: false\n\n  # You can configure key events by specifying them by their name, as it exists in Luca.keyMap. For example:\n\n  # keyEvents understands the following modifiers:\n  # `\u21e7`, `shift`, `option`, `\u2325`, `alt`, `ctrl`, `control`, `command`, and `\u2318`.\n\n  # The following special keys can be used for shortcuts:\n  # `backspace`, `tab`, `clear`, `enter`, `return`, `esc`, `escape`, `space`,\n  # `up`, `down`, `left`, `right`, `home`, `end`, `pageup`, `pagedown`, `del`, `delete`\n  # and `f1` through `f19`.\n  #\n  # Example:\n  # ```coffeescript\n  #   application.configuration\n  #     keyEvents:\n  #       '\u2318+r, ctrl+r': \"keyHandlerFunction\"\n  #     keyHandlerFunction: -> alert 'something + r was pressed'\n  # ```\n  keyEvents: {}\n\n  # applications have one component, the controller.\n  # any components defined on the application class directly\n  # will get wrapped by the main controller unless you\n  # set useController = false\n  components:[\n    type: 'template'\n    name: 'welcome'\n    template: 'sample/welcome'\n    templateContainer: \"Luca.templates\"\n  ]\n\n  # create getter methods for the various\n  # roles in the application's components on the\n  # application itself.  false by default.\n  createRoleBasedGetters: false\n\n  # create an instance of Luca.SocketManager\n  # which is a Backbone.Events style abstraction that\n  # sits on top of services like faye, or socket.io \n  useSocketManager: false\n  socketManagerOptions: {}\n\n  # Don't create getters on this component\n  # for the nested components\n  initialize: (@options={})->\n    app             = @\n    appName         = @name\n    alreadyRunning  = Luca.getApplication?()\n\n    Luca.Application.registerInstance(@)\n\n    Luca.concerns.StateModel.__initializer.call(@)\n\n    # The Collection Manager is responsible for managing instances \n    # of collections, usually to guarantee only a single collection is\n    # instantiated for a given resource, to maintain 'authoritative' \n    # representations of models.\n    @setupCollectionManager()\n\n    # Socket Manager provides a bridge between remote pub/sub providers and \n    # the backbone.events interface on various components in the system.\n    @setupSocketManager()\n\n    Luca.containers.Viewport::initialize.apply @, arguments\n\n    # The Controller is the piece of the application that handles showing\n    # and hiding 'pages' of the app.  The Application has a navigate_to\n    # method which delegates to the controller, and allows you to navigate\n    # to a given page, or component, by its name.  The controller integrates\n    # with the state machine of the application\n    @setupMainController() if @useController is true \n\n    # we will render when all of the various components\n    # which handle our data dependencies determine that\n    # we are ready\n    @defer(()-> app.render()).until(@, \"ready\")\n\n    # Set up the Backbone Router\n    @setupRouter()\n\n    # the keyHandler allows us to specify\n    # keyEvents on our application with an API very similar\n    # to the DOM events API for Backbone.View\n    #\n    # Example:\n    #\n    # keyEvents:\n    #   meta:\n    #     forwardslash: \"altSlashHandler\"\n    if (@useKeyHandler is true or @useKeyRouter is true) and @keyEvents?\n      @setupKeyHandler() \n\n    # if the application is a plugin designed to modify the behavior\n    # of another app, then don't claim ownership.  otherwise the most common\n    # use-case is that there will be one application instance\n    unless @plugin is true or alreadyRunning\n      Luca.getApplication = (name)=>\n        return app unless name?\n        Luca.Application.instances[ name ]\n\n    if @autoBoot\n      if Luca.util.resolve(@name)\n        throw \"Attempting to override window.#{ @name } when it already exists\"\n\n      $ ->\n        window[ appName ] = app\n        app.boot()\n\n    Luca.trigger \"application:available\", @\n\n  # @activeView() returns a reference to the instance of the view\n  # which is currently monopolizing the viewport.  In an application\n  # which uses a controller hierarchy, it will be the last controller\n  # has activated one of its pages.\n  activeView: ()->\n    if active = @activeSubSection()\n      @view( active )\n    else\n      @view( @activeSection() )\n\n  # Returns the name of the active component on the main controller\n  activeSection: ()->\n    @get(\"active_section\")\n\n  # Returns the name of the active component on the nested controllers\n  # on the main controller, if there is one.  These get set on the\n  # state machine in response to card switch events on the controller component\n  activeSubSection: ()->\n    @get(\"active_sub_section\")\n\n  activePages: ()->\n    @$('.luca-ui-controller').map (index,element)=> $(element).data('active-section')\n\n  # boot should trigger the ready event, which will call the initial call\n  # to render() your application, which will have a cascading effect on every\n  # subcomponent in the view, recursively rendering everything which is set\n  # to automatically render (i.e. any non-deferrable components ).\n  #\n  # you should use boot to fire up any dependent collections, manager, any\n  # sort of data processing, whatever your application requires to run outside\n  # of the views\n  boot: ()->\n    @trigger \"ready\"\n    for service in [@collectionManager, @socket, @router]\n      service?.trigger(\"ready\")\n\n  # delegate to the collection manager's get or create function.\n  # use App.collection() to create or access existing collections\n  collection: ()->\n    @collectionManager.getOrCreate.apply(@collectionManager, arguments)\n\n  get: (attribute)->\n    @state.get(attribute)\n\n  set: (attribute, value, options)->\n    @state.set.apply(@state, arguments)\n\n  view: (name)->\n    Luca.cache(name)\n\n  #### Navigation Hooks\n  #\n  # delegate to the main controller so that we can switch the active section\n  navigate_to: (component_name, callback)->\n    @getMainController().navigate_to(component_name, callback)\n\napplication.privateInterface\n  keyHandler: (e)->\n    return unless e and @keyEvents\n\n    isInputEvent = $(e.target).is('input') || $(e.target).is('textarea')\n\n    return if isInputEvent\n\n    keyname = Luca.keyMap[ e.keyCode ]\n\n    return unless keyname\n\n    meta = e?.metaKey is true\n    control = e?.ctrlKey is true\n\n    source = @keyEvents\n    source = if meta then @keyEvents.meta else source\n    source = if control then @keyEvents.control else source\n    source = if meta and control then @keyEvents.meta_control else source\n\n    if keyEvent = source?[keyname]\n      if @[keyEvent]? and _.isFunction(@[keyEvent])\n        @[keyEvent]?.call(@, e, keyname, keyEvent)\n      else\n        @trigger(keyEvent, e, keyname)\n\n  setupControllerBindings: ()->\n    app = @\n    # any time the main controller card switches we should track\n    # the active card on the global state chart\n    @getMainController()?.bind \"after:card:switch\", (previous,current)=>\n      @state.set(active_section:current.name)\n      app.trigger \"controller:change\", previous.name, current.name\n\n    # any time the card switches on one of the sub controllers\n    # then we should track the active sub section on the global state chart\n    @getMainController()?.each (component)=>\n      type = component.type || component.ctype\n      if type.match(/controller$/)\n        component.bind \"after:card:switch\", (previous,current)=>\n          @state.set(active_sub_section:current.name)\n          app.trigger \"action:change\", previous.name, current.name\n\n  setupMainController: ()->\n    if @useController is true\n      definedComponents = @components || []\n      base =  \n        type: 'controller'\n        name: \"main_controller\"\n        role: \"main_controller\"\n        components: definedComponents\n\n      if @mainControllerContainer?\n        _.extend(base, container: @mainControllerContainer)\n\n      @components = [base]\n    \n    @getMainController = ()=> \n      @findComponentByRole('main_controller')\n\n    @defer( @setupControllerBindings, false ).until(\"after:components\")\n\n  setupCollectionManager: ()->\n    return unless @useCollectionManager is true\n\n    return if @collectionManager? and @collectionManager?.get?\n\n    if _.isString( @collectionManagerClass )\n      @collectionManagerClass = Luca.util.resolve( @collectionManagerClass )\n\n    collectionManagerOptions = @collectionManagerOptions || {}\n\n    # if the collectionManager property is present, and it\n    # isn't a reference to a collection manager instance, then\n    # it is being used as a configuration hash for when we do create\n    # the collection manager. so let's stash it.\n    if _.isObject(@collectionManager) and not _.isFunction( @collectionManager?.get )\n      collectionManagerOptions = @collectionManager\n      @collectionManager = undefined\n\n    # if the collection manager property is a string, then it is a\n    # reference to a name of a collection manager to use.  so let's\n    # stash it\n    if _.isString(@collectionManager)\n      collectionManagerOptions =\n        name: @collectionManager\n\n\n    # let's try and get the collection manager by name if we can\n    @collectionManager = Luca.CollectionManager.get?( collectionManagerOptions.name )\n\n    # if we can't, then we will have to create one ourselves\n    unless _.isFunction(@collectionManager?.get)\n      collectionManagerOptions.autoStart = false\n      @collectionManager = new @collectionManagerClass( collectionManagerOptions )\n\n  setupSocketManager: ()->\n    return if _.isEmpty(@socketManagerOptions)\n    _.extend(@socketManagerOptions, autoStart: false)\n\n    @socket = new Luca.SocketManager(@socketManagerOptions) \n  \n  setupRouter: ()->\n    return if not @router? and not @routes?\n\n    routerClass = Luca.Router\n    routerClass = Luca.util.resolve(@router) if _.isString(@router)\n\n    routerConfig = routerClass.prototype\n    routerConfig.routes ||= {}\n    routerConfig.app = @\n\n    if _.isObject( @routes )\n      for routePattern, endpoint of @routes\n        if endpoint.match(/\\ /)\n          [page, action] = endpoint.split(' ')\n        else if endpoint.match(/\\#/)\n          [page, action] = endpoint.split('#')\n\n        fn = _.uniqueId(page)\n        routerConfig[fn] = Luca.Application.routeTo(page).action(action)\n        routerConfig.routes[ routePattern ] = fn\n\n    @router = new routerClass(routerConfig) \n\n    # if this application has a router associated with it\n    # then we need to start backbone history on a certain event.\n    # you can control which by setting the @startHistoryOn property\n    if @router and @autoStartHistory\n      @autoStartHistory = \"before:render\" if @autoStartHistory is true\n      @defer( Luca.Application.startHistory, false).until(@, @autoStartHistory)\n\n  setupKeyHandler: ()->\n    return unless @keyEvents\n\n    @keyEvents.control_meta ||= {}\n\n    # allow for both meta_control, control_meta for the combo\n    _.extend(@keyEvents.control_meta, @keyEvents.meta_control) if @keyEvents.meta_control\n\n    handler = _.bind(@keyHandler, @)\n\n    for keyEvent in (@keypressEvents || [\"keydown\"])\n      $( document ).on( keyEvent, handler )\n\napplication.classInterface\n  instances:{}\n\n  # Public: For purely informational purposes, describes the structure\n  # of the Application's controller views, and any of their nested controllers views.\n  pageHierarchy: ()->\n    app             = Luca()\n    mainController  = app.getMainController()\n\n    getTree = (node)->  \n      return {} unless node.components? or node.pages?\n\n      # recursively walks the pages on a controller\n      _( node.components || node.pages ).reduce (memo, page)->\n        memo[ page.name ] = page.name\n        memo[ page.name ] = getTree(page) if page.navigate_to?\n        memo\n      , {}\n\n    getTree( mainController )\n\n  # Private: registers the instance of the Luca.Appliction\n  # so that it is available via the Luca() helper, or through\n  # a call to Luca.Application.get()\n  registerInstance: (app)->\n    Luca.Application.instances[ app.name ] = app\n\n  # Keymaster understands the following modifiers:\n  # `\u21e7`, `shift`, `option`, `\u2325`, `alt`, `ctrl`, `control`, `command`, and `\u2318`.\n\n  # The following special keys can be used for shortcuts:\n  # `backspace`, `tab`, `clear`, `enter`, `return`, `esc`, `escape`, `space`,\n  # `up`, `down`, `left`, `right`, `home`, `end`, `pageup`, `pagedown`, `del`, `delete`\n  # and `f1` through `f19`.\n  checkForKeymaster: ()->\n    if window?.key?.noConflict\n      Luca.key = window.key.noConflict()\n\n      Luca.Application::setupKeyHandler = ()->\n        return unless @keyEvents\n        Luca.util.setupKeymaster(@keyEvents, \"all\").on(@)\n\n  # Private: Recursively navigates down the controller page hierarchy\n  # to the page you specify by name.  You can specify the \n  # method which is to be called at the end of the chain.\n  # \n  # This is used internally by the Application as it sets up\n  # the @routes property and uses it to configure the Luca.Router\n  # instance for your app.\n  routeTo: (pages...)->\n    last = _( pages ).last()\n    first = _( pages ).first()\n\n    callback = undefined    \n    specifiedAction = undefined\n\n    routeHelper = (args...)->\n      path = @app || Luca()\n      index = 0\n\n      # we can specify a page by name, and not have to know its full path\n      if pages.length is 1 and target = Luca(first)\n        pages = target.controllerPath()\n\n      # when we do know the full path\n      for page in pages when _.isString(page)\n        nextItem = pages[++index]\n        target = Luca(page)\n\n        if page is last \n          callback = if specifiedAction? and target[ specifiedAction ]?\n            _.bind(target[ specifiedAction ], target)\n          else if target.routeHandler?\n            target.routeHandler  \n\n        callback ||= if _.isFunction(nextItem)\n          _.bind(nextItem, target)\n        else if _.isObject(nextItem) \n          if action = nextItem.action and target[action]?\n            _.bind(target[action], target)\n\n        path = path.navigate_to page, ()->\n          callback?.apply(target, args)\n\n    routeHelper.action = (action)->\n      specifiedAction = action\n      routeHelper\n\n    routeHelper\n\n  # Public: you can override Luca.Application.startHistory to \n  # modify how Backbone.history.start is called.  This will get called\n  # by the Application instance in response to the @autoStartHistory property.\n  startHistory: ()->\n    Backbone.history.start(pushState: @pushState)\n\napplication.afterDefinition ()->\n  Luca.routeHelper = Luca.Application.routeTo\n  Luca.Application.checkForKeymaster()\n\napplication.register()"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/collection_loader_view.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/collection_loader_view.coffee","type":"component_definition","class_name":"Luca.components.CollectionLoaderView","header_documentation":"<p>Collection Loader View is a simple modal view\nYou can provide your own template for the collection loader modal\nif you want to. Default implementation uses twitter bootstrap modal and\nprogress bar (<a href=\"http://twitter.github.com/bootstrap/\">http://twitter.github.com/bootstrap/</a>). You template\nshould contain <code>progress</code>, <code>bar</code> and <code>message</code> classes</p>\n","type_alias":"collection_loader_view","css_class_identifier":"luca-collection-loader-view","defines_methods":{"initialize":{"defined_on_line":14,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"modalContainer":{"defined_on_line":22,"documentation":"","arguments":[]},"setupBindings":{"defined_on_line":25,"documentation":"","arguments":[]}},"defines_properties":{"className":{"defined_on_line":10,"documentation":"","default":""},"template":{"defined_on_line":12,"documentation":"","default":""}},"source_file_contents":"# Collection Loader View is a simple modal view\n# You can provide your own template for the collection loader modal\n# if you want to. Default implementation uses twitter bootstrap modal and\n# progress bar (http://twitter.github.com/bootstrap/). You template\n# should contain `progress`, `bar` and `message` classes\nloaderView = Luca.register        \"Luca.components.CollectionLoaderView\"\nloaderView.extends                \"Luca.View\"\n\nloaderView.defines\n  className: 'luca-ui-collection-loader-view'\n\n  template: \"components/collection_loader_view\"\n\n  initialize: (@options={})->\n    Luca.components.Template::initialize.apply @,arguments\n\n    @container ||= $('body')\n    @manager   ||= Luca.CollectionManager.get()\n\n    @setupBindings()\n\n  modalContainer: ()->\n    $(\"#progress-modal\", @el)\n\n  setupBindings: ()->\n    @manager.bind \"collection_loaded\", (name)=>\n      loaded   = @manager.loadedCollectionsCount()\n      total    = @manager.totalCollectionsCount()\n      progress = parseInt((loaded / total) * 100)\n      collectionName = _.string.titleize( _.string.humanize( name ) )\n\n      @modalContainer().find('.progress .bar').attr(\"style\", \"width: #{progress}%;\")\n      @modalContainer().find('.message').html(\"Loaded #{ collectionName }...\")\n\n    @manager.bind \"all_collections_loaded\", ()=>\n      @modalContainer().find('.message').html(\"All done!\")\n      _.delay ()=>\n        @modalContainer().modal('hide')\n      , 400"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/collection_view.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/collection_view.coffee","type":"component_definition","class_name":"Luca.CollectionView","header_documentation":"<p>The <code>Luca.CollectionView</code> renders models from a <code>Luca.Collection</code> into multiple\nelements, and provides methods for filtering, paginating, sorting the underlying\ncollection and re-rendering the contents of its <code>@el</code> accordingly.</p>\n\n<h4>Basic Example</h4>\n\n<pre><code>collectionView = Luca.register  &quot;App.views.Books&quot;\ncollectionView.extends          &quot;Luca.CollectionView&quot;\ncollectionView.defines\n  itemProperty: &quot;author&quot;\n  collection: new Luca.Collection([\n    author: &quot;George Orwell&quot;\n    title:  &quot;Animal Farm&quot;\n  ,\n    author: &quot;Noam Chomsky&quot;\n    title: &quot;Manufacturing Consent&quot;\n  ])\nview = new App.views.Books()\n</code></pre>\n\n<h4>Extending it to make it Filterable and Paginatable</h4>\n\n<pre><code>filterable = Luca.register    &quot;App.views.FilterableBooks&quot;\nfilterable.extends            &quot;App.views.Books&quot;\nfilterable.defines\n  collection: &quot;books&quot; \n  paginatable: 12\n  filterable:\n    query:\n      author: &quot;George Orwell&quot;\n\n view = new App.views.FilterableBooks()\n</code></pre>\n\n<h4>Filterable Collections</h4>\n\n<p>The <code>Luca.CollectionView</code> will attempt to perform a local query against its\ncollection which behaves like a <code>Backbone.QueryCollection</code>.  It will do this\nby default without making a remote request to the API.  </p>\n\n<p>If you do not want this behavior, you can configure the <code>Luca.CollectionView</code> to \nbehave as if the filtering was happen remotely in your REST API.<br>\n      filterable:\n        options:\n          remote: true</p>\n","type_alias":"collection_view","css_class_identifier":"luca-collection-view","defines_methods":{"initialize":{"defined_on_line":96,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"locateItemElement":{"defined_on_line":135,"documentation":"<p>Given the id of a model, find the underlying DOM element which was rendered by this collection.\nAssumes that the data-model-id attribute is set, which it is by default by @attributesForItem.</p>\n","arguments":[{"argument":"id","value":null}]},"refresh":{"defined_on_line":142,"documentation":"<p>Refresh is responsible for applying any filtering, pagination, or sorting options that may be set\nfrom the various Luca.concerns mixed in by <code>Luca.CollectionView</code> and making a query to the underlying\ncollection.  It will then take the set of models returned by <code>@getModels</code> and pass them through the\nitem rendering pipeline.</p>\n","arguments":[]},"attributesForItem":{"defined_on_line":164,"documentation":"<p>Determines which attributes should be set on the item DOM element.</p>\n","arguments":[{"argument":"item","value":null},{"argument":"model","value":null}]},"contentForItem":{"defined_on_line":169,"documentation":"<p>Determines the content for the item DOM element.  Will use the appropriate options\nspecified by <code>@itemTemplate</code>, <code>@itemRenderer</code>, or <code>@itemProperty</code></p>\n","arguments":[{"argument":"item","value":"{}"}]},"makeItem":{"defined_on_line":182,"documentation":"<p>Uses the various options passed to the <code>CollectionView</code> to assemble a call to <code>Luca.View::make</code>.</p>\n","arguments":[{"argument":"model","value":null},{"argument":"index","value":null}]},"refreshModel":{"defined_on_line":193,"documentation":"<p>Given a model, attempt to re-render the contents of its item in this view&#39;s DOM contents.</p>\n","arguments":[{"argument":"model","value":null}]},"registerEvent":{"defined_on_line":199,"documentation":"","arguments":[{"argument":"domEvent","value":null},{"argument":"selector","value":null},{"argument":"handler","value":null}]}},"defines_properties":{"collection":{"defined_on_line":64,"documentation":"<p>Specify which collection will be used to supply the models to be rendered.\nAccepts either a string alias for the Collection class, or an instance of\nany class which inherits from Backbone.Collection</p>\n","default":""},"tagName":{"defined_on_line":67,"documentation":"<p>By default the CollectionView will be rendered inside of an OL tag.</p>\n","default":""},"bodyClassName":{"defined_on_line":72,"documentation":"<p>The CollectionView behaves as a Luca.Panel which means it has an area for\ntop and bottom toolbars.  The actual content that gets rendered from the\ncollection will be rendered inside an element with the specified class.</p>\n","default":""},"itemTagName":{"defined_on_line":75,"documentation":"<p>Each item from the collection will be rendered inside of an element specified by @itemTagName</p>\n","default":""},"itemClassName":{"defined_on_line":78,"documentation":"<p>Each item element will be assigned a CSS class specified by @itemClassName</p>\n","default":""},"itemTemplate":{"defined_on_line":83,"documentation":"<p>Specify which template should be used to render each item in the collection.\nAccepts a string which will be passed to Luca.template(@itemTemplate).  Your template\ncan expect to be passed an object with the <code>model</code> and <code>index</code> properties on it.</p>\n","default":""},"itemRenderer":{"defined_on_line":87,"documentation":"<p>Accepts a reference to a function, which will be called with an object with the <code>model</code> and <code>index</code>\nproperties on it.  This function should return a String which will be injected into the item DOM element.</p>\n","default":""},"itemProperty":{"defined_on_line":90,"documentation":"<p>Plucks the specified property from the model and inserts it into the item DOM element.</p>\n","default":""},"observeChanges":{"defined_on_line":93,"documentation":"<p>If @observeChanges is set to true, any change in an underlying model will automatically be re-rendered.</p>\n","default":""}},"source_file_contents":"# The `Luca.CollectionView` renders models from a `Luca.Collection` into multiple\n# elements, and provides methods for filtering, paginating, sorting the underlying\n# collection and re-rendering the contents of its `@el` accordingly.\n#\n# #### Basic Example\n#     collectionView = Luca.register  \"App.views.Books\"\n#     collectionView.extends          \"Luca.CollectionView\"\n#\n#     collectionView.defines\n#       itemProperty: \"author\"\n#       collection: new Luca.Collection([\n#         author: \"George Orwell\"\n#         title:  \"Animal Farm\"\n#       ,\n#         author: \"Noam Chomsky\"\n#         title: \"Manufacturing Consent\"\n#       ])\n#\n#     view = new App.views.Books()\n# #### Extending it to make it Filterable and Paginatable\n#     filterable = Luca.register    \"App.views.FilterableBooks\"\n#     filterable.extends            \"App.views.Books\"\n#     filterable.defines\n#       collection: \"books\" \n#       paginatable: 12\n#       filterable:\n#         query:\n#           author: \"George Orwell\"\n#    \n#      view = new App.views.FilterableBooks()\n# #### Filterable Collections\n#\n# The `Luca.CollectionView` will attempt to perform a local query against its\n# collection which behaves like a `Backbone.QueryCollection`.  It will do this\n# by default without making a remote request to the API.  \n# \n# If you do not want this behavior, you can configure the `Luca.CollectionView` to \n# behave as if the filtering was happen remotely in your REST API.  \n#\n#       filterable:\n#         options:\n#           remote: true\ncollectionView = Luca.register      \"Luca.CollectionView\"\n\ncollectionView.extends            \"Luca.Panel\"\n\ncollectionView.replaces           \"Luca.components.CollectionView\"\n\ncollectionView.mixesIn            \"QueryCollectionBindings\", \n                                  \"LoadMaskable\", \n                                  \"Filterable\", \n                                  \"Paginatable\",\n                                  \"Sortable\"\n\ncollectionView.triggers           \"before:refresh\",\n                                  \"after:refresh\",\n                                  \"refresh\",\n                                  \"empty:results\"\n\ncollectionView.publicConfiguration\n  # Specify which collection will be used to supply the models to be rendered.\n  # Accepts either a string alias for the Collection class, or an instance of\n  # any class which inherits from Backbone.Collection\n  collection: undefined\n\n  # By default the CollectionView will be rendered inside of an OL tag.\n  tagName: \"ol\"\n\n  # The CollectionView behaves as a Luca.Panel which means it has an area for\n  # top and bottom toolbars.  The actual content that gets rendered from the \n  # collection will be rendered inside an element with the specified class.\n  bodyClassName: \"collection-ui-panel\"\n\n  # Each item from the collection will be rendered inside of an element specified by @itemTagName\n  itemTagName: 'li'\n\n  # Each item element will be assigned a CSS class specified by @itemClassName \n  itemClassName: 'collection-item'\n\n  # Specify which template should be used to render each item in the collection.  \n  # Accepts a string which will be passed to Luca.template(@itemTemplate).  Your template\n  # can expect to be passed an object with the `model` and `index` properties on it.\n  itemTemplate: undefined\n\n  # Accepts a reference to a function, which will be called with an object with the `model` and `index`\n  # properties on it.  This function should return a String which will be injected into the item DOM element.\n  itemRenderer: undefined\n\n  # Plucks the specified property from the model and inserts it into the item DOM element.\n  itemProperty: undefined\n\n  # If @observeChanges is set to true, any change in an underlying model will automatically be re-rendered.\n  observeChanges: false\n\ncollectionView.publicMethods\n  initialize: (@options={})->\n    _.extend(@, @options)\n    _.bindAll @, \"refresh\"\n\n    unless @collection? or @options.collection\n      console.log \"Error on initialize of collection view\", @\n      throw \"Collection Views must specify a collection\"\n\n    unless @itemTemplate? || @itemRenderer? || @itemProperty?\n      throw \"Collection Views must specify an item template or item renderer function\"\n\n    if _.isString(@collection) \n      if Luca.CollectionManager.get()\n        @collection = Luca.CollectionManager.get().getOrCreate(@collection)\n      else\n        console.log \"String Collection but no collection manager\"\n\n    unless Luca.isBackboneCollection(@collection)\n      console.log \"Missing Collection on #{ @name || @cid }\", @, @collection\n      throw \"Collection Views must have a valid backbone collection\"\n\n    # INVESTIGATE THIS BEING DOUBLE WORK\n    @on \"data:refresh\", @refresh, @\n    @on \"collection:reset\", @refresh, @\n\n    @on \"collection:remove\", @refresh, @\n    @on \"collection:add\", @refresh, @\n    @on \"collection:change\", @refreshModel, @ if @observeChanges is true\n\n    Luca.Panel::initialize.apply(@, arguments)\n\n    view = @\n    if @getCollection()?.length > 0\n      @on \"after:render\", ()->\n        view.refresh()\n        view.unbind \"after:render\", @\n\n  # Given the id of a model, find the underlying DOM element which was rendered by this collection.\n  # Assumes that the data-model-id attribute is set, which it is by default by @attributesForItem.\n  locateItemElement: (id)->\n    @$(\".#{ @itemClassName }[data-model-id='#{ id }']\")\n\n  # Refresh is responsible for applying any filtering, pagination, or sorting options that may be set\n  # from the various Luca.concerns mixed in by `Luca.CollectionView` and making a query to the underlying\n  # collection.  It will then take the set of models returned by `@getModels` and pass them through the\n  # item rendering pipeline.\n  refresh: ()->\n    query = @getLocalQuery()\n    options = @getQueryOptions()\n    models  = @getModels(query, options)\n\n    @$bodyEl().empty()\n\n    @trigger(\"before:refresh\", models, query, options)\n\n    if models.length is 0\n      @trigger(\"empty:results\", query, options)\n\n    index = 0\n    for model in models\n      @$append @makeItem(model, index++)\n\n    @trigger(\"after:refresh\", models, query, options)\n\n    @\n\ncollectionView.privateMethods\n  # Determines which attributes should be set on the item DOM element. \n  attributesForItem: (item, model)->\n    _.extend {}, class: @itemClassName, \"data-index\": item.index, \"data-model-id\": item.model.get('id')\n\n  # Determines the content for the item DOM element.  Will use the appropriate options\n  # specified by `@itemTemplate`, `@itemRenderer`, or `@itemProperty`\n  contentForItem: (item={})->\n    if @itemTemplate? and templateFn = Luca.template(@itemTemplate)\n      return content = templateFn.call(@, item)\n\n    if @itemRenderer? and _.isFunction( @itemRenderer )\n      return content = @itemRenderer.call(@, item, item.model, item.index)\n\n    if @itemProperty and item.model?\n      return content = item.model.read( @itemProperty )\n\n    \"\"\n\n  # Uses the various options passed to the `CollectionView` to assemble a call to `Luca.View::make`.\n  makeItem: (model, index)->\n    item = if @prepareItem? then @prepareItem.call(@, model, index) else (model:model, index: index)\n    attributes = @attributesForItem(item, model) \n    content = @contentForItem(item)\n\n    try\n      Luca.View::make(@itemTagName, attributes, content)\n    catch e\n      console.log \"Error generating DOM element for CollectionView\", @, model, index\n\n  # Given a model, attempt to re-render the contents of its item in this view's DOM contents.\n  refreshModel: (model)->\n    index = @collection.indexOf( model )\n    @locateItemElement(model.get('id')).empty().append( @contentForItem({model,index}, model) )\n    @trigger(\"model:refreshed\", index, model)\n\n\n  registerEvent: (domEvent, selector, handler)->\n    if !handler? and _.isFunction(selector)\n      handler = selector\n      selector = undefined\n\n    eventTrigger = _([domEvent,\"#{ @itemTagName }.#{ @itemClassName }\", selector]).compact().join(\" \")\n    Luca.View::registerEvent(eventTrigger,handler)\n\ncollectionView.register()\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/controller.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/controller.coffee","type":"component_definition","class_name":"Luca.components.Controller","header_documentation":"","type_alias":"controller","css_class_identifier":"luca-controller","defines_methods":{"default":{"defined_on_line":7,"documentation":"","arguments":[{"argument":"callback","value":null}]},"activePage":{"defined_on_line":10,"documentation":"","arguments":[]},"navigate_to":{"defined_on_line":13,"documentation":"","arguments":[{"argument":"section","value":null},{"argument":"callback","value":null}]},"setupComponentKeyEvents":{"defined_on_line":38,"documentation":"","arguments":[]},"controllerPath":{"defined_on_line":43,"documentation":"","arguments":[]},"initialize":{"defined_on_line":64,"documentation":"","arguments":[{"argument":"@options","value":null}]},"each":{"defined_on_line":83,"documentation":"","arguments":[{"argument":"fn","value":null}]},"activeSection":{"defined_on_line":86,"documentation":"","arguments":[]},"pageControllers":{"defined_on_line":89,"documentation":"","arguments":[{"argument":"deep","value":"false"}]},"controllers":{"defined_on_line":92,"documentation":"","arguments":[{"argument":"deep","value":"false"}]},"availablePages":{"defined_on_line":97,"documentation":"","arguments":[]},"availableSections":{"defined_on_line":100,"documentation":"","arguments":[]},"pageNames":{"defined_on_line":109,"documentation":"","arguments":[]},"sectionNames":{"defined_on_line":112,"documentation":"","arguments":[{"argument":"deep","value":"false"}]}},"defines_properties":{"tracker":{"defined_on_line":5,"documentation":"","default":""},"Luca.View":{"defined_on_line":57,"documentation":"","default":""},"additionalClassNames":{"defined_on_line":60,"documentation":"","default":""},"activeAttribute":{"defined_on_line":61,"documentation":"","default":""},"stateful":{"defined_on_line":62,"documentation":"","default":""}},"source_file_contents":"controller = Luca.register        \"Luca.components.Controller\"\ncontroller.extends                \"Luca.containers.CardView\"\n\ncontroller.publicInterface\n  tracker: \"page\"\n\n  default: (callback)->\n    @navigate_to(@defaultPage || @defaultCard, callback)\n\n  activePage: ()-> \n    @activeSection()\n\n  navigate_to: (section, callback)->\n    section ||= @defaultCard\n\n    @activate section, false, (activator, previous,current)=>\n      if current.activatedByController is true\n        current.trigger(\"on:controller:reactivation\")\n      else\n        current.trigger(\"on:controller:reactivation\")\n        current.trigger(\"on:controller:activation\")\n        current.activatedByController = true\n\n      @state.set(active_section: current.name )\n\n      if app = Luca.getApplication?()\n        app.state.set(@tracker, current.name)\n\n      Luca.key?.setScope( current.name )\n\n      if _.isFunction( callback )\n        callback.call(current)\n\n    # return the section we are navigating to\n    @find(section)\n\ncontroller.classMethods\n  setupComponentKeyEvents: ()->\n    @_().each (component)->    \n      if _.isObject(component.keyEvents) and component.name?\n        Luca.util.setupKeymaster(component.keyEvents, component.name).on(component)    \n\n  controllerPath: ()->\n    component = @\n    \n    list = [component.name]\n    atBase = false\n\n    while component and not atBase\n      component = component.getParent?()\n      atBase = true if component?.role is \"main_controller\"\n      list.push( component.name ) if component? and not atBase\n\n    list.reverse()\n\ncontroller.afterDefinition ()->\n  Luca.View::hooks.push \"on:controller:activation\"\n\ncontroller.defines\n  additionalClassNames: 'luca-ui-controller'\n  activeAttribute: \"active-section\"\n  stateful: true\n\n  initialize: (@options)->\n    # let's phase out the 'card' terminology \n    # and 'section' while we're at it.  page is the word.\n    @defaultCard ||= @defaultPage ||= @components[0]?.name || 0\n    @defaultPage ||= @defaultCard \n\n    @defaultState ||= \n      active_section: @defaultPage\n\n    Luca.containers.CardView::initialize.apply @, arguments\n\n    throw \"Controllers must specify a defaultCard property and/or the first component must have a name\" unless @defaultCard?\n\n    @_().each (component)->\n      component.controllerPath = Luca.components.Controller.controllerPath\n\n    @on \"after:render\", @default, @\n    @on \"before:render\", Luca.components.Controller.setupComponentKeyEvents, @\n\n  each: (fn)->\n    _( @components ).each (component)=> fn.call(@,component)\n\n  activeSection: ()->\n    @get(\"active_section\")\n\n  pageControllers: (deep=false)->\n    @controllers.apply(@, arguments)\n\n  controllers:(deep=false)->\n    @select (component)->\n      type = (component.type || component.ctype) \n      type is \"controller\" or type is \"page_controller\"\n\n  availablePages: ()->\n    @availableSections.apply(@, arguments)    \n\n  availableSections: ()->\n    base = {}\n    base[ @name ] = @sectionNames()\n\n    _( @controllers() ).reduce (memo,controller)=>\n      memo[ controller.name ] = controller.sectionNames()  \n      memo\n    , base \n\n  pageNames: ()->\n    @sectionNames()\n\n  sectionNames: (deep=false)->\n    @pluck('name')\n\n\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/base.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/base.coffee","type":"component_definition","class_name":"Luca.core.Field","header_documentation":"","type_alias":"field","css_class_identifier":"luca-core-field","defines_methods":{"disable":{"defined_on_line":19,"documentation":"","arguments":[]},"enable":{"defined_on_line":22,"documentation":"","arguments":[]},"getValue":{"defined_on_line":25,"documentation":"","arguments":[]},"setValue":{"defined_on_line":28,"documentation":"","arguments":[{"argument":"value","value":null}]},"updateState":{"defined_on_line":31,"documentation":"","arguments":[{"argument":"state","value":null}]},"clearErrors":{"defined_on_line":36,"documentation":"","arguments":[]},"displayErrors":{"defined_on_line":39,"documentation":"","arguments":[{"argument":"errors","value":null}]},"getParsedValue":{"defined_on_line":43,"documentation":"","arguments":[{"argument":"raw","value":null}]},"initialize":{"defined_on_line":57,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"beforeRender":{"defined_on_line":81,"documentation":"","arguments":[]},"change_handler":{"defined_on_line":87,"documentation":"","arguments":[{"argument":"e","value":null}]},"getInputElement":{"defined_on_line":90,"documentation":"","arguments":[]}},"defines_properties":{"labelAlign":{"defined_on_line":10,"documentation":"","default":""},"className":{"defined_on_line":11,"documentation":"","default":""},"isField":{"defined_on_line":53,"documentation":"","default":""},"template":{"defined_on_line":54,"documentation":"","default":""}},"source_file_contents":"field = Luca.register         \"Luca.core.Field\"\n\nfield.extends                 \"Luca.View\"\n\nfield.triggers                \"before:validation\",\n                              \"after:validation\",\n                              \"on:change\"\n\nfield.publicConfiguration\n  labelAlign: 'top'\n  className: 'luca-ui-text-field luca-ui-field'\n  statuses: [\n    \"warning\"\n    \"error\"\n    \"success\"\n  ]\n\nfield.publicInterface\n  disable: ()->\n    @getInputElement().attr('disabled', true)\n\n  enable: ()->\n    @getInputElement().attr('disabled', false)\n\n  getValue: ()->\n    @getParsedValue(@getInputElement()?.attr('value'))\n\n  setValue: (value)->\n    @getInputElement()?.attr('value', value)\n\n  updateState: (state)->\n    _( @statuses ).each (cls)=>\n      @$el.removeClass(cls)\n    @$el.addClass(state)\n\n  clearErrors: ()->\n    @$el.removeClass('error')\n\n  displayErrors: (errors)->\n    @updateState('error')\n\nfield.methods\n  getParsedValue: (raw)->\n    return raw if _.str.isBlank( raw )\n\n    switch @valueType\n      when \"integer\" then parseInt(raw)\n      when \"string\" then \"#{ raw }\"\n      when \"float\" then parseFloat(raw)\n      else raw\n\nfield.privateConfiguration\n  isField: true\n  template: 'fields/text_field'\n\nfield.defines\n  initialize: (@options={})->\n    _.extend @, @options\n\n    @input_id ||= _.uniqueId('field')\n    @input_name ||= @name\n    @input_class ||= \"\"\n    @input_type ||= \"\"\n    @helperText ||= \"\"\n    @label = @name if not @label? or @label.length is 0\n    @label ||= \"*#{ @label }\" if @required and not @label?.match(/^\\*/)\n    @inputStyles ||= \"\"\n    @input_value ||= @value || \"\"\n\n    @disable() if @disabled\n\n    @updateState( @state )\n    @placeHolder ||= \"\"\n\n    # In order to support using Luca.View template properties everywhere.\n\n    # Will need to work around how the field classes\n    # apply templates to themselves.\n    Luca.View::initialize.apply(@, arguments)\n\n  beforeRender: ()->\n    if Luca.config.enableBoostrap\n      @$el.addClass('control-group')\n\n    @$el.addClass('required') if @required\n\n  change_handler: (e)->\n    @trigger \"on:change\", @, e\n\n  getInputElement: ()->\n    @input ||= @$('input').eq(0)\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/button_field.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/button_field.coffee","type":"component_definition","class_name":"Luca.fields.ButtonField","header_documentation":"","type_alias":"button_field","css_class_identifier":"luca-fields-button-field","defines_methods":{"click_handler":{"defined_on_line":23,"documentation":"","arguments":[{"argument":"e","value":null}]},"initialize":{"defined_on_line":27,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"afterInitialize":{"defined_on_line":35,"documentation":"","arguments":[]},"setValue":{"defined_on_line":44,"documentation":"","arguments":[]}},"defines_properties":{"readOnly":{"defined_on_line":8,"documentation":"","default":""},"input_value":{"defined_on_line":9,"documentation":"","default":""},"input_type":{"defined_on_line":10,"documentation":"","default":""},"icon_class":{"defined_on_line":11,"documentation":"","default":""},"input_name":{"defined_on_line":12,"documentation":"","default":""},"white":{"defined_on_line":13,"documentation":"","default":""},"isButton":{"defined_on_line":17,"documentation":"","default":""},"template":{"defined_on_line":18,"documentation":"","default":""}},"source_file_contents":"buttonField = Luca.register         \"Luca.fields.ButtonField\"\n\nbuttonField.extends                 \"Luca.core.Field\"\n\nbuttonField.triggers                \"button:click\"\n\nbuttonField.publicConfiguration\n  readOnly:       true\n  input_value:    undefined \n  input_type:     \"button\" \n  icon_class:     undefined\n  input_name:     undefined\n  white:          undefined\n  buttonClasses:  \"\" \n\nbuttonField.privateConfiguration\n  isButton: true\n  template: \"fields/button_field\"\n  events:\n    \"click input\" : \"click_handler\"\n\nbuttonField.privateInterface\n  click_handler: (e)->\n    me = my = $( e.currentTarget )\n    @trigger \"button:click\"\n\n  initialize: (@options={})->\n    _.extend @options\n    _.bindAll @, \"click_handler\"\n\n    Luca.core.Field::initialize.apply @, arguments\n\n    @template = \"fields/button_field_link\" if @icon_class?.length\n\n  afterInitialize: ()->\n    @input_id ||= _.uniqueId('button')\n    @input_name ||= @name ||= @input_id\n    @input_value ||= @label ||= @text\n    @input_class ||= @class ||= @buttonClasses\n    @icon_class ||= \"\"\n    @icon_class = \"icon-#{ @icon_class }\" if @icon_class.length and !@icon_class.match(/^icon-/)\n    @icon_class += \" icon-white\" if @white\n\n  setValue: ()-> true\n\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/checkbox_array.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/checkbox_array.coffee","type":"component_definition","class_name":"Luca.fields.CheckboxArray","header_documentation":"","type_alias":"checkbox_array","css_class_identifier":"luca-fields-checkbox-array","defines_methods":{"initialize":{"defined_on_line":18,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"afterInitialize":{"defined_on_line":31,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"clickHandler":{"defined_on_line":47,"documentation":"","arguments":[{"argument":"event","value":null}]},"controls":{"defined_on_line":56,"documentation":"","arguments":[]},"renderCheckboxes":{"defined_on_line":59,"documentation":"","arguments":[]},"uncheckAll":{"defined_on_line":77,"documentation":"","arguments":[]},"allFields":{"defined_on_line":80,"documentation":"","arguments":[]},"checkSelected":{"defined_on_line":83,"documentation":"","arguments":[{"argument":"items","value":null}]},"getValue":{"defined_on_line":94,"documentation":"","arguments":[]},"setValue":{"defined_on_line":97,"documentation":"","arguments":[{"argument":"items","value":null}]},"getValues":{"defined_on_line":108,"documentation":"","arguments":[]},"setValues":{"defined_on_line":111,"documentation":"","arguments":[{"argument":"items","value":null}]}},"defines_properties":{"version":{"defined_on_line":7,"documentation":"","default":""},"template":{"defined_on_line":9,"documentation":"","default":""},"className":{"defined_on_line":11,"documentation":"","default":""}},"source_file_contents":"make = Luca.View::make\n\ncheckboxArray = Luca.register     \"Luca.fields.CheckboxArray\"\ncheckboxArray.extends             \"Luca.core.Field\"\n\ncheckboxArray.defines\n  version: 2\n\n  template: \"fields/checkbox_array\"\n\n  className: \"luca-ui-checkbox-array\"\n\n  events:\n    \"click input\" : \"clickHandler\"\n\n  selectedItems: []\n\n  initialize: (@options={})->\n    _.extend @, @options\n    _.extend @, Luca.concerns.Deferrable\n    _.bindAll @, \"renderCheckboxes\", \"clickHandler\", \"checkSelected\"\n\n    Luca.core.Field::initialize.apply @, arguments\n\n    @input_id ||= _.uniqueId('field')\n    @input_name ||= @name\n    @label ||= @name\n    @valueField ||= \"id\"\n    @displayField ||= \"name\"\n\n  afterInitialize: (@options={})->\n    try\n      @configure_collection()\n    catch e\n      console.log \"Error Configuring Collection\", @, e.message\n\n    cbArray = @\n\n    unless Luca.isBackboneCollection(@collection)\n      throw \"Checkbox Array Fields must specify a @collection property\"\n      \n    if @collection.length > 0\n      @renderCheckboxes()\n    else\n      @defer(\"renderCheckboxes\").until(@collection,\"reset\")\n\n  clickHandler: (event)->\n    checkbox = $(event.target)\n\n    if checkbox.prop('checked')\n      @selectedItems.push( checkbox.val() )\n    else\n      if _( @selectedItems ).include( checkbox.val() )\n        @selectedItems = _( @selectedItems ).without( checkbox.val() )\n\n  controls: ()->\n    @$('.controls')\n\n  renderCheckboxes: ()->\n    @controls().empty()\n    @selectedItems = []\n\n    @collection.each (model)=>\n      value = model.get(@valueField)\n      label = model.get(@displayField)\n      input_id = _.uniqueId(\"#{ @cid }_checkbox\")\n\n      inputElement = make(\"input\",type:\"checkbox\",class:\"array-checkbox\",name:@input_name,value:value,id: input_id)\n      element = make(\"label\", {for:input_id}, inputElement)\n\n      $( element ).append(\" #{ label }\")\n      @controls().append( element )\n\n    @trigger(\"checkboxes:rendered\", @checkboxesRendered = true)\n    @\n\n  uncheckAll: ()->\n    @allFields().prop('checked', false)\n\n  allFields: ()->\n    @controls().find(\"input[type='checkbox']\")\n\n  checkSelected: (items)->\n    @selectedItems = items if items?\n\n    @uncheckAll()\n\n    for value in @selectedItems\n      checkbox = @controls().find(\"input[value='#{ value }']\")\n      checkbox.prop('checked', true)\n\n    @selectedItems\n\n  getValue: ()->\n    @$(field).val() for field in @allFields() when @$(field).prop('checked')\n\n  setValue: (items)->\n    @selectedItems = items\n\n    if @checkboxesRendered is true\n      @checkSelected(items)\n    else\n      cbArray = @\n      @defer ()->\n        cbArray.checkSelected(items)\n      .until(\"checkboxes:rendered\")\n\n  getValues: ()->\n    @getValue()\n\n  setValues: (items)->\n    @setValue(items)"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/checkbox_field.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/checkbox_field.coffee","type":"component_definition","class_name":"Luca.fields.CheckboxField","header_documentation":"","type_alias":"checkbox_field","css_class_identifier":"luca-fields-checkbox-field","defines_methods":{"change_handler":{"defined_on_line":18,"documentation":"","arguments":[{"argument":"e","value":null}]},"initialize":{"defined_on_line":28,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"setValue":{"defined_on_line":39,"documentation":"","arguments":[{"argument":"checked","value":null}]},"getValue":{"defined_on_line":42,"documentation":"","arguments":[]}},"defines_properties":{"send_blanks":{"defined_on_line":9,"documentation":"","default":""},"input_value":{"defined_on_line":10,"documentation":"","default":""},"template":{"defined_on_line":13,"documentation":"","default":""},"version":{"defined_on_line":46,"documentation":"","default":""}},"source_file_contents":"checkboxField = Luca.register         \"Luca.fields.CheckboxField\"\n\ncheckboxField.extends                 \"Luca.core.Field\"\n\ncheckboxField.triggers                \"checked\",\n                                      \"unchecked\"\n\ncheckboxField.publicConfiguration\n  send_blanks: true\n  input_value: 1\n\ncheckboxField.privateConfiguration\n  template: 'fields/checkbox_field'\n  events:\n    \"change input\" : \"change_handler\"\n\ncheckboxField.privateInterface\n  change_handler: (e)->\n    me = my = $(e.target)\n\n    if me.is(\":checked\")\n      @trigger \"checked\"\n    else\n      @trigger \"unchecked\"\n\n    @trigger \"on:change\", @, e, me.is(\":checked\")\n\n  initialize: (@options={})->\n    _.extend @, @options\n    _.bindAll @, \"change_handler\"\n\n    Luca.core.Field::initialize.apply @, arguments\n\n    @input_id ||= _.uniqueId('field')\n    @input_name ||= @name\n    @label ||= @name\n\ncheckboxField.publicInterface\n  setValue: (checked)->\n    @getInputElement().attr('checked', checked)\n\n  getValue:()->\n    @getInputElement().is(\":checked\")\n\ncheckboxField.defines\n  version: 1"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/file_upload_field.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/file_upload_field.coffee","type":"component_definition","class_name":"Luca.fields.FileUploadField","header_documentation":"","type_alias":"file_upload_field","css_class_identifier":"luca-fields-file-upload-field","defines_methods":{"afterInitialize":{"defined_on_line":9,"documentation":"","arguments":[]}},"defines_properties":{"version":{"defined_on_line":5,"documentation":"","default":""},"template":{"defined_on_line":7,"documentation":"","default":""}},"source_file_contents":"fileUpload = Luca.register              \"Luca.fields.FileUploadField\"\nfileUpload.extends                      \"Luca.core.Field\"\n\nfileUpload.defines\n  version: 1\n\n  template: 'fields/file_upload_field'\n\n  afterInitialize: ()->\n    @input_id ||= _.uniqueId('field')\n    @input_name ||= @name\n    @label ||= @name\n    @helperText ||= \"\"\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/hidden_field.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/hidden_field.coffee","type":"component_definition","class_name":"Luca.fields.HiddenField","header_documentation":"","type_alias":"hidden_field","css_class_identifier":"luca-fields-hidden-field","defines_methods":{"afterInitialize":{"defined_on_line":7,"documentation":"","arguments":[]}},"defines_properties":{"template":{"defined_on_line":5,"documentation":"","default":""}},"source_file_contents":"hiddenField = Luca.register       \"Luca.fields.HiddenField\"\nhiddenField.extends               \"Luca.core.Field\"\n\nhiddenField.defines\n  template: 'fields/hidden_field'\n\n  afterInitialize: ()->\n    @input_id ||= _.uniqueId('field')\n    @input_name ||= @name\n    @input_value ||= @value\n    @label ||= @name"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/label_field.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/label_field.coffee","type":"component_definition","class_name":"Luca.components.LabelField","header_documentation":"","type_alias":"label_field","css_class_identifier":"luca-label-field","defines_methods":{"formatter":{"defined_on_line":5,"documentation":"","arguments":[{"argument":"value","value":null}]},"setValue":{"defined_on_line":9,"documentation":"","arguments":[{"argument":"value","value":null}]}},"defines_properties":{},"source_file_contents":"labelField = Luca.register          \"Luca.components.LabelField\"\nlabelField.extends                  \"Luca.core.Field\"\n\nlabelField.defines\n  formatter: (value)->\n    value ||= @getValue()\n    _.str.titleize( value )\n\n  setValue: (value)->\n    @trigger(\"change\", value, @getValue())\n    @getInputElement().attr('value', value)\n    @$('.value').html( @formatter(value) )\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/select_field.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/select_field.coffee","type":"component_definition","class_name":"Luca.fields.SelectField","header_documentation":"","type_alias":"select_field","css_class_identifier":"luca-fields-select-field","defines_methods":{"setValue":{"defined_on_line":47,"documentation":"<p>sets the value of this select field.</p>\n","arguments":[{"argument":"value","value":null}]},"getValue":{"defined_on_line":54,"documentation":"<p>returns the value of the select field.  runs\nthe value through the getParsedValue method which\nenforces the valueType type conversion.</p>\n","arguments":[]},"initialize":{"defined_on_line":64,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"afterInitialize":{"defined_on_line":80,"documentation":"","arguments":[]},"parseData":{"defined_on_line":99,"documentation":"<p>if the select field is configured with a data property\nthen parse that data into the proper format.  either\nan array of objects with the valueField and displayField\nproperties, or an array of arrays with [valueField, displayField]</p>\n","arguments":[]},"getInputElement":{"defined_on_line":109,"documentation":"","arguments":[]},"afterRender":{"defined_on_line":112,"documentation":"","arguments":[]},"beforeFetch":{"defined_on_line":118,"documentation":"","arguments":[]},"change_handler":{"defined_on_line":121,"documentation":"","arguments":[{"argument":"e","value":null}]},"resetOptions":{"defined_on_line":124,"documentation":"","arguments":[]},"populateOptions":{"defined_on_line":132,"documentation":"","arguments":[]}},"defines_properties":{"allowMultiple":{"defined_on_line":10,"documentation":"<p>Enables multi-select UI element.</p>\n","default":""},"includeBlank":{"defined_on_line":14,"documentation":"<p>Includes a blank option in addition to all of the items\nin the underlying collection.  Defaults to <code>true</code></p>\n","default":""},"blankText":{"defined_on_line":22,"documentation":"<p>Determines the text displayed when\nthe blank option is selected</p>\n","default":""},"maxDisplayLength":{"defined_on_line":28,"documentation":"<p>Specifying a value for maxDisplayLength will truncate\nvalues displayed in the select field when they reach\npast a certain point, using the _.str truncate method.\nLeave at 0 if you want to keep this feature disabled.</p>\n","default":""},"retainValue":{"defined_on_line":34,"documentation":"<p>When the underlying collection is reset and we re-render\nthe options elements, should we keep the value that was set\non this field prior to that? Defaults to <code>true</code> unless otherwise\nspecified.</p>\n","default":""},"label":{"defined_on_line":38,"documentation":"<p>Determines which value is rendered in the label element that gets\nrendered along with this control group.</p>\n","default":""},"template":{"defined_on_line":41,"documentation":"","default":""}},"source_file_contents":"selectField = Luca.register   \"Luca.fields.SelectField\"\n\nselectField.extends           \"Luca.core.Field\"\n\nselectField.triggers          \"after:select\",\n                              \"on:change\"\n\nselectField.publicConfiguration\n  # Enables multi-select UI element.\n  allowMultiple: false\n\n  # Includes a blank option in addition to all of the items\n  # in the underlying collection.  Defaults to `true` \n  includeBlank: true\n\n  # determines which value is sent when \n  # the blank option is selected?\n  blankValue: ''\n\n  # Determines the text displayed when \n  # the blank option is selected \n  blankText: 'Select One'\n\n  # Specifying a value for maxDisplayLength will truncate\n  # values displayed in the select field when they reach \n  # past a certain point, using the _.str truncate method.\n  # Leave at 0 if you want to keep this feature disabled.\n  maxDisplayLength: 0 \n\n  # When the underlying collection is reset and we re-render\n  # the options elements, should we keep the value that was set\n  # on this field prior to that? Defaults to `true` unless otherwise\n  # specified.\n  retainValue: undefined\n\n  # Determines which value is rendered in the label element that gets\n  # rendered along with this control group. \n  label: undefined\n\nselectField.privateConfiguration\n  template: \"fields/select_field\"\n  events:\n    \"change select\" : \"change_handler\"\n\nselectField.publicMethods\n  # sets the value of this select field.\n  setValue: (value)->\n    @currentValue = value\n    Luca.core.Field::setValue.apply @, arguments\n\n  # returns the value of the select field.  runs\n  # the value through the getParsedValue method which\n  # enforces the valueType type conversion.\n  getValue: ()->\n    raw = @getInputElement()?.val()\n\n    if @allowMultiple\n      _.map raw, (value)=>\n        @getParsedValue(value)\n    else\n      @getParsedValue(raw)\n\nselectField.privateMethods\n  initialize: (@options={})->\n    _.extend @, @options\n    _.extend @, Luca.concerns.Deferrable\n    _.bindAll @, \"change_handler\"\n\n    if _.isArray(@collection)\n      @collection = data: @collection\n\n    Luca.core.Field::initialize.apply @, arguments\n\n    @input_id ||= _.uniqueId('field')\n    @input_name ||= @name\n    @valueType ||= Luca.config.idAttributeType if @valueField is \"id\"\n    @label ||= @name\n    @retainValue = true unless @retainValue? \n\n  afterInitialize: ()->\n    if @collection?.data\n      @valueField ||= \"id\"\n      @displayField ||= \"name\"\n      @sortOptionsBy ||= @displayField\n      @parseData()\n\n    try\n      @configure_collection( @setAsDeferrable )\n    catch e\n      console.log \"Error Configuring Collection\", @, e.message\n\n    @collection?.bind \"before:fetch\", @beforeFetch, @\n    @collection?.bind \"reset\", @populateOptions, @\n\n  # if the select field is configured with a data property\n  # then parse that data into the proper format.  either\n  # an array of objects with the valueField and displayField\n  # properties, or an array of arrays with [valueField, displayField]\n  parseData: ()->\n    @collection.data = _( @collection.data ).map (record)=>\n      return record if not _.isArray( record )\n\n      hash = {}\n      hash[ @valueField ] = record[0]\n      hash[ @displayField ] = record[1] || record[0]\n\n      hash\n\n  getInputElement: ()->\n    @input ||= @$('select').eq(0)\n\n  afterRender: ()->\n    if @collection?.models?.length > 0\n      @populateOptions()\n    else\n      @collection?.trigger(\"reset\")\n\n  beforeFetch: ()->\n    @resetOptions()\n\n  change_handler: (e)->\n    @trigger \"on:change\", @, e\n\n  resetOptions: ()->\n    @getInputElement().html('')\n\n    if @allowMultiple\n      @getInputElement().attr(multiple: true)\n    else if @includeBlank\n      @getInputElement().append(\"<option value='#{ @blankValue }'>#{ @blankText }</option>\")\n\n  populateOptions: ()->\n    @resetOptions()\n\n    if @collection?.length > 0\n      if @sortOptionsBy?\n        models = @collection.sortBy (model)=>\n          if model.read?\n            model.read( @sortOptionsBy )\n          else\n            model.get( @sortOptionsBy )\n      else\n        models = @collection.models\n\n      for model in models\n        v = model.read?( @valueField ) || model.get(@valueField)\n        d = model.read?( @displayField ) || model.get(@displayField)\n\n        if @maxDisplayLength and @maxDisplayLength > 0\n          d = _.str.truncate(d, @maxDisplayLength)\n\n        selected = \"selected\" if @selected and v is @selected\n        option = \"<option #{ selected } value='#{ v }'>#{ d }</option>\"\n        @getInputElement().append( option )\n\n    @trigger \"after:populate:options\", @\n    @setValue( @currentValue )\n\nselectField.register()"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/text_area_field.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/text_area_field.coffee","type":"component_definition","class_name":"Luca.fields.TextAreaField","header_documentation":"","type_alias":"text_area_field","css_class_identifier":"luca-fields-text-area-field","defines_methods":{"initialize":{"defined_on_line":16,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"setValue":{"defined_on_line":35,"documentation":"","arguments":[{"argument":"value","value":null}]},"getValue":{"defined_on_line":38,"documentation":"","arguments":[]},"field":{"defined_on_line":41,"documentation":"","arguments":[]},"keyup_handler":{"defined_on_line":44,"documentation":"","arguments":[{"argument":"e","value":null}]},"blur_handler":{"defined_on_line":50,"documentation":"","arguments":[{"argument":"e","value":null}]},"focus_handler":{"defined_on_line":53,"documentation":"","arguments":[{"argument":"e","value":null}]},"change_handler":{"defined_on_line":56,"documentation":"","arguments":[{"argument":"e","value":null}]}},"defines_properties":{"autoBindEventHandlers":{"defined_on_line":4,"documentation":"","default":""},"template":{"defined_on_line":10,"documentation":"","default":""},"height":{"defined_on_line":12,"documentation":"","default":""},"width":{"defined_on_line":13,"documentation":"","default":""},"keyEventThrottle":{"defined_on_line":14,"documentation":"","default":""}},"source_file_contents":"textArea = Luca.register          \"Luca.fields.TextAreaField\"\ntextArea.extends                  \"Luca.core.Field\"\ntextArea.defines\n  autoBindEventHandlers: true\n\n  events:\n    \"blur textarea\" : \"blur_handler\"\n    \"focus textarea\" : \"focus_handler\"\n\n  template: 'fields/text_area_field'\n\n  height: \"200px\"\n  width: \"90%\"\n  keyEventThrottle: 300\n\n  initialize: (@options={})->\n\n    @input_id ||= _.uniqueId('field')\n    @input_name ||= @name\n    @label ||= @name\n    @input_class ||= @class\n    @input_value ||= \"\"\n    @inputStyles ||= \"height:#{ @height };width:#{ @width }\"\n    @placeHolder ||= \"\"\n\n    Luca.core.Field::initialize.apply @, arguments\n\n    if @enableKeyEvents is true\n      @keyup_handler = _.debounce(@keyup_handler, @keyEventThrottle || 10)\n\n      console.log \"Registering Key Events\"\n      @registerEvent(\"keyup textarea\",\"keyup_handler\")     \n      @registerEvent(\"keydown textarea\",\"keyup_handler\")     \n\n  setValue: (value)->\n    $( @field() ).val(value)\n\n  getValue: ()->\n    $( @field() ).val()\n\n  field: ()->\n    @input = @$(\"textarea\")\n\n  keyup_handler: (e)->\n    # TODO: Should ignore certain keyup events\n    # which would not indicate a change\n    @trigger \"on:change\", @, e\n    @trigger \"on:keyup\", @, e\n\n  blur_handler: (e)->\n    @trigger \"on:blur\", @, e\n\n  focus_handler: (e)->\n    @trigger \"on:focus\", @, e\n\n  change_handler: (e)-> \n    @trigger \"on:change\", @, e"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/text_field.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/text_field.coffee","type":"component_definition","class_name":"Luca.fields.TextField","header_documentation":"","type_alias":"text_field","css_class_identifier":"luca-fields-text-field","defines_methods":{"initialize":{"defined_on_line":18,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"keyup_handler":{"defined_on_line":43,"documentation":"","arguments":[{"argument":"e","value":null}]},"blur_handler":{"defined_on_line":49,"documentation":"","arguments":[{"argument":"e","value":null}]},"focus_handler":{"defined_on_line":52,"documentation":"","arguments":[{"argument":"e","value":null}]},"change_handler":{"defined_on_line":55,"documentation":"","arguments":[{"argument":"e","value":null}]}},"defines_properties":{"template":{"defined_on_line":10,"documentation":"","default":""},"autoBindEventHandlers":{"defined_on_line":12,"documentation":"","default":""},"send_blanks":{"defined_on_line":14,"documentation":"","default":""},"keyEventThrottle":{"defined_on_line":16,"documentation":"","default":""}},"source_file_contents":"textField = Luca.register     'Luca.fields.TextField'\ntextField.extends             'Luca.core.Field'\n\ntextField.defines\n  _events:\n    \"blur input\" : \"blur_handler\"\n    \"focus input\" : \"focus_handler\"\n    \"change input\" : \"change_handler\"\n\n  template: 'fields/text_field'\n\n  autoBindEventHandlers: true\n\n  send_blanks: true\n\n  keyEventThrottle: 300\n\n  initialize: (@options={})->\n    if @enableKeyEvents\n      if @keyEventThrottle\n        @keyup_handler = _.debounce(@keyup_handler, @keyEventThrottle)\n        \n      @registerEvent(\"keyup input\",\"keyup_handler\")     \n\n    @input_id ||= _.uniqueId('field')\n    @input_name ||= @name\n    @label ||= @name\n    @input_class ||= @class\n    @input_value ||= @value || \"\" \n    \n    if @prepend\n      @$el.addClass 'input-prepend'\n      @addOn = @prepend\n\n    if @append\n      @$el.addClass 'input-append'\n      @addOn = @append\n\n    @placeHolder ||= \"\"\n\n    Luca.core.Field::initialize.apply @, arguments\n\n  keyup_handler: (e)->\n    # TODO: Should ignore certain keyup events\n    # which would not indicate a change\n    @trigger \"on:change\", @, e\n    @trigger \"on:keyup\", @, e\n\n  blur_handler: (e)->\n    @trigger \"on:blur\", @, e\n\n  focus_handler: (e)->\n    @trigger \"on:focus\", @, e\n\n  change_handler: (e)-> \n    @trigger \"on:change\", @, e\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/type_ahead_field.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/fields/type_ahead_field.coffee","type":"component_definition","class_name":"Luca.fields.TypeAheadField","header_documentation":"","type_alias":"type_ahead_field","css_class_identifier":"luca-fields-type-ahead-field","defines_methods":{"getSource":{"defined_on_line":6,"documentation":"","arguments":[]},"matcher":{"defined_on_line":9,"documentation":"","arguments":[{"argument":"item","value":null}]},"beforeRender":{"defined_on_line":12,"documentation":"","arguments":[]},"afterRender":{"defined_on_line":16,"documentation":"","arguments":[]}},"defines_properties":{},"source_file_contents":"typeAheadField = Luca.register      \"Luca.fields.TypeAheadField\"\ntypeAheadField.extends              \"Luca.fields.TextField\" \n\n\ntypeAheadField.defines\n  getSource: ()->\n    Luca.util.read(@source) || []\n\n  matcher: (item)->\n    true\n\n  beforeRender: ()->\n    Luca.fields.TextField::beforeRender.apply(@, arguments)\n    @getInputElement().attr('data-provide','typeahead')\n\n  afterRender: ()->\n    Luca.fields.TextField::afterRender.apply(@, arguments)\n    @getInputElement().typeahead\n      matcher: @matcher\n      source: @getSource()"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/form_view.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/form_view.coffee","type":"component_definition","class_name":"Luca.components.FormView","header_documentation":"<p>The FormView component is a special container which provides functionality\naround the components inside which extend from the Luca.core.Field class.\nThe FormView component integrates well with Luca.Models and can control\nthe attributes on that model, respond to validations, and submit changes\nto an API.</p>\n","type_alias":"form_view","css_class_identifier":"luca-form-view","defines_methods":{"initialize":{"defined_on_line":110,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"onFieldChange":{"defined_on_line":138,"documentation":"","arguments":[{"argument":"field","value":null},{"argument":"e","value":null}]},"getDefaultToolbar":{"defined_on_line":142,"documentation":"","arguments":[]},"applyStyleClasses":{"defined_on_line":146,"documentation":"","arguments":[]},"applyBootstrapStyleClasses":{"defined_on_line":153,"documentation":"","arguments":[]},"resetHandler":{"defined_on_line":161,"documentation":"","arguments":[{"argument":"e","value":null}]},"submitHandler":{"defined_on_line":170,"documentation":"","arguments":[{"argument":"e","value":null}]},"afterComponents":{"defined_on_line":180,"documentation":"","arguments":[]},"eachField":{"defined_on_line":188,"documentation":"","arguments":[{"argument":"iterator","value":null}]},"getField":{"defined_on_line":191,"documentation":"","arguments":[{"argument":"name","value":null}]},"getFields":{"defined_on_line":197,"documentation":"","arguments":[{"argument":"attr","value":null},{"argument":"value","value":null}]},"loadModel":{"defined_on_line":208,"documentation":"","arguments":[{"argument":"model","value":null}]},"reset":{"defined_on_line":230,"documentation":"","arguments":[]},"clear":{"defined_on_line":233,"documentation":"","arguments":[]},"isDirty":{"defined_on_line":242,"documentation":"","arguments":[]},"setValues":{"defined_on_line":247,"documentation":"<p>set the values on the form\nwithout syncing</p>\n","arguments":[{"argument":"source","value":null},{"argument":"options","value":"{}"}]},"getValues":{"defined_on_line":270,"documentation":"<p>Public: returns a hash of values for the form fields in this view.</p>\n\n<p>options - An options Hash to control the behavior of values returned (default: {}):\nreject<em>blank: don&#39;t include values which are blank (default: true)\nskip</em>buttons: don&#39;t include button fields (default: true)\nblanks: an inverse alias for reject_blank (default: false)</p>\n","arguments":[{"argument":"options","value":"{}"}]},"removeErrors":{"defined_on_line":309,"documentation":"","arguments":[]},"displayErrors":{"defined_on_line":316,"documentation":"","arguments":[{"argument":"errors","value":null}]},"displayValidationErrorsMessage":{"defined_on_line":326,"documentation":"","arguments":[]},"submit_success_handler":{"defined_on_line":329,"documentation":"","arguments":[{"argument":"model","value":null},{"argument":"response","value":null},{"argument":"xhr","value":null}]},"submit_fatal_error_handler":{"defined_on_line":338,"documentation":"","arguments":[{"argument":"model","value":null},{"argument":"response","value":null},{"argument":"xhr","value":null}]},"submit":{"defined_on_line":348,"documentation":"","arguments":[{"argument":"save","value":"true"},{"argument":"saveOptions","value":"{}"}]},"hasModel":{"defined_on_line":359,"documentation":"","arguments":[]},"currentModel":{"defined_on_line":362,"documentation":"","arguments":[{"argument":"options","value":"{}"}]},"applyFormValuesToModel":{"defined_on_line":368,"documentation":"","arguments":[{"argument":"options","value":null}]},"setLegend":{"defined_on_line":371,"documentation":"","arguments":[{"argument":"@legend","value":null}]},"flash":{"defined_on_line":374,"documentation":"","arguments":[{"argument":"message","value":null}]},"successMessage":{"defined_on_line":382,"documentation":"","arguments":[{"argument":"message","value":null}]},"errorMessage":{"defined_on_line":389,"documentation":"","arguments":[{"argument":"message","value":null}]},"setupToolbar":{"defined_on_line":394,"documentation":"","arguments":[]}},"defines_properties":{"trackDirtyState":{"defined_on_line":35,"documentation":"<p>track dirty state will bind to change events\non all of the underlying fields, and set a\nflag whenever one of them changes</p>\n","default":""},"trackModelChanges":{"defined_on_line":38,"documentation":"<p>don&#39;t setup two way binding to the model</p>\n","default":""},"labelAlign":{"defined_on_line":42,"documentation":"<p>should the label display above, or to the\nside of the fields</p>\n","default":""},"fieldLayoutClass":{"defined_on_line":46,"documentation":"<p>specifying this class gives you the ability\nto layout the nested fields accordingly.</p>\n","default":""},"toolbar":{"defined_on_line":55,"documentation":"<p>available options are true, false, &quot;top&quot;, &quot;bottom&quot;, or &quot;both&quot;\nthe component configuration for the toolbar can be controlled\nby specifying a name of a property that contains a valid\ncomponent reference ( either hash w/ type reference )</p>\n","default":""},"toolbarConfig":{"defined_on_line":60,"documentation":"<p>the name of the property which contains the configuration\nfor the buttons that will go in this toolbar.  Specify\na string so it can be lazily evaluated at initialization.</p>\n","default":""},"defaultToolbar":{"defined_on_line":66,"documentation":"<p>the default toolbar definition that will be created if\nthe form is configured to have a toolbar on it.  this value\nwill be resolved at initialization, so pass a string identifying\nan object in memory.</p>\n","default":""},"loadMask":{"defined_on_line":71,"documentation":"<p>if this form will be submitting values to a RESTful API and you\nwant to show a loading indicator or progress bar, configure the\n@loadMask property.</p>\n","default":""},"well":{"defined_on_line":75,"documentation":"<p>Applies the twitter bootstrap well class to this form.\n@$el.addClass(&#39;well&#39;) if @well</p>\n","default":""},"searchForm":{"defined_on_line":79,"documentation":"<p>Applies the twitter bootstrap form-search class to this form.\n@$el.addClass(&#39;form-search&#39;) if @searchForm</p>\n","default":""},"horizontalForm":{"defined_on_line":83,"documentation":"<p>Applies the twitter bootstrap horizontal form class to this form.\n@$el.addClass(&#39;form-horizontal&#39;) if @horizontalForm</p>\n","default":""},"inlineForm":{"defined_on_line":87,"documentation":"<p>Applies the twitter bootstrap inline form class to this form.\n@$el.addClass(&#39;form-inline&#39;) if @inlineForm</p>\n","default":""},"includeBlankValues":{"defined_on_line":91,"documentation":"<p>if we should always include blank values\nregardless of how the field is configured</p>\n","default":""},"tagName":{"defined_on_line":94,"documentation":"","default":""},"bodyClassName":{"defined_on_line":103,"documentation":"","default":""},"successFlashDelay":{"defined_on_line":380,"documentation":"","default":""},"version":{"defined_on_line":420,"documentation":"","default":""}},"source_file_contents":"# The FormView component is a special container which provides functionality\n# around the components inside which extend from the Luca.core.Field class.\n#\n# The FormView component integrates well with Luca.Models and can control\n# the attributes on that model, respond to validations, and submit changes\n# to an API.\nformView = Luca.register        \"Luca.components.FormView\"\n\nformView.extends                \"Luca.Container\"\n\nformView.mixesIn                \"LoadMaskable\",\n                                \"FormModelBindings\"\n\nformView.triggers               \"before:submit\",\n                                \"before:reset\",\n                                \"before:load\",\n                                \"before:load:new\",\n                                \"before:load:existing\",\n                                \"after:submit\",\n                                \"after:reset\",\n                                \"after:load\",\n                                \"after:load:new\",\n                                \"after:load:existing\",\n                                \"after:submit:success\",\n                                \"after:submit:fatal_error\",\n                                \"after:submit:error\",\n                                \"state:change:dirty\"\n\n\n\nformView.publicConfiguration\n  # track dirty state will bind to change events\n  # on all of the underlying fields, and set a\n  # flag whenever one of them changes\n  trackDirtyState: false\n\n  # don't setup two way binding to the model\n  trackModelChanges: false\n\n  # should the label display above, or to the\n  # side of the fields\n  labelAlign: undefined\n\n  # specifying this class gives you the ability\n  # to layout the nested fields accordingly.\n  fieldLayoutClass: undefined\n\n  # should this form have a legend?\n  legend: \"\"\n\n  # available options are true, false, \"top\", \"bottom\", or \"both\"\n  # the component configuration for the toolbar can be controlled\n  # by specifying a name of a property that contains a valid\n  # component reference ( either hash w/ type reference )\n  toolbar: true\n\n  # the name of the property which contains the configuration\n  # for the buttons that will go in this toolbar.  Specify\n  # a string so it can be lazily evaluated at initialization.\n  toolbarConfig: undefined\n\n  # the default toolbar definition that will be created if\n  # the form is configured to have a toolbar on it.  this value\n  # will be resolved at initialization, so pass a string identifying\n  # an object in memory.\n  defaultToolbar: \"Luca.components.FormView.defaultToolbar\"\n\n  # if this form will be submitting values to a RESTful API and you\n  # want to show a loading indicator or progress bar, configure the\n  # @loadMask property.\n  loadMask: true\n\n  # Applies the twitter bootstrap well class to this form.\n  # @$el.addClass('well') if @well\n  well: false\n\n  # Applies the twitter bootstrap form-search class to this form.\n  # @$el.addClass('form-search') if @searchForm\n  searchForm: false\n\n  # Applies the twitter bootstrap horizontal form class to this form.\n  # @$el.addClass('form-horizontal') if @horizontalForm\n  horizontalForm: false\n\n  # Applies the twitter bootstrap inline form class to this form.\n  # @$el.addClass('form-inline') if @inlineForm\n  inlineForm: false\n\n  # if we should always include blank values\n  # regardless of how the field is configured\n  includeBlankValues: undefined\n\nformView.privateConfiguration\n  tagName: 'form'\n\n  # These events will get registered on the component\n  # but still leave the @events property open to extend\n  # for any component which inherits from us.\n  _events:\n    \"click .submit-button\" : \"submitHandler\"\n    \"click .reset-button\" : \"resetHandler\"\n\n  bodyClassName: \"form-view-body\"\n\n  stateful:\n    dirty: false\n    currentModel: undefined\n\nformView.privateMethods\n  initialize: (@options={})->\n    form = @\n\n    @loadMask = Luca.config.enableBoostrap unless @loadMask?\n\n    Luca.Container::initialize.apply @, arguments\n\n    @components ||= @fields\n\n    _.bindAll @, \"submitHandler\", \"resetHandler\", \"renderToolbars\"\n\n    # have our events be internal to the view, and not\n    # part of the normal @events chain, so they can be inherited\n    for eventId, handler of @_events\n      @registerEvent(eventId, handler)\n\n    if @trackDirtyState is true\n      @on \"after:components\", ()->\n        for field in @getFields()\n          field.on \"on:change\", @onFieldChange, form\n      , form\n\n    @setupHooks( @hooks )\n\n    @applyStyleClasses()\n\n    Luca.components.FormView.setupToolbar.call(@)\n\n  onFieldChange: (field, e)->\n    @trigger \"field:change\", field, e\n    @state.set('dirty', true)\n\n  getDefaultToolbar: ()->\n    config = @toolbarConfig || @defaultToolbar\n    Luca.util.resolve( Luca.util.read(config) )\n\n  applyStyleClasses: ()->\n    if Luca.config.enableBoostrap\n      @applyBootstrapStyleClasses()\n\n    @$el.addClass( \"label-align-#{ @labelAlign }\") if @labelAlign\n    @$el.addClass( @fieldLayoutClass ) if @fieldLayoutClass\n\n  applyBootstrapStyleClasses: ()->\n    @inlineForm = true if @labelAlign is \"left\"\n\n    @$el.addClass('well') if @well\n    @$el.addClass('form-search') if @searchForm\n    @$el.addClass('form-horizontal') if @horizontalForm\n    @$el.addClass('form-inline') if @inlineForm\n\n  resetHandler: (e)->\n    me = my = $( e?.target )\n    if @beforeReset?\n      result = @beforeReset()\n      return if result is false\n\n    @reset()\n    @trigger \"after:reset\", @\n\n  submitHandler: (e)->\n    if @beforeSubmit?\n      result = @beforeSubmit()\n      return if result is false\n    else\n      @trigger \"before:submit\", @\n\n    @trigger \"enable:loadmask\", @ if @loadMask is true\n    @submit() if @hasModel()\n\n  afterComponents: ()->\n    Luca.Container::afterComponents?.apply(@, arguments)\n\n    form = @\n    @eachField (field)->\n      field.getForm = ()=> form\n      field.getModel = ()=> form.currentModel()\n\n  eachField: (iterator)->\n    _( @getFields() ).map( iterator )\n\n  getField: (name)->\n    passOne = _( @getFields('name', name) ).first()\n    return passOne if passOne?\n\n    _( @getFields('input_name', name) ).first()\n\n  getFields: (attr,value)->\n    fields = @selectByAttribute(\"isField\", true, true)\n\n    if attr? and value?\n      fields = _(fields).select (field)->\n        property  = field[ attr ]\n        property  = property.call(field) if _.isFunction(property)\n        property is value\n\n    fields\n\n  loadModel: (model)->\n    form = @\n    fields = @getFields()\n\n    @state.set('dirty', false)\n\n    @trigger \"before:load\", @, model\n\n    if model\n      model.beforeFormLoad?.apply(model, @)\n      event = \"before:load:#{ (if model.isNew() then \"new\" else \"existing\")}\"\n      @trigger event, @, model\n\n    @state.set('currentModel', model)\n\n    @setValues(model || {}, silent: true)\n\n    @trigger \"after:load\", @, model\n\n    if model\n      @trigger \"after:load:#{ (if model.isNew() then \"new\" else \"existing\")}\", @, model\n\n  reset: ()->\n    @loadModel( @state.get('currentModel') )\n\n  clear: ()->\n    @state.set('currentModel', @defaultModel?() )\n\n    _( @getFields() ).each (field)=>\n      try\n        field.setValue('')\n      catch e\n        console.log \"Error Clearing\", @, field\n\n  isDirty: ()->\n    !!@state.get('dirty')\n\n  # set the values on the form\n  # without syncing\n  setValues: (source, options={})->\n    source ||= @currentModel()\n    fields = @getFields()\n\n    _( fields ).each (field) =>\n      field_name = field.input_name || field.name\n\n      if source?[field_name]\n        value = Luca.util.read( source[field_name] )\n\n      if !value and Luca.isBackboneModel(source)\n        value = source.get(field_name)\n\n      field?.setValue( value ) unless field.readOnly is true\n\n    @applyFormValuesToModel() unless options.silent? is true\n\n  # Public: returns a hash of values for the form fields in this view.\n  #\n  # options - An options Hash to control the behavior of values returned (default: {}):\n  #           reject_blank: don't include values which are blank (default: true)\n  #           skip_buttons: don't include button fields (default: true)\n  #           blanks: an inverse alias for reject_blank (default: false)\n  getValues: (options={})->\n    options.reject_blank = true unless options.reject_blank?\n    options.skip_buttons = true unless options.skip_buttons?\n    options.reject_blank = true if options.blanks is false\n\n    values = _( @getFields() ).inject (memo,field)=>\n      value   = field.getValue()\n      key     = field.input_name || field.name\n\n      valueIsBlank      = !!(_.str.isBlank( value ) || _.isUndefined( value ))\n\n      allowBlankValues  = not options.reject_blank and not field.send_blanks\n      allowBlankValues = true if field.includeBlank is true or @includeBlankValues is true\n\n\n      if options.debug\n        console.log \"#{ key } Options\", options, \"Value\", value, \"Value Is Blank?\", valueIsBlank, \"Allow Blanks?\", allowBlankValues\n\n      if options.skip_buttons and field.isButton\n        skip = true\n      else\n        if valueIsBlank and allowBlankValues is false\n          skip = true\n\n        if field.input_name is \"id\" and valueIsBlank is true\n          skip = true\n\n      if options.debug\n        console.log \"Skip is true on #{ key }\"\n\n      if skip isnt true\n        memo[ key ] = value\n\n      memo\n\n    , (options.defaults || {})\n\n    values\n\n  removeErrors: ()->\n    @$('.alert.alert-error').remove()\n    @$el.removeClass('error')\n\n    for field in @getFields()\n      field.clearErrors()\n\n  displayErrors: (errors)->\n    has_errors = false\n    for field in @getFields()\n      for field_name, field_errors of errors when field_name is field.input_name\n        field.displayErrors(field_errors)\n        has_errors = true\n\n    if has_errors\n      @$el.addClass('error')\n\n  displayValidationErrorsMessage: ()->\n    @errorMessage('Please fix the fields with errors')\n\n  submit_success_handler: (model, response, xhr)->\n    @trigger \"after:submit\", @, model, response\n    @trigger \"disable:loadmask\", @ if @loadMask is true\n\n    if response and response?.success is true\n      @trigger \"after:submit:success\", @, model, response\n    else\n      @trigger \"after:submit:error\", @, model, response\n\n  submit_fatal_error_handler: (model, response, xhr)->\n    @trigger \"after:submit\", @, model, response\n    @trigger \"after:submit:fatal_error\", @, model, response\n\n    try\n      json = $.parseJSON(response.responseText)\n      if !json.success && json.errors?\n        @displayValidationErrorsMessage()\n        @displayErrors(json.errors)\n\n  submit: (save=true, saveOptions={})->\n    _.bindAll @, \"submit_success_handler\", \"submit_fatal_error_handler\"\n\n    saveOptions.success ||= @submit_success_handler\n    saveOptions.error ||= @submit_fatal_error_handler\n\n    @removeErrors()\n    @applyFormValuesToModel()\n    return unless save\n    @currentModel()?.save( @currentModel().toJSON(), saveOptions )\n\n  hasModel: ()->\n    @currentModel()?\n\n  currentModel: (options={})->\n    if options is true or options?.refresh is true\n      @applyFormValuesToModel()\n\n    @state.get('currentModel')\n\n  applyFormValuesToModel: (options)->\n    @currentModel()?.set( @getValues(), options )\n\n  setLegend: (@legend)->\n    $('fieldset legend', @el).first().html(@legend)\n\n  flash: (message)->\n    if @$('.toolbar-container.top').length > 0\n      @$('.toolbar-container.top').after(message)\n    else\n      @$bodyEl().prepend(message)\n\n  successFlashDelay: 1500\n\n  successMessage: (message)->\n    @$('.alert.alert-success').remove()\n    @flash Luca.template(\"components/form_alert\", className:\"alert alert-success\", message: message)\n    _.delay ()=>\n      @$('.alert.alert-success').fadeOut()\n    , @successFlashDelay || 0\n\n  errorMessage: (message)->\n    @$('.alert.alert-error').remove()\n    @flash Luca.template(\"components/form_alert\", className:\"alert alert-error\", message: message)\n\nformView.classInterface\n  setupToolbar: ()->\n    if @toolbar isnt false and (not @topToolbar and not @bottomToolbar)\n      if @toolbar is \"both\" or @toolbar is \"top\"\n        @topToolbar = _.clone( @getDefaultToolbar() )\n\n      unless @toolbar is \"top\"\n        @bottomToolbar = _.clone( @getDefaultToolbar() )\n\n  defaultToolbar:\n    buttons:[\n      icon:\"remove-sign\"\n      label: \"Reset\"\n      eventId: \"click:reset\"\n      className:\"reset-button\"\n      align: 'right'\n    ,\n      icon:\"ok-sign\"\n      white: true\n      label: \"Save Changes\"\n      eventId: \"click:submit\"\n      color: \"success\"\n      className: 'submit-button'\n      align: 'right'\n    ]\n\nformView.defines\n  version: 2\n\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/grid_layout_view.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/grid_layout_view.coffee","type":"component_definition","class_name":"Luca.components.GridLayoutView","header_documentation":"","type_alias":"grid_layout_view","css_class_identifier":"luca-grid-layout-view","defines_methods":{"attributesForItem":{"defined_on_line":19,"documentation":"<p>adds the bootstrap span class to each collection-item,\nwhere span class is equal to the 12 column grid / @itemsPerRow.\nfor example, each item would receive a span4 class when @itemsPerRow = 3</p>\n","arguments":[]},"renderModels":{"defined_on_line":29,"documentation":"<p>wraps every N number of rows, where N = @itemsPerRow\nin a row-fluid wrapper, and appends it to the view</p>\n","arguments":[{"argument":"models","value":null}]}},"defines_properties":{"itemsPerRow":{"defined_on_line":8,"documentation":"<p>how many items do you wish to render per row?\nassuming a 12 column grid, each item will receive\nan equal amount of grid span/columns.</p>\n","default":""},"className":{"defined_on_line":11,"documentation":"","default":""},"tagName":{"defined_on_line":12,"documentation":"","default":""},"itemTagName":{"defined_on_line":13,"documentation":"","default":""}},"source_file_contents":"gridView = Luca.register    \"Luca.components.GridLayoutView\"\ngridView.extends            \"Luca.CollectionView\"\n\ngridView.publicConfiguration\n  # how many items do you wish to render per row?\n  # assuming a 12 column grid, each item will receive\n  # an equal amount of grid span/columns.\n  itemsPerRow: 3\n\ngridView.privateConfiguration\n  className: \"grid-layout-view\"\n  tagName: \"div\"\n  itemTagName: \"div\"\n\ngridView.privateMethods\n  # adds the bootstrap span class to each collection-item,\n  # where span class is equal to the 12 column grid / @itemsPerRow.\n  # for example, each item would receive a span4 class when @itemsPerRow = 3\n  attributesForItem: ()->\n    base = Luca.CollectionView::attributesForItem.apply(@, arguments)\n    @itemsPerRow = 3 unless _.isNumber(@itemsPerRow) and @itemsPerRow > 1\n    columns = parseInt(12 / @itemsPerRow)\n    base.class += \" span#{ columns }\"\n\n    base\n\n  # wraps every N number of rows, where N = @itemsPerRow\n  # in a row-fluid wrapper, and appends it to the view\n  renderModels: (models)->\n    index = 0\n    rowIndex = 0\n\n    rows = for model in models\n      row = @make(\"div\", class:\"row-fluid\") if rowIndex++ is 0\n      $(row).append @makeItem(model,index++)\n      rowIndex = 0 if index > 0 and index % @itemsPerRow is 0\n      row\n\n    console.log \"Appending rows\", rows\n    for row in rows\n      @$append(row) \n\ngridView.register()\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/load_mask.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/load_mask.coffee","type":"component_definition","class_name":"Luca.components.LoadMask","header_documentation":"<p>#_.def(&quot;Luca.components.LoadMask&quot;).extends(&quot;Luca.View&quot;).with</p>\n","type_alias":"load_mask","css_class_identifier":"luca-load-mask","defines_methods":{},"defines_properties":{"className":{"defined_on_line":7,"documentation":"","default":""},"bodyTemplate":{"defined_on_line":8,"documentation":"","default":""}},"source_file_contents":"#_.def(\"Luca.components.LoadMask\").extends(\"Luca.View\").with\nloadMask = Luca.register  \"Luca.components.LoadMask\"\n\nloadMask.extends          \"Luca.View\"\n\nloadMask.defines\n  className: \"luca-ui-load-mask\"\n  bodyTemplate:\"components/load_mask\"\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/multi_collection_view.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/multi_collection_view.coffee","type":"component_definition","class_name":"Luca.components.MultiCollectionView","header_documentation":"","type_alias":"multi_collection_view","css_class_identifier":"luca-multi-collection-view","defines_methods":{"initialize":{"defined_on_line":42,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"relayAfterRefresh":{"defined_on_line":54,"documentation":"","arguments":[{"argument":"models","value":null},{"argument":"query","value":null},{"argument":"options","value":null}]},"refresh":{"defined_on_line":57,"documentation":"","arguments":[]},"propagateCollectionComponents":{"defined_on_line":61,"documentation":"","arguments":[]},"validateComponent":{"defined_on_line":81,"documentation":"","arguments":[{"argument":"component","value":null}]}},"defines_properties":{"version":{"defined_on_line":92,"documentation":"","default":""}},"source_file_contents":"multiView = Luca.register     \"Luca.components.MultiCollectionView\"\n\n# The CollectionMultiView is a collection view with multiple renderings\n# of the list.  ( e.g. Icons, Table, List ).  It works by maintaining\n# a current view, and rendering that view.  It refreshes the views\n# whenever they are activated. \n#\n# The MultiView allows you to share one collection, filter, pagination setup\n# but render multiple versions of a model.  To do this, you  are expected to\n# define one or more objects in the @views property of the component.\n\n# Example:\n#   multiView = new Luca.components.MultiCollectionView\n#     collection: \"my_collection\"\n#     paginatable:\n#       page: 1\n#       limit: 20\n#     views:[\n#       type:           \"table\"\n#       columns:[\n#         header: \"Header\"\n#         reader: \"attribute\"\n#       ]\n#     ]\nmultiView.extends           \"Luca.containers.CardView\"\n\nmultiView.mixesIn           \"QueryCollectionBindings\", \n                            \"LoadMaskable\",\n                            \"Filterable\",\n                            \"Paginatable\",\n                            \"Sortable\"\n\nmultiView.triggers          \"before:refresh\",\n                            \"after:refresh\",\n                            \"refresh\",\n                            \"empty:results\"\n\nmultiView.private\n  stateful:\n    activeView: 0\n\n  initialize: (@options={})->\n    @components ||= @views\n\n    for view in @components    \n      Luca.components.MultiCollectionView.validateComponent( view ) \n\n    Luca.containers.CardView::initialize.apply(@, arguments) \n\n    @on \"data:refresh\", @refresh, @\n    @on \"after:card:switch\", @refresh, @\n    @on \"after:components\", Luca.components.MultiCollectionView.propagateCollectionComponents, @\n\n  relayAfterRefresh: (models,query,options)->\n    @trigger \"after:refresh\", models, query, options\n\n  refresh: ()->\n    @activeComponent()?.refresh()\n\nmultiView.classMethods\n  propagateCollectionComponents: ()->\n    container = @\n\n    # in the multi view will share the same\n    # collection, filter state, pagination options, etc\n    for component in @components\n\n      component.on \"after:refresh\", (models,query,options)=> \n        @debug \"collection member after refresh\"\n        @trigger(\"after:refresh\",models,query,options)\n\n      _.extend component, \n        collection: container.getCollection() \n        getQuery: _.bind(container.getQuery, container)\n        getQueryOptions: _.bind(container.getQueryOptions, container)\n\n      if container.prepareQuery?\n        _.extend component,\n          prepareQuery: _.bind(container.prepareQuery, container)\n\n  validateComponent: (component)->\n    type = (component.type || component.ctype)\n\n    return if  type is \"collection\" or \n               type is \"collection_view\" or\n               type is \"table\" or\n               type is \"table_view\" \n\n    throw \"The MultiCollectionView expects to contain multiple collection views\" \n\nmultiView.defines\n  version: 3\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/nav_bar.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/nav_bar.coffee","type":"component_definition","class_name":"Luca.components.NavBar","header_documentation":"<p>A Twitter Bootstrap compatible navigation bar.  The Luca.Application\nand Luca.containers.Viewport class both have configuration options for\ncreating navbar components in the header and footer of the viewport.</p>\n\n<h4>Example of an Application with a Navbar</h4>\n\n<h5>Component Definition</h5>\n\n<pre><code>  # Navigation Component\n  navBar = Luca.register  &quot;App.views.TopNavigation&quot;\n  navBar.extends          &quot;Luca.components.NavBar&quot;\n  navBar.defines\n    brand: &quot;My App&quot;\n    # for white on black\n    inverse: true\n</code></pre>\n\n<p>We are able to reference the component we just defined in the\nconfiguration of the Application, simply by using it&#39;s \ntype alias <code>top_navigation</code>\n      # Application Component\n      app = Luca.register       &quot;App.Application&quot;\n      app.extends               &quot;Luca.Application&quot;\n      app.defines\n        topNav: &quot;top_navigation&quot;</p>\n","type_alias":"nav_bar","css_class_identifier":"luca-nav-bar","defines_methods":{"beforeRender":{"defined_on_line":54,"documentation":"","arguments":[]},"render":{"defined_on_line":70,"documentation":"","arguments":[]},"navContainer":{"defined_on_line":73,"documentation":"","arguments":[]},"content":{"defined_on_line":76,"documentation":"","arguments":[]}},"defines_properties":{"fixed":{"defined_on_line":31,"documentation":"<p>Specify whether the navbar is supposed to be fixed\nthe way Twitter bootstrap navbar can be.</p>\n","default":""},"position":{"defined_on_line":34,"documentation":"<p>Valid options are &#39;top&#39;, &#39;bottom&#39;.  Only valid when <code>@fixed is true</code></p>\n","default":""},"fluid":{"defined_on_line":38,"documentation":"<p>Specify whether the navbar should use the fluid grid.\nUsually the same as your Viewport setting.</p>\n","default":""},"brand":{"defined_on_line":42,"documentation":"<p>What content do you want to show in the logo area of the\nstandard bootstrap nav</p>\n","default":""},"template":{"defined_on_line":47,"documentation":"<p>Specifies an optional template to use for the navigation menu\ncontent.  Whatever you specify will be rendered inside of the\ncollapsible container inside of the standard bootstrap nav.</p>\n","default":""},"className":{"defined_on_line":50,"documentation":"","default":""},"bodyTemplate":{"defined_on_line":51,"documentation":"","default":""},"bodyClassName":{"defined_on_line":52,"documentation":"","default":""}},"source_file_contents":"# A Twitter Bootstrap compatible navigation bar.  The Luca.Application\n# and Luca.containers.Viewport class both have configuration options for\n# creating navbar components in the header and footer of the viewport.\n#\n# #### Example of an Application with a Navbar\n# ##### Component Definition\n#       # Navigation Component\n#       navBar = Luca.register  \"App.views.TopNavigation\"\n#       navBar.extends          \"Luca.components.NavBar\"\n#       navBar.defines\n#         brand: \"My App\"\n#         # for white on black\n#         inverse: true\n#\n# We are able to reference the component we just defined in the\n# configuration of the Application, simply by using it's \n# type alias `top_navigation`\n#\n#       # Application Component\n#       app = Luca.register       \"App.Application\"\n#       app.extends               \"Luca.Application\"\n#       app.defines\n#         topNav: \"top_navigation\"\n#\nnavBar = Luca.register \"Luca.components.NavBar\"\nnavBar.extends         \"Luca.View\"\n\nnavBar.publicConfiguration\n  # Specify whether the navbar is supposed to be fixed\n  # the way Twitter bootstrap navbar can be.\n  fixed: true\n\n  # Valid options are 'top', 'bottom'.  Only valid when `@fixed is true`\n  position: 'top'\n\n  # Specify whether the navbar should use the fluid grid. \n  # Usually the same as your Viewport setting.\n  fluid: undefined\n\n  # What content do you want to show in the logo area of the\n  # standard bootstrap nav\n  brand: \"Luca.js\"\n\n  # Specifies an optional template to use for the navigation menu\n  # content.  Whatever you specify will be rendered inside of the \n  # collapsible container inside of the standard bootstrap nav.\n  template: undefined\n\nnavBar.privateConfiguration\n  className: 'navbar'\n  bodyTemplate: 'nav_bar'\n  bodyClassName: 'luca-ui-navbar-body'\n\n  beforeRender: ()->\n    @$el.addClass \"navbar-fixed-#{ @position }\" if @fixed\n    @$el.addClass \"navbar-inverse\" if @inverse is true\n\n    if @brand?\n      @$('.brand').attr('href', @homeLink || '#')\n      @$('.brand').html(@brand)\n\n    if @template\n      @navContainer().html Luca.template(@template, @)\n\n    if !!(@fluid || Luca.getApplication()?.fluid)\n      @content().addClass( Luca.config.fluidWrapperClass )\n    else\n      @content().addClass( Luca.config.wrapperClass )\n\n  render: ()->\n    @\n\n  navContainer: ()->\n    @$('.luca-ui-navbar-body .nav-collapse')\n\n  content: ()->\n    @$('.luca-ui-navbar-body').eq(0)\n\n\nnavBar.register()"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/page.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/page.coffee","type":"component_definition","class_name":"Luca.components.Page","header_documentation":"<p>The <code>Page</code> is a type of <code>Container</code> that has\nall of its subcomponents visible at one time, \nand assigned to various <code>@regions</code> that exist\nin the <code>@layout</code> template which provide its \ninternal dom structure.</p>\n\n<h4>Example Template (haml):</h4>\n\n<pre><code>  .page.layout.row-fluid{&quot;data-layout&quot;=&gt;&quot;layouts/left_nav_grid&quot;}\n    .span3.region{&quot;data-region&quot;=&gt;&quot;left&quot;}\n    .span9.region{&quot;data-region&quot;=&gt;&quot;right&quot;}\n</code></pre>\n\n<h3>Example Page Configuration</h3>\n\n<pre><code>page = new Luca.components.Page\n  layout: &quot;layouts/left_nav_grid&quot;\n  regions:\n    left: \n      type: &quot;navigation&quot;\n    right:\n      type: &quot;details&quot;\n</code></pre>\n","type_alias":"page","css_class_identifier":"luca-page","defines_methods":{"initialize":{"defined_on_line":26,"documentation":"<p><code>Page</code>s are typically instantiated by a <code>Luca.components.Controller</code></p>\n","arguments":[{"argument":"@options","value":"{}"}]},"assignComponentsToRegions":{"defined_on_line":33,"documentation":"<p>Takes the configuration specified in @regions\nand creates a components hash out of them.</p>\n","arguments":[]}},"defines_properties":{"layout":{"defined_on_line":53,"documentation":"","default":""}},"source_file_contents":"# The `Page` is a type of `Container` that has\n# all of its subcomponents visible at one time, \n# and assigned to various `@regions` that exist\n# in the `@layout` template which provide its \n# internal dom structure.\n#\n# #### Example Template (haml):\n#       .page.layout.row-fluid{\"data-layout\"=>\"layouts/left_nav_grid\"}\n#         .span3.region{\"data-region\"=>\"left\"}\n#         .span9.region{\"data-region\"=>\"right\"}\n#\n# ### Example Page Configuration\n#     page = new Luca.components.Page\n#       layout: \"layouts/left_nav_grid\"\n#       regions:\n#         left: \n#           type: \"navigation\"\n#         right:\n#           type: \"details\"\n#\npage = Luca.register       \"Luca.components.Page\"\npage.extends               \"Luca.Container\"\n\npage.privateMethods\n  # `Page`s are typically instantiated by a `Luca.components.Controller`\n  initialize: (@options={})->\n    @assignComponentsToRegions()\n    @bodyTemplate = @options.layout || @layout\n    Luca.Container::initialize.apply(@, arguments)\n\n  # Takes the configuration specified in @regions\n  # and creates a components hash out of them.\n  assignComponentsToRegions: ()->\n    @components ||= []\n\n    assigned = for regionId, regionAssignment of @regions\n      if _.isString(regionAssignment) and componentClass = Luca.registry.lookup( regionAssignment )\n        regionAssignment = \n          component: regionAssignment\n      else if _.isString(regionAssignment) and Luca.template(regionAssignment)\n        regionAssignment = \n          bodyTemplate: regionAssignment\n\n      _.extend(regionAssignment, container: \"[data-region='#{ regionId }']\")\n\n    @components = assigned\n\npage.publicConfiguration\n  # The `@layout` property is the equivalent to specifying @bodyTemplate\n  # but more semantic.  A `@layout` template is expected to contain DOM \n  # elements with a data attribute named `region` on it.  \n\n  layout: undefined\n  # The @regions property assigns containers ( by their type alias )\n  # to DOM elements identified as regions within a layout template.\n  #\n  # #### Example:\n  #     new Luca.components.Page\n  #       regions: \n  #         left: \"my_component\"\n  #         right: \n  #           type: \"my_other_component\"\n  #           role: \"component_role\"\n  #\n  #   This will render an instance of MyComponent to this\n  #   page's @$('[data-region-id=\"right\"]') DOM element.\n  regions: {}\n\npage.register()\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/page_controller.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/page_controller.coffee","type":"component_definition","class_name":"Luca.PageController","header_documentation":"","type_alias":"page_controller","css_class_identifier":"luca-page-controller","defines_methods":{},"defines_properties":{},"source_file_contents":"pageController = Luca.register  \"Luca.PageController\"\npageController.extends          \"Luca.components.Controller\"\npageController.register()\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/pagination_control.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/pagination_control.coffee","type":"component_definition","class_name":"Luca.components.PaginationControl","header_documentation":"","type_alias":"pagination_control","css_class_identifier":"luca-pagination-control","defines_methods":{"onPageCountChange":{"defined_on_line":20,"documentation":"","arguments":[]},"limit":{"defined_on_line":23,"documentation":"","arguments":[]},"page":{"defined_on_line":26,"documentation":"","arguments":[]},"nextPage":{"defined_on_line":29,"documentation":"","arguments":[]},"previousPage":{"defined_on_line":33,"documentation":"","arguments":[]},"selectPage":{"defined_on_line":37,"documentation":"","arguments":[{"argument":"e","value":null}]},"setPage":{"defined_on_line":46,"documentation":"","arguments":[{"argument":"page","value":"1"},{"argument":"options","value":"{}"}]},"setLimit":{"defined_on_line":49,"documentation":"","arguments":[{"argument":"limit","value":"1"},{"argument":"options","value":"{}"}]},"pageButtonContainer":{"defined_on_line":52,"documentation":"","arguments":[]},"previousEnabled":{"defined_on_line":55,"documentation":"","arguments":[]},"nextEnabled":{"defined_on_line":58,"documentation":"","arguments":[]},"previousButton":{"defined_on_line":61,"documentation":"","arguments":[]},"nextButton":{"defined_on_line":64,"documentation":"","arguments":[]},"pageButtons":{"defined_on_line":67,"documentation":"","arguments":[]},"updateWithPageCount":{"defined_on_line":70,"documentation":"","arguments":[{"argument":"@pageCount","value":null},{"argument":"models","value":"[]"}]},"toggleNavigationButtons":{"defined_on_line":85,"documentation":"","arguments":[]},"selectActivePageButton":{"defined_on_line":90,"documentation":"","arguments":[]},"activePageButton":{"defined_on_line":93,"documentation":"","arguments":[]},"totalPages":{"defined_on_line":96,"documentation":"","arguments":[]},"totalItems":{"defined_on_line":99,"documentation":"","arguments":[]},"itemsPerPage":{"defined_on_line":102,"documentation":"","arguments":[{"argument":"value","value":null},{"argument":"options","value":"{}"}]}},"defines_properties":{"template":{"defined_on_line":6,"documentation":"","default":""},"stateful":{"defined_on_line":8,"documentation":"","default":""},"autoBindEventHandlers":{"defined_on_line":13,"documentation":"","default":""}},"source_file_contents":"paginationControl = Luca.register   \"Luca.components.PaginationControl\"\n\npaginationControl.extends           \"Luca.View\"\n\npaginationControl.defines\n  template: \"components/pagination\"\n\n  stateful: true\n\n  stateChangeEvents:\n    \"numberOfPages\" : \"onPageCountChange\"\n\n  autoBindEventHandlers: true\n\n  events:\n    \"click a[data-page-number]\" : \"selectPage\"\n    \"click a.next\"              : \"nextPage\"\n    \"click a.prev\"              : \"previousPage\"\n\n  onPageCountChange: ()->\n    @updateWithPageCount( @get('numberOfPages') )\n\n  limit: ()->\n    parseInt (@get('limit') || @collection?.length)\n\n  page: ()->\n    parseInt (@get('page') || 1)\n\n  nextPage: ()->\n    return unless @nextEnabled()\n    @set('page', @page() + 1 )\n\n  previousPage: ()->\n    return unless @previousEnabled()\n    @set('page', @page() - 1 )\n\n  selectPage: (e)->\n    me = my = @$( e.target )\n    me = my = my.closest('a.page') unless me.is('a.page')\n\n    my.siblings().removeClass('is-selected')\n    me.addClass('is-selected')\n\n    @setPage( my.data('page-number') )\n\n  setPage: (page=1,options={})->\n    @set('page', page, options)\n\n  setLimit: (limit=1,options={})->\n    @set('limit', limit, options)\n\n  pageButtonContainer: ()->\n    @$ '.group'\n\n  previousEnabled: ()->\n    @page() > 1\n\n  nextEnabled: ()->\n    @page() < @totalPages()\n\n  previousButton: ()->\n    @$ 'a.page.prev'\n\n  nextButton: ()->\n    @$ 'a.page.next'\n\n  pageButtons: ()->\n    @$ 'a[data-page-number]', @pageButtonContainer()\n\n  updateWithPageCount: (@pageCount, models=[])->\n    modelCount = models.length\n\n    @pageButtonContainer().empty()\n\n    _( @pageCount ).times (index)=>\n      page = index + 1\n      button = @make(\"a\",\"data-page-number\":page, class:\"page\", page )\n      @pageButtonContainer().append(button)\n\n    @toggleNavigationButtons()\n    @selectActivePageButton()\n\n    @\n\n  toggleNavigationButtons: ()->\n    @$('a.next, a.prev').addClass('disabled')\n    @nextButton().removeClass('disabled') if @nextEnabled()\n    @previousButton().removeClass('disabled') if @previousEnabled()\n\n  selectActivePageButton: ()->\n    @activePageButton().addClass('is-selected')\n\n  activePageButton: ()->\n    @pageButtons().filter(\"[data-page-number='#{ @page() }']\")\n\n  totalPages: ()->\n    @pageCount\n\n  totalItems: ()->\n    parseInt @collection?.length || 0\n\n  itemsPerPage: (value, options={})->\n    @set(\"limit\", value, options) if value?\n    parseInt @get(\"limit\")\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/router.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/router.coffee","type":"component_definition","class_name":"Luca.Router","header_documentation":"<p>#_.def(&quot;Luca.Router&quot;).extends(&quot;Backbone.Router&quot;).with</p>\n","type_alias":"router","css_class_identifier":"luca-router","defines_methods":{"initialize":{"defined_on_line":8,"documentation":"","arguments":[{"argument":"@options","value":null}]},"navigate":{"defined_on_line":26,"documentation":"<p>Intercept calls to Backbone.Router.navigate so that we can at least\nbuild a path from the route, even if we don&#39;t trigger the route handler</p>\n","arguments":[{"argument":"route","value":null},{"argument":"triggerRoute","value":"false"}]},"buildPathFrom":{"defined_on_line":34,"documentation":"<p>given a url fragment, construct an argument chain similar to what would be\nemitted from a normal route:#{ name } event that gets triggered\nwhen a route is actually fired.  This is used to trap route changes that happen\nthrough calls to @navigate()</p>\n","arguments":[{"argument":"matchedRoute","value":null}]}},"defines_properties":{},"source_file_contents":"#_.def(\"Luca.Router\").extends(\"Backbone.Router\").with\nrouter = Luca.register  \"Luca.Router\"\nrouter.extends          \"Backbone.Router\"\nrouter.defines\n  routes:\n    \"\" : \"default\"\n\n  initialize: (@options)->\n    _.extend @, @options\n\n    @routeHandlers = _( @routes ).values()\n\n    # when a route handler is fired, the route:route_name event is triggered by the router\n    # unfortunately this doesn't apply to calls to @navigate() so we override Backbone.Router.navigate\n    # and trigger an event separately.\n    _( @routeHandlers ).each (route_id) =>\n      @bind \"route:#{ route_id }\", ()=>\n        @trigger.apply @, [\"change:navigation\", route_id  ].concat( _( arguments ).flatten() )\n\n    Backbone.Router.initialize?.apply(@, arguments)\n\n  #### Router Functions\n\n  # Intercept calls to Backbone.Router.navigate so that we can at least\n  # build a path from the route, even if we don't trigger the route handler\n  navigate: (route, triggerRoute=false)->\n    Backbone.Router.prototype.navigate.apply @, arguments\n    @buildPathFrom( Backbone.history.getFragment() )\n\n  # given a url fragment, construct an argument chain similar to what would be\n  # emitted from a normal route:#{ name } event that gets triggered\n  # when a route is actually fired.  This is used to trap route changes that happen\n  # through calls to @navigate()\n  buildPathFrom: (matchedRoute)->\n    _(@routes).each (route_id, route)=>\n      regex = @_routeToRegExp(route)\n      if regex.test(matchedRoute)\n        args = @_extractParameters(regex, matchedRoute)\n        @trigger.apply @, [\"change:navigation\", route_id].concat( args )\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/simple_collection_view.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/simple_collection_view.coffee","type":"component_definition","class_name":"Luca.components.SimpleCollectionView","header_documentation":"<p>The SimpleCollectionView class is a CollectionView without any of the\nbells and whistles ( filtering, pagination, sorting, etc )</p>\n","type_alias":"simple_collection_view","css_class_identifier":"luca-simple-collection-view","defines_methods":{},"defines_properties":{"filterable":{"defined_on_line":7,"documentation":"","default":""},"paginatable":{"defined_on_line":8,"documentation":"","default":""},"sortable":{"defined_on_line":9,"documentation":"","default":""},"loadMask":{"defined_on_line":10,"documentation":"","default":""}},"source_file_contents":"# The SimpleCollectionView class is a CollectionView without any of the\n# bells and whistles ( filtering, pagination, sorting, etc )\nsimple = Luca.register    \"Luca.components.SimpleCollectionView\"\nsimple.extends            \"Luca.CollectionView\"\n\nsimple.defines\n  filterable: false\n  paginatable: false\n  sortable: false\n  loadMask: false"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/table_view.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/table_view.coffee","type":"component_definition","class_name":"Luca.components.TableView","header_documentation":"","type_alias":"table_view","css_class_identifier":"luca-table-view","defines_methods":{"lastColumn":{"defined_on_line":21,"documentation":"","arguments":[]},"eachColumn":{"defined_on_line":24,"documentation":"","arguments":[{"argument":"fn","value":null},{"argument":"scope","value":"@"}]},"itemRenderer":{"defined_on_line":29,"documentation":"","arguments":[{"argument":"item","value":null},{"argument":"model","value":null}]},"initialize":{"defined_on_line":32,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"rowRenderer":{"defined_on_line":80,"documentation":"","arguments":[{"argument":"item","value":null},{"argument":"model","value":null},{"argument":"index","value":null}]}},"defines_properties":{"emptyText":{"defined_on_line":7,"documentation":"","default":""},"additionalClassNames":{"defined_on_line":10,"documentation":"","default":""},"tagName":{"defined_on_line":11,"documentation":"","default":""},"bodyTemplate":{"defined_on_line":12,"documentation":"","default":""},"bodyTagName":{"defined_on_line":13,"documentation":"","default":""},"bodyClassName":{"defined_on_line":14,"documentation":"","default":""},"stateful":{"defined_on_line":15,"documentation":"","default":""},"itemTagName":{"defined_on_line":16,"documentation":"","default":""},"observeChanges":{"defined_on_line":17,"documentation":"","default":""}},"source_file_contents":"tableView = Luca.register     \"Luca.components.TableView\"\ntableView.extends             \"Luca.CollectionView\"\n\ntableView.publicConfiguration\n  widths: []\n  columns:[]\n  emptyText: \"There are no results to display\"\n\ntableView.privateConfiguration\n  additionalClassNames: \"table\"\n  tagName: \"table\"\n  bodyTemplate: \"table_view\"\n  bodyTagName: \"tbody\"\n  bodyClassName: \"table-body\"\n  stateful: true\n  itemTagName: \"tr\"\n  observeChanges: true\n\ntableView.privateMethods\n\n  lastColumn: ()->\n    @columns[ @columns.length - 1 ]\n\n  eachColumn: (fn, scope=@)->\n    index = 0\n    for col in @columns  \n      fn.call(scope, col, index++, @)\n\n  itemRenderer: (item, model)->\n    Luca.components.TableView.rowRenderer.call(@, item, model)\n\n  initialize: (@options={})->\n    Luca.components.CollectionView::initialize.apply(@, arguments)\n\n    index = 0\n    @columns = for column in @columns\n      if width = @widths[ index ]\n        column.width = width\n\n      if _.isString(column)\n        column = reader: column\n\n      if !column.header?\n        column.header = _.str.titleize(_.str.humanize(column.reader))\n\n      index++\n      column\n\n    @defer ()=> \n      Luca.components.TableView.renderHeader.call(@, @columns, @$('thead') )\n    .until(\"after:render\")\n\ntableView.classMethods\n  renderHeader : (columns, targetElement)->\n    index = 0\n\n    @$( targetElement ).append(\"<tr></tr>\")\n\n    for column in columns\n      attrs = \"data-col-index\": index++\n\n      if column.sortable\n        attrs.class = \"sortable-toggle\"\n        attrs[\"data-sortable-sort-by\"] = column.sortBy || column.sortable\n        attrs[\"data-sortable-order\"] = column.order\n\n      content = column.header \n      content = \"<a class='link'>#{ column.header }</a>\" if column.sortable\n\n      @$(targetElement).find('tr').append( Luca.View::make \"th\", attrs, content )\n\n\n    index = 0\n\n    for column in columns when column.width?\n      th = @$(\"th[data-col-index='#{ index++ }']\",targetElement)\n      th.css('width', column.width)\n\n\n  rowRenderer: (item, model, index)->\n    colIndex = 0\n    for columnConfig in @columns\n      Luca.components.TableView.renderColumn.call(@, columnConfig, item, model, colIndex++) \n\n  renderColumn : (column, item, model, index)->\n    cellValue = model.read( column.reader )\n\n    if _.isFunction( column.renderer )\n      cellValue = column.renderer.call @, cellValue, model, column \n\n    Luca.View::make(\"td\", {\"data-col-index\":index}, cellValue)\n\ntableView.register()"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/table_view_scrollable.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/components/table_view_scrollable.coffee","type":"component_definition","class_name":"Luca.components.ScrollableTable","header_documentation":"","type_alias":"scrollable_table","css_class_identifier":"luca-scrollable-table","defines_methods":{"$scrollableWrapperEl":{"defined_on_line":11,"documentation":"","arguments":[]},"setMaxHeight":{"defined_on_line":14,"documentation":"","arguments":[]},"afterRender":{"defined_on_line":18,"documentation":"","arguments":[]}},"defines_properties":{"maxHeight":{"defined_on_line":8,"documentation":"","default":""},"version":{"defined_on_line":23,"documentation":"","default":""}},"source_file_contents":"scrollable = Luca.register      'Luca.components.ScrollableTable'\n\nscrollable.extends              'Luca.components.TableView'\n\nscrollable.replaces             'Luca.components.GridView'\n\nscrollable.publicConfiguration\n  maxHeight: undefined\n\nscrollable.privateMethods\n  $scrollableWrapperEl: ()->\n    @$el.parent('.scrollable-wrapper')\n\n  setMaxHeight: ()->\n    parent = @$scrollableWrapperEl()\n    parent.css('overflow':'auto', 'max-height': @maxHeight)\n\n  afterRender: ()->\n    @$wrap 'scrollable-wrapper'\n    @setMaxHeight()\n\nscrollable.defines\n  version: 1"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/container.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/container.coffee","type":"component_definition","class_name":"Luca.Container","header_documentation":"<p>The Luca.Container is the heart and soul of the Luca framework \nand the component driven design philosophy.  The central idea\nis that every component should be designed as an isolated unit\nwhich completely encapsulates its features.  It should not know about\nother components outside of it.</p>\n\n<p>It is the responsibility of a <code>Luca.Container</code> to define its \nchild <code>@components</code>, render them, and broker communication between them\nin response to events which occur in the user interface.<br>\nA common use case for this would be a page which has a filter form, and\na grid of search results.  The fields in the filter form are used to \nfilter the table.  Neither the form or the table know about each other, \nsince both can be used in other contexts.  A <code>Luca.Container</code> would be used\nto relay events from the form to the table, and in doing so create a higher\nlevel component which can be extended and re-used. </p>\n\n<h4>Using a container to combine a Filter View and Results Table</h4>\n\n<pre><code>    form = Luca.register    &quot;App.views.FilterForm&quot;\n    form.extends            &quot;Luca.components.FormView&quot;\n    form.contains\n      type:   &quot;text&quot;\n      label:  &quot;Filter by&quot;\n      name:   &quot;filter_text&quot;\n    ,\n      type:   &quot;button&quot;\n      className: &quot;filter&quot;\n      value:  &quot;Filter&quot;          \n    form.defines\n      toolbar: false \n</code></pre>\n\n<p>Elsewhere, we have a table that lists records in a collection:</p>\n\n<pre><code>    table = Luca.register     &quot;App.views.ResultsTable&quot;\n    table.extends             &quot;Luca.components.TableView&quot;\n    table.defines \n      striped: true\n      collection: &quot;components&quot;\n      columns:[\n        header: &quot;Component Class&quot;\n        reader: &quot;class_name&quot;\n      ,\n        header: &quot;Component Type Alias&quot;\n        reader: &quot;type_alias&quot;\n      ]\n</code></pre>\n\n<p>We can join these two components together by declaring their relationship\nin a <code>Luca.Container</code>.  Remember the components we defined above are just\nprototypes.  We can override specific instance configuration and properties \nin our container.</p>\n\n<h4>Container Example</h4>\n\n<pre><code>    container = Luca.register     &quot;App.views.ComponentFinder&quot;\n    container.extends             &quot;Luca.Container&quot;\n\n  # This is the same as defining a components property on the component.\n  # The type alias is derived from the name of the component.  It is \n  # a short hand way of referencing a component you might reuse a lot.\n  container.contains\n    type: &quot;filter_form&quot;\n    role: &quot;filter&quot;\n  ,\n    type: &quot;results_table&quot;\n    # change the prototype&#39;s default \n    striped: false\n    role: &quot;results&quot;\n    filterable: true\n  # A Container will generally define some component event bindings\n  # and handler methods to handle the communication between its sub\n  # components.  By default a container is able to access events\n  # from all of its descendants in the hierarchy. \n  container.defines\n    # These will be applied to each of our components.\n    defaults:\n      attributes:\n        &quot;data-attribute&quot;: &quot;whatever&quot;\n    componentEvents:\n      # Any time any of our child components emit\n      # the on:change event, pass it to the filterTable method\n      &quot;* on:change&quot; : &quot;filterTable&quot;\n    # Communicates between the filter and the table&#39;s\n    # underlying collection.  NOtice the use of the @role\n    # property.  It automatically creates getter helpers for us.\n    filterTable: ()-&gt;\n      filter = @getFilter()\n      results = @getResults()\n      # filter.getValues() is a hash of each field and its value\n      results.applyFilter( filter.getValues() )\n</code></pre>\n\n<h3>DOM Layout Configuration</h3>\n\n<p>Another responsibility of the container is to structurally layout its\nchild components in the DOM.  There are a number of different \noptions available depending on how you need to do this.  By default,\na <code>Luca.Container</code> will simply append the @$el of all of its views\nto its own.\nThe <code>Luca.components.Controller</code> is a container which hides every page\nbut the active page.  Similarly, there is the <code>Luca.containers.TabView</code>\nwhich does the same thing, but renders a tab selector menu for you.  You\ncan create any type of interface you want using containers. \nTo make this easy for you, you can do a few different things:</p>\n\n<h4>Use the Twitter Bootstrap Fluid Grid</h4>\n\n<pre><code>    container = Luca.register &quot;App.views.ColumnLayout&quot; \n    container.extends         &quot;App.views.ComponentFinder&quot;\n    container.contains\n      span: 4\n      type: &quot;filter_form&quot;\n      role: &quot;filter&quot;\n    ,\n      span: 8\n      type: &quot;results_table&quot;\n      role: &quot;results&quot;\n    container.defines\n      rowFluid: true\n</code></pre>\n\n<h4>Using a layout template with CSS Selectors</h4>\n\n<pre><code>    ... \n    container.contains\n      role: &quot;filter&quot;\n      container: &quot;#filter-wrapper-dom-selector&quot;\n    ,\n      role: &quot;results&quot;\n      container: &quot;#results-wrapper-dom-selector&quot;\n    ...\n    container.defines\n      # assumes the template will provide the CSS selectors used above \n      bodyTemplate: &quot;layouts/custom_template&quot;\n</code></pre>\n","type_alias":"container","css_class_identifier":"luca-container","defines_methods":{"initialize":{"defined_on_line":183,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"remove":{"defined_on_line":202,"documentation":"","arguments":[]},"beforeRender":{"defined_on_line":207,"documentation":"","arguments":[]},"customizeContainerEl":{"defined_on_line":216,"documentation":"<p>Components which inherit from Luca.Container can implement\ntheir own versions of this method, if they need to apply any sort\nof additional styling / configuration for the DOM elements that\nare created to wrap each container.</p>\n","arguments":[{"argument":"containerEl","value":null},{"argument":"panel","value":null},{"argument":"panelIndex","value":null}]},"prepareLayout":{"defined_on_line":219,"documentation":"","arguments":[]},"prepareComponents":{"defined_on_line":242,"documentation":"","arguments":[]},"createComponents":{"defined_on_line":285,"documentation":"<p>create components is responsible for turning the JSON syntax of the\ncontainer&#39;s definition into live objects against a given Luca Component\ntype.</p>\n\n<p>In addition to this, a container builds an index of the components\nwhich belong to it, so that they can easily be looked up by name</p>\n","arguments":[]},"renderComponents":{"defined_on_line":349,"documentation":"<p>Trigger the Rendering Pipeline process on all of the nested\ncomponents</p>\n","arguments":[{"argument":"@debugMode","value":"\"\""}]},"firstActivation":{"defined_on_line":395,"documentation":"<h3>Container Activation</h3>\n\n<p>When a container is first activated is a good time to perform\noperations which are not needed unless that component becomes\nvisible.  This first activation event should be relayed to all\nof the nested components.  Components which hide / display\nother components, such as a CardView or TabContainer\nwill trigger first:activation on the components as they become\ndisplayed.</p>\n","arguments":[]},"_":{"defined_on_line":405,"documentation":"<h3>Underscore Methods For Working with Components</h3>\n","arguments":[{"argument":")-> _( @components","value":null}]},"pluck":{"defined_on_line":407,"documentation":"","arguments":[{"argument":"attribute","value":null}]},"invoke":{"defined_on_line":410,"documentation":"","arguments":[{"argument":"method","value":null}]},"select":{"defined_on_line":413,"documentation":"","arguments":[{"argument":"fn","value":null}]},"detect":{"defined_on_line":416,"documentation":"","arguments":[{"argument":"fn","value":null}]},"reject":{"defined_on_line":419,"documentation":"","arguments":[{"argument":"fn","value":null}]},"map":{"defined_on_line":422,"documentation":"","arguments":[{"argument":"fn","value":null}]},"registerComponentEvents":{"defined_on_line":425,"documentation":"","arguments":[{"argument":"eventList","value":null},{"argument":"direction","value":"\"on\""}]},"subContainers":{"defined_on_line":447,"documentation":"","arguments":[]},"roles":{"defined_on_line":451,"documentation":"","arguments":[]},"allChildren":{"defined_on_line":454,"documentation":"","arguments":[]},"findComponentForEventBinding":{"defined_on_line":462,"documentation":"","arguments":[{"argument":"nameRoleOrGetter","value":null},{"argument":"deep","value":"true"}]},"findComponentByGetter":{"defined_on_line":465,"documentation":"","arguments":[{"argument":"getter","value":null},{"argument":"deep","value":"false"}]},"findComponentByRole":{"defined_on_line":469,"documentation":"","arguments":[{"argument":"role","value":null},{"argument":"deep","value":"false"}]},"findComponentByType":{"defined_on_line":473,"documentation":"","arguments":[{"argument":"desired","value":null},{"argument":"deep","value":"false"}]},"findComponentByName":{"defined_on_line":477,"documentation":"","arguments":[{"argument":"name","value":null},{"argument":"deep","value":"false"}]},"findComponentById":{"defined_on_line":481,"documentation":"","arguments":[{"argument":"id","value":null},{"argument":"deep","value":"false"}]},"findComponent":{"defined_on_line":484,"documentation":"","arguments":[{"argument":"needle","value":null},{"argument":"haystack","value":"\"name\""},{"argument":"deep","value":"false"}]},"each":{"defined_on_line":498,"documentation":"","arguments":[{"argument":"fn","value":null}]},"eachComponent":{"defined_on_line":504,"documentation":"<p>run a function for each component in this container\nand any nested containers in those components, recursively\npass false as the second argument to skip the deep recursion</p>\n","arguments":[{"argument":"fn","value":null},{"argument":"deep","value":"true"}]},"indexOf":{"defined_on_line":509,"documentation":"","arguments":[{"argument":"name","value":null}]},"activeComponent":{"defined_on_line":513,"documentation":"","arguments":[]},"componentElements":{"defined_on_line":517,"documentation":"","arguments":[]},"getComponent":{"defined_on_line":520,"documentation":"","arguments":[{"argument":"needle","value":null}]},"isRootComponent":{"defined_on_line":523,"documentation":"","arguments":[]},"getRootComponent":{"defined_on_line":526,"documentation":"","arguments":[]},"selectByAttribute":{"defined_on_line":530,"documentation":"","arguments":[{"argument":"attribute","value":null},{"argument":"value","value":"undefined"},{"argument":"deep","value":"false"}]},"at":{"defined_on_line":624,"documentation":"","arguments":[{"argument":"index","value":null}]}},"defines_properties":{"emptyContainerElements":{"defined_on_line":159,"documentation":"","default":""},"className":{"defined_on_line":160,"documentation":"","default":""},"componentTag":{"defined_on_line":161,"documentation":"","default":""},"componentClass":{"defined_on_line":162,"documentation":"","default":""},"isContainer":{"defined_on_line":163,"documentation":"","default":""},"rendered":{"defined_on_line":164,"documentation":"","default":""},"@trigger \"before":{"defined_on_line":558,"documentation":"","default":""},"@trigger \"after":{"defined_on_line":560,"documentation":"","default":""},"style_declarations.push \"height":{"defined_on_line":565,"documentation":"","default":""},"style_declarations.push \"width":{"defined_on_line":566,"documentation":"","default":""},"style_declarations.push \"float":{"defined_on_line":567,"documentation":"","default":""}},"source_file_contents":"# The Luca.Container is the heart and soul of the Luca framework \n# and the component driven design philosophy.  The central idea\n# is that every component should be designed as an isolated unit\n# which completely encapsulates its features.  It should not know about\n# other components outside of it.\n# \n# It is the responsibility of a `Luca.Container` to define its \n# child `@components`, render them, and broker communication between them\n# in response to events which occur in the user interface.  \n#\n# A common use case for this would be a page which has a filter form, and\n# a grid of search results.  The fields in the filter form are used to \n# filter the table.  Neither the form or the table know about each other, \n# since both can be used in other contexts.  A `Luca.Container` would be used\n# to relay events from the form to the table, and in doing so create a higher\n# level component which can be extended and re-used. \n#\n# #### Using a container to combine a Filter View and Results Table \n#\n#         form = Luca.register    \"App.views.FilterForm\"\n#         form.extends            \"Luca.components.FormView\"\n#\n#         form.contains\n#           type:   \"text\"\n#           label:  \"Filter by\"\n#           name:   \"filter_text\"\n#         ,\n#           type:   \"button\"\n#           className: \"filter\"\n#           value:  \"Filter\"          \n#\n#\n#         form.defines\n#           toolbar: false \n# \n# Elsewhere, we have a table that lists records in a collection:\n#         \n#         table = Luca.register     \"App.views.ResultsTable\"\n#         table.extends             \"Luca.components.TableView\"\n#         table.defines \n#           striped: true\n#           collection: \"components\"\n#           columns:[\n#             header: \"Component Class\"\n#             reader: \"class_name\"\n#           ,\n#             header: \"Component Type Alias\"\n#             reader: \"type_alias\"\n#           ]\n#\n# We can join these two components together by declaring their relationship\n# in a `Luca.Container`.  Remember the components we defined above are just\n# prototypes.  We can override specific instance configuration and properties \n# in our container.\n#\n# #### Container Example\n#\n#         container = Luca.register     \"App.views.ComponentFinder\"\n#         container.extends             \"Luca.Container\"\n#       \n#       # This is the same as defining a components property on the component.\n#       # The type alias is derived from the name of the component.  It is \n#       # a short hand way of referencing a component you might reuse a lot.\n#       container.contains\n#         type: \"filter_form\"\n#         role: \"filter\"\n#       ,\n#         type: \"results_table\"\n#         # change the prototype's default \n#         striped: false\n#         role: \"results\"\n#         filterable: true\n#\n#       # A Container will generally define some component event bindings\n#       # and handler methods to handle the communication between its sub\n#       # components.  By default a container is able to access events\n#       # from all of its descendants in the hierarchy. \n#       container.defines\n#         # These will be applied to each of our components.\n#         defaults:\n#           attributes:\n#             \"data-attribute\": \"whatever\"\n#\n#         componentEvents:\n#           # Any time any of our child components emit\n#           # the on:change event, pass it to the filterTable method\n#           \"* on:change\" : \"filterTable\"\n#\n#         # Communicates between the filter and the table's\n#         # underlying collection.  NOtice the use of the @role\n#         # property.  It automatically creates getter helpers for us.\n#         filterTable: ()->\n#           filter = @getFilter()\n#           results = @getResults()\n#           # filter.getValues() is a hash of each field and its value\n#           results.applyFilter( filter.getValues() )\n#         \n# ### DOM Layout Configuration\n#\n# Another responsibility of the container is to structurally layout its\n# child components in the DOM.  There are a number of different \n# options available depending on how you need to do this.  By default,\n# a `Luca.Container` will simply append the @$el of all of its views\n# to its own.\n#\n# The `Luca.components.Controller` is a container which hides every page\n# but the active page.  Similarly, there is the `Luca.containers.TabView`\n# which does the same thing, but renders a tab selector menu for you.  You\n# can create any type of interface you want using containers. \n#\n# To make this easy for you, you can do a few different things:\n#\n# #### Use the Twitter Bootstrap Fluid Grid\n#\n#         container = Luca.register \"App.views.ColumnLayout\" \n#         container.extends         \"App.views.ComponentFinder\"\n#\n#         container.contains\n#           span: 4\n#           type: \"filter_form\"\n#           role: \"filter\"\n#         ,\n#           span: 8\n#           type: \"results_table\"\n#           role: \"results\"\n#\n#         container.defines\n#           rowFluid: true\n#\n# #### Using a layout template with CSS Selectors\n#         ... \n#         container.contains\n#           role: \"filter\"\n#           container: \"#filter-wrapper-dom-selector\"\n#         ,\n#           role: \"results\"\n#           container: \"#results-wrapper-dom-selector\"\n#         ...\n#         container.defines\n#           # assumes the template will provide the CSS selectors used above \n#           bodyTemplate: \"layouts/custom_template\"\ncontainer = Luca.register         \"Luca.Container\"\n\ncontainer.extends                 \"Luca.Panel\"\n\ncontainer.triggers                \"before:components\",\n                                  \"before:render:components\",\n                                  \"before:layout\",\n                                  \"after:components\",\n                                  \"after:layout\",\n                                  \"first:activation\"\n\ncontainer.replaces                \"Luca.Container\"\n\ncontainer.publicConfiguration\n  components:[]\n\ncontainer.privateConfiguration\n  emptyContainerElements: false\n  className: 'luca-ui-container'\n  componentTag: 'div'\n  componentClass: 'luca-ui-panel'\n  isContainer: true\n  rendered: false\n\n  # @componentEvents provides declarative syntax for responding to events on\n  # the components in this container.  the format of the syntax is very similar\n  # to the other event binding helpers:\n  #\n  #   component_accessor component:trigger\n  #\n  # where component_accessor is either the name of the role, or a method on the container\n  # which will find the component in question.\n  #\n  # myContainer = new Luca.Container\n  #   componentEvents:\n  #     \"name component:trigger\"    : \"handler\"\n  #     \"role component:trigger\"    : \"handler\"\n  #     \"getter component:trigger\"  : \"handler\"\n  #\n  componentEvents: {}\n\n  initialize: (@options={})->\n    _.extend @, @options\n\n    # aliases for the components property\n    @components ||= @fields ||= @pages ||= @cards ||= @views\n    \n    # accept components as an array of strings representing\n    # the luca component type\n    for component in @components when _.isString(component)\n      component = (type: component, role: component, name: component)\n\n    _.bindAll(@, \"beforeRender\")\n\n    @setupHooks( Luca.Container::hooks )\n\n    validateContainerConfiguration(@)\n\n    Luca.View::initialize.apply @, arguments\n\n  remove: ()->\n    Luca.View::remove.apply(@, arguments)\n    @eachComponent (component)->\n      component.remove?()\n      \n  beforeRender: ()->\n    doLayout.call(@)\n    doComponents.call(@)\n    Luca.Panel::beforeRender?.apply(@, arguments)\n\n  # Components which inherit from Luca.Container can implement\n  # their own versions of this method, if they need to apply any sort\n  # of additional styling / configuration for the DOM elements that\n  # are created to wrap each container.\n  customizeContainerEl: (containerEl, panel, panelIndex)->\n    containerEl\n\n  prepareLayout: ()->\n    container = @\n    @componentContainers = _( @components ).map (component, index)->\n      applyDOMConfig.call(container, component, index)\n\n    componentsWithClassBasedAssignment = @_().select (component)->\n      _.isString(component.container) and component.container?.match(/^\\./) and container.$( component.container ).length > 0\n\n    # TEMP / HACK / Workaround\n    #\n    # Containers with components assigned to .class-based-containers\n    # seem to get double rendered in the renderComponents() method.\n    #\n    # So here I am uniquely identifying the containers in a way that is not possible\n    # in the templates ( since we want to be able to inherit templates and component assignments )\n    if componentsWithClassBasedAssignment.length > 0\n      for specialComponent in componentsWithClassBasedAssignment\n        containerAssignment = _.uniqueId('container')\n        targetEl = container.$( specialComponent.container )\n        if targetEl.length > 0\n          $(targetEl).attr('data-container-assignment', containerAssignment)\n          specialComponent.container += \"[data-container-assignment='#{ containerAssignment }']\"\n\n  prepareComponents: ()->\n    container = @\n\n    _( @components ).each (component, index)=>\n      ce = componentContainerElement = @componentContainers?[index]\n\n      # support a variety of the bad naming conventions\n      ce.class = ce.class || ce.className || ce.classes\n\n      if @generateComponentElements\n        panel = @make(@componentTag, componentContainerElement, '')\n        @$append( panel )\n\n      # if the container defines a @defaults property\n      # then we should make sure our child components inherit\n      # these values unless specifically defined\n      if container.defaults?\n        component = _.defaults(component, (container.defaults || {}))\n\n      # if the container defines an @extensions property as an array of\n      # configuration objects, then we will extend the component config with\n      # the object in the matching position of the @extensions array.\n      if _.isArray(container.extensions) and _.isObject(container.extensions?[ index ])\n        componentExtension = container.extensions[index]\n        component = _.extend(component, componentExtension)\n\n      # if the container defines an @extensions property as an object of nested hashes,\n      # then extensions is a key/value pair whose key represents the role of the component\n      # that we wish to extend / customize \n      if component.role? and _.isObject(container.extensions) and _.isObject(container.extensions[component.role])\n        componentExtension = container.extensions[component.role]\n        component = _.extend(component, componentExtension)\n        \n      unless component.container?\n        component.container = \"##{ componentContainerElement.id }\" if @generateComponentElements\n        component.container ||= @$bodyEl()\n\n  # create components is responsible for turning the JSON syntax of the\n  # container's definition into live objects against a given Luca Component\n  # type.\n  #\n  # In addition to this, a container builds an index of the components\n  # which belong to it, so that they can easily be looked up by name\n  createComponents: ()->\n    return if @componentsCreated is true\n\n    map = @componentIndex =\n      name_index: {}\n      cid_index: {}\n      role_index: {}\n\n    container   = @\n\n    @components = _( @components ).map (object, index)=>\n\n      # you can include normal backbone views as components\n      # you will want to make sure your render method handles\n      # adding the views @$el to the appropriate @container.\n\n      # you can also just pass a string representing the component_type\n      component = if Luca.isComponent( object )\n        object\n      else\n        # if a component is tagged with a @component property\n        # we assume this is the kind of singleton component\n        # and set the type, role and name to the same value (if they're blank)\n        if object.component? and not (object.type || object.ctype)\n          object.type = object.component\n          object.name ||= object.component\n          object.role ||= object.component\n\n        object.type ||= object.ctype\n\n        # guess the type based on the properties\n        if !object.type?\n          # TODO\n          # Add support for all of the various components property aliases\n          if object.components?\n            object.type = object.ctype = 'container'\n          else\n            object.type = object.ctype = Luca.defaultComponentType\n\n        object._parentCid ||= container.cid\n        created = Luca.util.lazyComponent( object )\n\n      # if we're using base backbone views, then they don't extend themselves\n      # with their passed options, so this is a workaround to get them to\n      # pick up the container config property\n      if !component.container and component.options?.container\n        component.container = component.options.container\n\n      component.getParent ||= ()-> Luca( component._parentCid )\n\n      if not component.container?\n        console.log component,index,@\n        console.error \"could not assign container property to component on container #{ @name || @cid }\"\n\n      indexComponent( component ).at(index).in( @componentIndex )\n\n      component\n\n    @componentsCreated = true\n\n    map\n\n  # Trigger the Rendering Pipeline process on all of the nested\n  # components\n  renderComponents: (@debugMode=\"\")->\n    @debug \"container render components\"\n\n    container = @\n\n    _(@components).each (component)->\n      try\n        component.trigger \"before:attach\"\n\n        containerElement = container.$(component.container)\n\n        if containerElement.length is 0\n          if _.isString( component.container )\n            # the container trying to assign this component to is not in the dom\n            1\n\n          # try in the window context.  this is almost always certainly a bug\n          # so look into wtf is going on and which components are problematic\n          containerElement = @$( component.container ).eq(0) if containerElement.length is 0\n\n        if @emptyContainerElements is true\n          containerElement.empty()\n\n        containerElement.append( component.el )\n\n        component.trigger \"after:attach\"\n        component.render()\n        component.rendered = true\n      catch e\n        console.log \"Error Rendering Component #{ component.name || component.cid }\", component\n\n        if _.isObject(e)\n          console.log e.message\n          console.log e.stack\n\n        throw e unless Luca.silenceRenderErrors? is true\n\n  #### Container Activation\n  #\n  # When a container is first activated is a good time to perform\n  # operations which are not needed unless that component becomes\n  # visible.  This first activation event should be relayed to all\n  # of the nested components.  Components which hide / display\n  # other components, such as a CardView or TabContainer\n  # will trigger first:activation on the components as they become\n  # displayed.\n  firstActivation: ()->\n    activator = @\n    @each (component, index)->\n      # apply the first:activation trigger on the component, in the context of the component\n      # passing as arguments the component itself, and the component doing the activation\n      unless component?.previously_activated is true\n        component?.trigger?.call component, \"first:activation\", component, activator\n        component.previously_activated = true\n\n  #### Underscore Methods For Working with Components\n  _: ()-> _( @components )\n\n  pluck: (attribute)->\n    @_().pluck(attribute)\n\n  invoke: (method)->\n    @_().invoke(method)\n\n  select: (fn)->\n    @_().select(fn)\n\n  detect: (fn)->\n    @_().detect(attribute)\n\n  reject: (fn)->\n    @_().reject(fn)\n\n  map: (fn)->\n    @_().map(fn)\n\n  registerComponentEvents: (eventList, direction=\"on\")->\n    container = @\n\n    for listener, handler of (eventList || @componentEvents||{})\n      [componentNameOrRole,eventId] = listener.split(' ')\n\n      unless _.isFunction( @[handler] )\n        console.log \"Error registering component event\", listener, componentNameOrRole, eventId\n        throw \"Invalid component event definition #{ listener }. Specified handler is not a method on the container\"\n\n      if componentNameOrRole is \"*\"\n        @eachComponent (component)=> component.on(eventId, @[handler], container)\n      else\n        component = @findComponentForEventBinding( componentNameOrRole )\n\n        unless component? and Luca.isComponent(component)\n          console.log \"Error registering component event\", listener, componentNameOrRole, eventId\n          throw \"Invalid component event definition: #{ componentNameOrRole }\"\n\n        component[direction](eventId, @[handler], container)\n\n\n  subContainers: ()->\n    @select (component)->\n      component.isContainer is true\n\n  roles: ()->\n    _( @allChildren() ).pluck('role')\n\n  allChildren: ()->\n    children = @components\n\n    grandchildren = _( @subContainers() ).map (component)->\n      component?.allChildren?()\n\n    _([children,grandchildren]).chain().compact().flatten().value()\n\n  findComponentForEventBinding: (nameRoleOrGetter, deep=true)->\n    @findComponentByName(nameRoleOrGetter, deep) || @findComponentByGetter( nameRoleOrGetter, deep ) || @findComponentByRole( nameRoleOrGetter, deep )\n\n  findComponentByGetter: (getter, deep=false)->\n    _( @allChildren() ).detect (component)->\n      component?.getter is getter\n\n  findComponentByRole: (role,deep=false)->\n    _( @allChildren() ).detect (component)->\n      component?.role is role or component?.type is role or component?.ctype is role\n\n  findComponentByType: (desired,deep=false)->\n    _( @allChildren() ).detect (component)->\n      desired is (component.type || component.ctype)\n\n  findComponentByName: (name, deep=false)->\n    _( @allChildren() ).detect (component)->\n      component.name is name\n\n  findComponentById: (id, deep=false)->\n    @findComponent(id, \"cid_index\", deep)\n\n  findComponent: (needle, haystack=\"name\", deep=false)->\n    @createComponents() unless @componentsCreated is true\n\n    position = @componentIndex?[ haystack ][ needle ]\n    component = @components[ position ]\n\n    return component if component\n\n    if deep is true\n      sub_container = _( @components ).detect (component)->\n        component?.findComponent?(needle, haystack, true)\n\n      sub_container?.findComponent?(needle, haystack, true)\n\n  each: (fn)->\n    @eachComponent(fn, false)\n\n  # run a function for each component in this container\n  # and any nested containers in those components, recursively\n  # pass false as the second argument to skip the deep recursion\n  eachComponent: (fn, deep=true)->\n    _( @components ).each (component, index)=>\n      fn.call component, component, index\n      component?.eachComponent?.apply component, [fn,deep] if deep\n\n  indexOf: (name)->\n    names = _( @components ).pluck('name')\n    _( names ).indexOf(name)\n\n  activeComponent: ()->\n    return @ unless @activeItem\n    return @components[ @activeItem ]\n\n  componentElements: ()->\n    @$(\"[data-luca-parent='#{ @name || @cid }']\")\n\n  getComponent: (needle)->\n    @components[ needle ]\n\n  isRootComponent:()->\n    @rootComponent is true || !@getParent?\n\n  getRootComponent: ()->\n    if @isRootComponent() then @ else @getParent().getRootComponent()\n\n\n  selectByAttribute: (attribute, value=undefined, deep=false)->\n    components = _( @components ).map (component)->\n      matches = []\n      test = component[ attribute ]\n\n      matches.push( component ) if test is value or (not value? and test?)\n\n      # recursively traverse our components\n      matches.push component.selectByAttribute?(attribute, value, true) if deep is true\n\n      _.compact matches\n\n    _.flatten( components )\n\n\ncontainer.register()\n\n# This is the method by which a container injects the rendered child views\n# into the DOM.  It will get passed the container object, and the component\n# that is being rendered.\nLuca.Container.componentRenderer = (container, component)->\n  attachMethod = $( component.container )[ component.attachWith || \"append\" ]\n  attachMethod( component.render().el )\n\n\n#### Private Helpers\n\ndoLayout = ()->\n  @trigger \"before:layout\", @\n  @prepareLayout()\n  @trigger \"after:layout\", @\n\napplyDOMConfig = (panel, panelIndex)->\n  style_declarations = []\n\n  style_declarations.push \"height: #{ (if _.isNumber(panel.height) then panel.height + 'px' else panel.height ) }\" if panel.height?\n  style_declarations.push \"width: #{ (if _.isNumber(panel.width) then panel.width + 'px' else panel.width ) }\" if panel.width?\n  style_declarations.push \"float: #{ panel.float }\" if panel.float\n\n  config =\n    class: panel?.classes || @componentClass\n    id: \"#{ @cid }-#{ panelIndex }\"\n    style: style_declarations.join(';')\n    \"data-luca-parent\" : @name || @cid\n\n  if @customizeContainerEl?\n   config = @customizeContainerEl( config, panel, panelIndex )\n\n  config\n\n\n\ncreateGetterMethods = ()->\n  container = @\n\n  childrenWithGetter = _( @allChildren() ).select (component)->\n    component?.getter?\n\n  _( childrenWithGetter ).each (component)->\n    container[ component.getter ] ||= ()-> component\n\ncreateMethodsToGetComponentsByRole = ()->\n  container = @\n\n  childrenWithRole = _( @allChildren() ).select (component)->\n    component?.role?\n\n  _( childrenWithRole ).each (component)->\n    getter = _.str.camelize( \"get_\" + component.role )\n    getterFn = ()-> component\n    container[ getter ] ||= _.bind(getterFn, container) \n\ndoComponents = ()->\n  @trigger \"before:components\", @, @components\n  @prepareComponents()\n  @trigger \"before:create:components\", @, @components\n  @createComponents()\n  @trigger \"before:render:components\", @, @components\n  @renderComponents()\n  @trigger \"after:components\", @, @components\n\n  unless @skipGetterMethods is true\n    createGetterMethods.call(@)\n    createMethodsToGetComponentsByRole.call(@)\n\n  @registerComponentEvents()\n\nvalidateContainerConfiguration = ()->\n  true\n\n# Private Helpers\n#\n# indexComponent( component ).at( index ).in( componentsInternalIndexMap )\nindexComponent = (component)->\n  at: (index)->\n    in: (map)->\n      if component.cid?\n        map.cid_index[ component.cid ] = index\n      if component.role?\n        map.role_index[ component.role ] = index\n      if component.name?\n        map.name_index[ component.name ] = index\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/panel_toolbar.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/panel_toolbar.coffee","type":"component_definition","class_name":"Luca.PanelToolbar","header_documentation":"<p>The Panel Toolbar is a collection of buttons and / or dropdowns</p>\n","type_alias":"panel_toolbar","css_class_identifier":"luca-panel-toolbar","defines_methods":{"initialize":{"defined_on_line":29,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"clickHandler":{"defined_on_line":43,"documentation":"<p>The Toolbar behaves by triggering events on the components which they\nbelong to. Combined with Luca.View::setupHooks it is a clean way\nto organize actions</p>\n","arguments":[{"argument":"e","value":null}]},"beforeRender":{"defined_on_line":61,"documentation":"","arguments":[]},"render":{"defined_on_line":72,"documentation":"","arguments":[]}},"defines_properties":{"orientation":{"defined_on_line":22,"documentation":"","default":""},"autoBindEventHandlers":{"defined_on_line":24,"documentation":"","default":""}},"source_file_contents":"panelToolbar = Luca.register        \"Luca.PanelToolbar\"\n# The Panel Toolbar is a collection of buttons and / or dropdowns\n# which are automatically created by BasicPanel classes, or can be\n# added to any other view component.\npanelToolbar.extends                \"Luca.View\"\n\n\npanelToolbar.defines\n  # @buttons is an array of button config objects\n  # button config accepts the following paramters:\n  #\n  # label       what should the button say\n  # eventId     what event should the button trigger\n  # dropdown    an array of arrays: [eventId, label]\n  # group       an array of button configs\n  # wrapper     a css class, in addition to btn-group\n  # icon        which icon do you want to use on this button?\n  # white       true or false: is it a white colored text?\n  # color       options are primary, info, success, warning, danger, inverse\n  buttons:[]\n\n  orientation: 'top'\n\n  autoBindEventHandlers: true\n\n  events:\n    \"click a.btn, click .dropdown-menu li\" : \"clickHandler\"\n\n  initialize: (@options={})->\n    @_super(\"initialize\", @, arguments)\n\n    # if the toolbar consists of a single button group\n    # don't make the developer specify buttons = {buttons:[group:true, buttons:[...]]}\n    if @group is true and @buttons?.length >= 0\n      @buttons = [\n        group: true\n        buttons: @buttons\n      ]\n\n  # The Toolbar behaves by triggering events on the components which they\n  # belong to. Combined with Luca.View::setupHooks it is a clean way\n  # to organize actions\n  clickHandler: (e)->\n    me = my = $( e.target )\n    me = my = $( e.target ).parent() if me.is('i')\n\n    if @selectable is true\n      my.siblings().removeClass(\"is-selected\")\n      me.addClass('is-selected')\n\n    return unless eventId = my.data('eventid')\n\n    hook = Luca.util.hook( eventId )\n\n    source = @parent || @\n    if _.isFunction( source[hook] )\n      source[ hook ].call(@, me, e)\n    else\n      source.trigger(eventId, me, e)\n\n  beforeRender:()->\n    @_super(\"beforeRender\", @, arguments)\n\n    if @well is true\n      @$el.addClass 'well'\n\n    @$el.addClass 'btn-selectable' if @selectable is true\n    @$el.addClass \"toolbar-#{ @orientation }\"\n    @$el.addClass \"pull-right\" if @align is \"right\"\n    @$el.addClass \"pull-left\" if @align is \"left\"\n\n  render: ()->\n    @$el.empty()\n    @$el.append( element ) for element in prepareButtons(@buttons)\n    @\n\n\nmake = Luca.View::make\n\nbuildButton = (config, wrap=true)->\n  if config.ctype? or config.type?\n    config.className ||= \"\"\n    config.className += 'toolbar-component'\n\n    object = Luca(config).render()\n\n    if Luca.isBackboneView(object)\n      return object.$el\n\n  if config.spacer\n    return make \"div\", class: \"spacer #{ config.spacer }\"\n\n  if config.text\n    return make \"div\", {class: \"toolbar-text\"}, config.text\n\n  wrapper = 'btn-group'\n  wrapper += \"#{ config.wrapper }\" if config.wrapper?\n  wrapper += \"pull-#{ config.align } align-#{ config.align }\" if config.align?\n  wrapper += 'btn-selectable' if config.selectable is true\n\n  # if we're passed a group, then we need to just\n  # wrap the contents of the buttons property in that group\n  # skipping the btn-group wrapping that takes place for\n  # individual buttons\n  if config.group? and config.buttons?\n    buttons = prepareButtons( config.buttons, false )\n    return make \"div\", class: wrapper, buttons\n\n  # if it is a normal button, and not a button group\n  else\n    label = config.label ||= \"\"\n\n    config.eventId ||= _.string.dasherize( config.label.toLowerCase() )\n\n    if config.icon\n      label = \" \" if _.string.isBlank( label )\n      white = \"icon-white\" if config.white\n      label = \"<i class='#{ white || \"\" } icon-#{ config.icon }' /> #{ label }\"\n\n    buttonAttributes =\n      class: _.compact([\"btn\",config.classes,config.className]).join(\" \")\n      \"data-eventId\" : config.eventId\n      title: config.title || config.description\n\n    buttonAttributes[\"class\"] += \" btn-#{ config.color }\" if config.color?\n    buttonAttributes[\"class\"] += \" is-selected\" if config.selected?\n\n    if config.dropdown\n      label = \"#{ label } <span class='caret'></span>\"\n      buttonAttributes[\"class\"] += \" dropdown-toggle\"\n      buttonAttributes[\"data-toggle\"] = \"dropdown\"\n\n      dropdownItems = for dropdownItem in config.dropdown\n        if _.isObject(dropdownItem)\n          dropdownItem = _.values(dropdownItem).reverse()\n\n        link = make \"a\", {}, dropdownItem[1]\n        make \"li\", {\"data-eventId\": dropdownItem[0]}, link\n\n      dropdownEl = make \"ul\", {class:\"dropdown-menu\"}, dropdownItems\n\n    buttonEl = make \"a\", buttonAttributes, label\n\n    # needs to be wrapped for proper rendering, but not\n    # if it already is part of a group\n    autoWrapClass = \"btn-group\"\n    autoWrapClass += \" align-#{ config.align }\" if config.align?\n\n    if wrap is true\n      return make \"div\", {class: autoWrapClass}, [buttonEl,dropdownEl]\n    else\n      # for buttons which are already part f a group\n      buttonEl\n\nprepareButtons = (buttons=[], wrap=true)->\n  buildButton(button, wrap) for  button in buttons\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/tab_view.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/tab_view.coffee","type":"component_definition","class_name":"Luca.containers.TabView","header_documentation":"","type_alias":"tab_view","css_class_identifier":"luca-containers-tab-view","defines_methods":{"initialize":{"defined_on_line":19,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"activeTabSelector":{"defined_on_line":30,"documentation":"","arguments":[]},"beforeLayout":{"defined_on_line":33,"documentation":"","arguments":[]},"afterRender":{"defined_on_line":41,"documentation":"","arguments":[]},"createTabSelectors":{"defined_on_line":50,"documentation":"","arguments":[]},"highlightSelectedTab":{"defined_on_line":63,"documentation":"","arguments":[]},"tabSelectClickHandler":{"defined_on_line":67,"documentation":"","arguments":[{"argument":"e","value":null}]},"select":{"defined_on_line":75,"documentation":"","arguments":[{"argument":"tabName","value":"0"}]},"componentElements":{"defined_on_line":80,"documentation":"","arguments":[]},"tabContentWrapper":{"defined_on_line":83,"documentation":"","arguments":[]},"tabContainerWrapper":{"defined_on_line":86,"documentation":"","arguments":[]},"tabContainer":{"defined_on_line":89,"documentation":"","arguments":[]},"tabSelectors":{"defined_on_line":92,"documentation":"","arguments":[]},"bodyTemplateVars":{"defined_on_line":95,"documentation":"","arguments":[]}},"defines_properties":{"tab_position":{"defined_on_line":8,"documentation":"","default":""},"tabVerticalOffset":{"defined_on_line":9,"documentation":"","default":""},"additionalClassNames":{"defined_on_line":12,"documentation":"","default":""},"navClass":{"defined_on_line":13,"documentation":"","default":""},"bodyTemplate":{"defined_on_line":14,"documentation":"","default":""},"bodyClassName":{"defined_on_line":15,"documentation":"","default":""},"skipGetterMethods":{"defined_on_line":16,"documentation":"","default":""}},"source_file_contents":"tabView = Luca.register       \"Luca.containers.TabView\"\ntabView.extends               \"Luca.containers.CardView\"\n\ntabView.triggers              \"before:select\",\n                              \"after:select\"\n\ntabView.publicConfiguration\n  tab_position: 'top'\n  tabVerticalOffset: '50px'\n\ntabView.privateConfiguration\n  additionalClassNames: 'tabbable'\n  navClass: \"nav-tabs\"\n  bodyTemplate: \"containers/tab_view\"\n  bodyClassName: \"tab-content\"\n  skipGetterMethods: true\n\ntabView.defines\n  initialize: (@options={})->\n    @navClass = \"nav-list\"if @navStyle is \"list\"\n\n    Luca.containers.CardView::initialize.apply @, arguments\n\n    _.bindAll @, \"select\", \"highlightSelectedTab\"\n\n    @setupHooks( @hooks )\n\n    @bind \"after:card:switch\", @highlightSelectedTab\n\n  activeTabSelector: ()->\n    @tabSelectors().eq( @activeCard || @activeTab || @activeItem )\n\n  beforeLayout: ()->\n    @$el.addClass(\"tabs-#{ @tab_position }\")\n    @activeTabSelector().addClass 'active'\n\n    @createTabSelectors()\n\n    Luca.containers.CardView::beforeLayout?.apply @, arguments\n\n  afterRender: ()->\n    Luca.containers.CardView::afterRender?.apply @, arguments\n    tabContainerId = @tabContainer().attr(\"id\")\n    @registerEvent(\"click ##{ tabContainerId } li a\", \"tabSelectClickHandler\")\n\n    if Luca.config.enableBootstrap and (@tab_position is \"left\" or @tab_position is \"right\")\n      @tabContainerWrapper().addClass(\"span2\")\n      @tabContentWrapper().addClass(\"span9\")\n\n  createTabSelectors: ()->\n    tabView = @\n    @each (component,index)->\n      icon = \"<i class='icon-#{ component.tabIcon }'></i>\" if component.tabIcon\n      link = \"<a href='#'>#{ icon || ''} #{ component.title }</a>\"\n      selector = tabView.make(\"li\",{class:\"tab-selector\",\"data-target\":index}, link)\n      tabView.tabContainer().append(selector)\n\n      if component.navHeading? and not tabView.navHeadings?[ component.navHeading ]\n        $( selector ).before( tabView.make('li',{class:\"nav-header\"}, component.navHeading))\n        tabView.navHeadings ||= {}\n        tabView.navHeadings[ component.navHeading ] = true\n\n  highlightSelectedTab: ()->\n    @tabSelectors().removeClass('active')\n    @activeTabSelector().addClass('active')\n\n  tabSelectClickHandler: (e)->\n    e?.preventDefault()\n    me = my = $( e.target )\n    me = my ||= @tabSelectors()[0]\n    tabName = my.parent().data('target')\n\n    @select(tabName)\n\n  select: (tabName=0)->\n    @trigger \"before:select\", @\n    @activate(tabName)\n    @trigger \"after:select\", @\n\n  componentElements: ()->\n    @$(\">.tab-content >.#{ @componentClass }\")\n\n  tabContentWrapper: ()->\n    $(\"##{ @cid }-tab-view-content\")\n\n  tabContainerWrapper: ()->\n    $(\"##{ @cid }-tabs-selector\")\n\n  tabContainer: ()->\n    @$(\"ul.#{ @navClass }\", @tabContainerWrapper() )\n\n  tabSelectors: ()->\n    @$( 'li.tab-selector', @tabContainer() )\n\n  bodyTemplateVars: ()->\n    cid: @cid  \n    navClass: @navClass"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/viewport.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/containers/viewport.coffee","type":"component_definition","class_name":"Luca.containers.Viewport","header_documentation":"","type_alias":"viewport","css_class_identifier":"luca-containers-viewport","defines_methods":{"initialize":{"defined_on_line":10,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"enableFluid":{"defined_on_line":21,"documentation":"","arguments":[{"argument":")-> @enableWrapper(","value":null}]},"disableFluid":{"defined_on_line":23,"documentation":"","arguments":[{"argument":")-> @disableWrapper(","value":null}]},"enableWrapper":{"defined_on_line":25,"documentation":"","arguments":[]},"disableWrapper":{"defined_on_line":29,"documentation":"","arguments":[]},"enableFullscreen":{"defined_on_line":33,"documentation":"","arguments":[]},"disableFullscreen":{"defined_on_line":37,"documentation":"","arguments":[]},"beforeRender":{"defined_on_line":41,"documentation":"","arguments":[]},"height":{"defined_on_line":50,"documentation":"","arguments":[]},"width":{"defined_on_line":53,"documentation":"","arguments":[]},"afterRender":{"defined_on_line":56,"documentation":"","arguments":[]},"renderTopNavigation":{"defined_on_line":62,"documentation":"","arguments":[]},"renderBottomNavigation":{"defined_on_line":77,"documentation":"","arguments":[]}},"defines_properties":{"fullscreen":{"defined_on_line":5,"documentation":"","default":""},"fluid":{"defined_on_line":6,"documentation":"","default":""},"applyWrapper":{"defined_on_line":8,"documentation":"","default":""}},"source_file_contents":"viewport = Luca.register    \"Luca.containers.Viewport\"\nviewport.extends            \"Luca.Container\"\n\nviewport.defines\n  fullscreen: true\n  fluid: false\n\n  applyWrapper: true\n\n  initialize: (@options={})->\n    _.extend @, @options\n\n    if Luca.config.enableBoostrap is true and @applyWrapper is true\n      @wrapperClass = if @fluid is true then Luca.config.fluidWrapperClass else Luca.config.wrapperClass\n\n    Luca.Container::initialize.apply(@, arguments)\n\n    if @fullscreen is true\n      @enableFullscreen() \n\n  enableFluid: ()-> @enableWrapper()\n\n  disableFluid: ()-> @disableWrapper()\n   \n  enableWrapper: ()->\n    if @wrapperClass?\n      @$el.parent().addClass( @wrapperClass ) \n\n  disableWrapper: ()->\n    if @wrapperClass?\n      @$el.parent().removeClass( @wrapperClass ) \n\n  enableFullscreen: ()->\n    $('html,body').addClass('luca-ui-fullscreen')\n    @$el.addClass('fullscreen-enabled')\n\n  disableFullscreen: ()->\n    $('html,body').removeClass('luca-ui-fullscreen')\n    @$el.removeClass('fullscreen-enabled')\n\n  beforeRender: ()->\n    Luca.containers.CardView::beforeRender?.apply(@, arguments)\n\n    #if Luca.config.enableBoostrap and @topNav and @fullscreen\n    #  $('body').css('padding','40px')\n\n    @renderTopNavigation() if @topNav?\n    @renderBottomNavigation() if @bottomNav?\n\n  height: ()->\n    @$el.height()\n\n  width: ()->\n    @$el.width()\n\n  afterRender: ()->\n    Luca.containers.CardView::after?.apply(@, arguments)\n\n    if Luca.config.enableBoostrap is true and @containerClassName\n      @$el.children().wrap('<div class=\"#{ containerClassName }\" />')\n\n  renderTopNavigation: ()->\n    return unless @topNav?\n\n    if _.isString( @topNav )\n      @topNav = Luca.util.lazyComponent(@topNav)\n\n    if _.isObject( @topNav )\n      @topNav.ctype ||= @topNav.type || \"nav_bar\"\n      unless Luca.isBackboneView(@topNav)\n        @topNav = Luca.util.lazyComponent( @topNav )\n\n    @topNav.app = @\n\n    $('body').prepend( @topNav.render().el )\n\n  renderBottomNavigation: ()->\n    # IMPLEMENT\n\n\nLuca.containers.Viewport.defaultWrapperClass  = Luca.config.wrapperClass || 'container'\nLuca.containers.Viewport.fluidWrapperClass    = Luca.config.fluidWrapperClass || 'container-fluid'\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/core/panel.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/core/panel.coffee","type":"component_definition","class_name":"Luca.Panel","header_documentation":"<p>Luca.Panel is a low level Luca.View component which is used \nto build components which have toolbar areas, and a body area for the main\ncontents of the view.</p>\n","type_alias":"panel","css_class_identifier":"luca-panel","defines_methods":{"applyStyles":{"defined_on_line":18,"documentation":"","arguments":[{"argument":"styles","value":"{}"},{"argument":"body","value":"false"}]},"$bodyEl":{"defined_on_line":27,"documentation":"","arguments":[]},"$wrap":{"defined_on_line":44,"documentation":"","arguments":[]},"$template":{"defined_on_line":50,"documentation":"","arguments":[]},"$empty":{"defined_on_line":53,"documentation":"","arguments":[]},"$html":{"defined_on_line":56,"documentation":"","arguments":[]},"$append":{"defined_on_line":59,"documentation":"","arguments":[]},"beforeRender":{"defined_on_line":63,"documentation":"","arguments":[]},"renderToolbars":{"defined_on_line":69,"documentation":"","arguments":[]},"renderToolbar":{"defined_on_line":74,"documentation":"","arguments":[{"argument":"orientation","value":"\"top\""},{"argument":"config","value":"{}"}]},"attachToolbar":{"defined_on_line":83,"documentation":"","arguments":[{"argument":"config","value":"{}"},{"argument":"targetEl","value":null}]}},"defines_properties":{"topToolbar":{"defined_on_line":11,"documentation":"","default":""},"bottomToolbar":{"defined_on_line":12,"documentation":"","default":""},"version":{"defined_on_line":124,"documentation":"","default":""}},"source_file_contents":"# Luca.Panel is a low level Luca.View component which is used \n# to build components which have toolbar areas, and a body area for the main\n# contents of the view.\npanel = Luca.register           \"Luca.Panel\"\n\npanel.replaces                  \"Luca.Panel\"\n\npanel.extends                   \"Luca.View\"\n\npanel.configuration\n  topToolbar: undefined\n  bottomToolbar: undefined\n  #loadMask: false\n  #loadMaskTemplate: \"components/load_mask\"\n  #loadMaskTimeout: 3000\n\npanel.publicMethods\n  applyStyles: (styles={},body=false)->\n\n    target = if body then @$bodyEl() else @$el\n\n    for setting, value  of styles\n      target.css(setting,value)\n\n    @\n\n  $bodyEl: ()->\n    element = @bodyTagName || \"div\"\n    className = @bodyClassName || \"view-body\"\n\n    @bodyEl ||= \"#{ element }.#{ className }\"\n\n    bodyEl = @$(@bodyEl)\n\n    return bodyEl if bodyEl.length > 0\n\n    if bodyEl.length is 0 and (@bodyClassName? || @bodyTagName?)\n      newElement = @make(element,class:className,\"data-auto-appended\":true)\n      @$el.append( newElement )\n      return @$(@bodyEl)\n\n    @$el\n\n  $wrap: (wrapper)->\n    if _.isString(wrapper) and not wrapper.match(/[<>]/)\n      wrapper = @make(\"div\",class:wrapper)\n\n    @$el.wrap( wrapper )\n\n  $template: (template, variables={})->\n    @$html( Luca.template(template,variables) )\n\n  $empty: ()->\n    @$bodyEl().empty()\n    \n  $html: (content)->\n    @$bodyEl().html( content )\n\n  $append: (content)->\n    @$bodyEl().append(content)\n\npanel.privateMethods\n  beforeRender: ()->\n    Luca.View::beforeRender?.apply(@, arguments)\n    @applyStyles( @styles ) if @styles?\n    @applyStyles( @bodyStyles, true ) if @bodyStyles?\n    @renderToolbars?()\n\n  renderToolbars: ()->\n    _( [\"top\",\"left\",\"right\",\"bottom\"] ).each (orientation)=>\n      if config = @[\"#{ orientation }Toolbar\"]\n        @renderToolbar( orientation, config)\n\n  renderToolbar: (orientation=\"top\", config={})->\n    config.parent = @\n    config.orientation = orientation\n    el = Luca.util.read( config.container )\n    el ||= Luca.util.read( config.targetEl )\n\n    Luca.Panel.attachToolbar.call(@, config, el )\n\npanel.classMethods\n  attachToolbar: (config={}, targetEl)->\n    config.orientation ||= \"top\"\n    config.type ||= config.ctype ||= @toolbarType || \"panel_toolbar\"\n\n    config.additionalClassNames = \"#{ Luca.config.toolbarContainerClass } #{ config.orientation }\"\n  \n    toolbar = Luca.util.lazyComponent( config )\n    # TEMP\n    # Do this properly\n    if config.orientation is \"bottom\"\n      @getBottomToolbar ||= ()-> toolbar   \n\n    if config.orientation is \"top\"\n      @getTopToolbar ||= ()-> toolbar   \n\n    if config.orientation is \"right\"\n      @getRightToolbar ||= ()-> toolbar   \n\n    if config.orientation is \"left\"\n      @getLeftToolbar ||= ()-> toolbar   \n\n    hasBody = @bodyClassName or @bodyTagName\n\n    action = config.attachmentAction\n    # there will be a body panel inside of the views $el\n    # so just place the toolbar before, or after the body\n    action ||= switch config.orientation\n      when \"top\", \"left\"\n        if hasBody and not targetEl?.length > 0 then \"before\" else \"prepend\"\n\n      when \"bottom\", \"right\"\n        if hasBody and not targetEl?.length > 0 then \"after\" else \"append\"\n\n    toolbarEl = if targetEl?.length > 0\n      @$(targetEl)\n    else\n      @$bodyEl()\n\n    toolbarEl[action]( toolbar.render().el )\n\npanel.defines\n  version: 3"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/core/view.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/core/view.coffee","type":"component_definition","class_name":"Luca.View","header_documentation":"<p><code>Luca.View</code> is an enhanced <code>Backbone.View</code> which provides common patterns for view components,\nand various helper methods and configuration conventions.</p>\n\n<h4>Instance caching / naming</h4>\n\n<p>If you provide a <code>@name</code> property to your views, they will be accessible by that property\nusing the Application helper.<br>\n      view = new Luca.View(name:&quot;my<em>view&quot;)\n      Luca(&quot;my</em>view&quot;) === view</p>\n\n<h4>CSS @className conventions</h4>\n\n<p>In order to make it easier to componentize your views, extending from <code>Luca.View</code> will\nenable CSS class based inheritance based on the names of the view class.</p>\n\n<h5>For Example:</h5>\n\n<pre><code>  base = Luca.register  &quot;App.views.BaseViewClass&quot;\n  base.extends          &quot;Luca.View&quot;\n  base.defines\n    className: &quot;some-other-class&quot;\n  child = Luca.register &quot;App.views.ChildViewClass&quot;\n  child.extends         &quot;App.views.BaseViewClass&quot;\n  child.defines\n    myClasses: ()-&gt;\n      @$el.attr(&#39;class&#39;) \n\nview = new App.views.ChildViewClass()\nview.myClasses() #=&gt; &quot;app-base-view-class app-child-view-class some-other-class&quot;\n</code></pre>\n\n<p>This establishes a convention for css class names, and allows you to componetize your css\nalong with the component by joining them based on the name of your view class.  When using\nSass scoping / nesting it fits very nicely together.</p>\n\n<h4>Internal state machine</h4>\n\n<p>Any <code>Luca.View</code> class which defines a <code>@stateful</code> property will automatically generate a\n<code>@state</code> model that can be used to get/set attributes on the view as well as bind to change events on these attributes.  </p>\n\n<p>This gives your views a dedicated place to store state, and you can bind to your data models separately\nand update the DOM without confusing the two. </p>\n\n<pre><code>  statefulView = Luca.register    &quot;App.views.StatefulView&quot;\n  statefulView.extends            &quot;Luca.View&quot;\n  statefulView.defines\n    # Passing an object allows you to set default values on the @state model.\n    stateful:\n      attribute: &quot;value&quot;\n    # Whenever the attribute specified changes, call the specified method.\n    stateChangeEvents:\n      &quot;attribute&quot; : &quot;onAttributeChange&quot;\n\n    onAttributeChange: (stateMachine, attributeValue)-&gt;\n      @doSomethingWhenAttributeChanges()\n</code></pre>\n\n<p>If this type of declarative style isn&#39;t your thing, you can still bind to events in code:</p>\n\n<pre><code>  view = new App.views.StatefulView()\n  view.on &quot;state:change:attribute&quot;, (stateMachine, attributeValue)=&gt; @$el.html(&quot;New Attribute: #&quot;)\n  view.set &quot;attribute&quot;, &quot;something&quot;\n</code></pre>\n\n<h4>Event binding helpers</h4>\n\n<p>In addition to the <code>@stateChangeEvent</code> bindings documented above, you have available\nto you similar configuration helpers for binding to events emitted by the singletons:\n- <code>Luca.Application</code> via <code>@applicationEvents</code> \n- <code>Luca.CollectionManager</code> via <code>@collectionEvents</code>\n- <code>Luca.SocketManager</code> via <code>@socketEvents</code></p>\n","type_alias":"view","css_class_identifier":"luca-view","defines_methods":{"identifier":{"defined_on_line":149,"documentation":"","arguments":[]},"remove":{"defined_on_line":154,"documentation":"<p>Calls Backbone.View::remove, and removes the view from the\ninstance cache.  Triggers a &quot;before:remove&quot; event.</p>\n","arguments":[]},"initialize":{"defined_on_line":159,"documentation":"","arguments":[{"argument":"@options","value":"{}"}]},"debug":{"defined_on_line":188,"documentation":"","arguments":[{"argument":"args...","value":null}]},"trigger":{"defined_on_line":193,"documentation":"","arguments":[]},"make":{"defined_on_line":204,"documentation":"<p>Backbone.View.prototype.make is removed in 0.9.10.\nAs we happen to rely on this little utility heavily,\nwe add it to Luca.View</p>\n","arguments":[{"argument":"tagName","value":null},{"argument":"attributes","value":null},{"argument":"content","value":null}]},"registerEvent":{"defined_on_line":213,"documentation":"","arguments":[{"argument":"selector","value":null},{"argument":"handler","value":null}]},"definitionClass":{"defined_on_line":226,"documentation":"<p>Returns a reference to the class which this view is an instance of.</p>\n","arguments":[]},"_collections":{"defined_on_line":230,"documentation":"<p>Returns a list of all of the collections which are properties on this view.</p>\n","arguments":[]},"_models":{"defined_on_line":234,"documentation":"<p>Returns a list of all of the models which are properties on this view.</p>\n","arguments":[]},"_views":{"defined_on_line":238,"documentation":"<p>Returns a list of all of the views which are properties on this view.</p>\n","arguments":[]},"legacy":{"defined_on_line":276,"documentation":"","arguments":[{"argument":"_userSpecifiedMethod","value":null}]},"improved":{"defined_on_line":316,"documentation":"","arguments":[{"argument":"_userSpecifiedMethod","value":null}]}},"defines_properties":{"name":{"defined_on_line":111,"documentation":"<p>Specifying a <code>@name</code> for your views is useful for views which\nthere will only be one instance.  This allows you to reference\nthe view instances by name using the application helper:\nLuca(&quot;my<em>view</em>name&quot;)</p>\n","default":""},"autoBindEventHandlers":{"defined_on_line":137,"documentation":"<p>Setting this property to true will automatically bind the context\nof your event handler methods to the instance of this view.  This\nsaves you from having to manually do:</p>\n\n<p>Luca.View.extend\nevents:\n&quot;click .one&quot; : &quot;oneHandler&quot;\n&quot;click .two&quot; : &quot;twoHandler&quot;\ninitialize: ()-&gt;\n_.bindAll(@, &quot;oneHandler&quot;, &quot;twoHandler&quot;)</p>\n\n<p>Instead:</p>\n\n<p>Luca.View.extend\nautoBindEventHandlers: true\nevents:\n&quot;click .one&quot; : &quot;oneHandler&quot;</p>\n\n<p>Optionally, you can define an array of method names you want bound\nto this view:</p>\n\n<p>Luca.View.extend\nbindMethods:[&quot;oneHandler&quot;,&quot;twoHandler&quot;]</p>\n","default":""},"_inheritEvents":{"defined_on_line":143,"documentation":"<p>Supplying configuration to <code>@_events</code> will ensure that this configuration\nis present on views which extend from this view.  In normal Backbone behavior\nthe <code>@events</code> property can be overridden by views which extend, and this isn&#39;t\nalways what you want from your component.</p>\n","default":""},"setupHooks":{"defined_on_line":252,"documentation":"<p>views which inherit from Luca.View can define hooks\nor events which can be emitted from them.  Automatically,\nany functions on the view which are named according to the\nconvention will automatically get run.</p>\n\n<p>by default, all Luca.View classes come with the following:</p>\n\n<ul>\n<li>before:render     : beforeRender()</li>\n<li>after:render      : afterRender()</li>\n<li>after:initialize  : afterInitialize()</li>\n<li>first:activation  : firstActivation()</li>\n</ul>\n","default":""},"if not Backbone.View":{"defined_on_line":257,"documentation":"","default":""},"_userSpecifiedMethod ||= ()-> @trigger \"empty":{"defined_on_line":343,"documentation":"","default":""}},"source_file_contents":"# `Luca.View` is an enhanced `Backbone.View` which provides common patterns for view components,\n# and various helper methods and configuration conventions.\n#\n# #### Instance caching / naming\n#\n# If you provide a `@name` property to your views, they will be accessible by that property\n# using the Application helper.    \n#\n#       view = new Luca.View(name:\"my_view\")\n#       Luca(\"my_view\") === view\n#\n# #### CSS @className conventions\n#  \n# In order to make it easier to componentize your views, extending from `Luca.View` will\n# enable CSS class based inheritance based on the names of the view class.\n#\n# ##### For Example:\n#\n#       base = Luca.register  \"App.views.BaseViewClass\"\n#       base.extends          \"Luca.View\"\n#       base.defines\n#         className: \"some-other-class\"\n#\n#       child = Luca.register \"App.views.ChildViewClass\"\n#       child.extends         \"App.views.BaseViewClass\"\n#       child.defines\n#         myClasses: ()->\n#           @$el.attr('class') \n#     \n#     view = new App.views.ChildViewClass()\n#     view.myClasses() #=> \"app-base-view-class app-child-view-class some-other-class\"\n#\n# This establishes a convention for css class names, and allows you to componetize your css\n# along with the component by joining them based on the name of your view class.  When using\n# Sass scoping / nesting it fits very nicely together.\n#\n# #### Internal state machine\n# \n# Any `Luca.View` class which defines a `@stateful` property will automatically generate a\n# `@state` model that can be used to get/set attributes on the view as well as bind to change events on these attributes.  \n# \n# This gives your views a dedicated place to store state, and you can bind to your data models separately\n# and update the DOM without confusing the two. \n# \n#       statefulView = Luca.register    \"App.views.StatefulView\"\n#       statefulView.extends            \"Luca.View\"\n#\n#       statefulView.defines\n#         # Passing an object allows you to set default values on the @state model.\n#         stateful:\n#           attribute: \"value\"\n#\n#         # Whenever the attribute specified changes, call the specified method.\n#         stateChangeEvents:\n#           \"attribute\" : \"onAttributeChange\"\n#         \n#         onAttributeChange: (stateMachine, attributeValue)->\n#           @doSomethingWhenAttributeChanges()\n#\n#  If this type of declarative style isn't your thing, you can still bind to events in code:\n#       \n#       view = new App.views.StatefulView()\n#       view.on \"state:change:attribute\", (stateMachine, attributeValue)=> @$el.html(\"New Attribute: #\")\n#       view.set \"attribute\", \"something\"\n# \n# #### Event binding helpers\n# \n# In addition to the `@stateChangeEvent` bindings documented above, you have available\n# to you similar configuration helpers for binding to events emitted by the singletons:\n#\n# - `Luca.Application` via `@applicationEvents` \n# - `Luca.CollectionManager` via `@collectionEvents`\n# - `Luca.SocketManager` via `@socketEvents`\nview = Luca.register    \"Luca.View\"\nview.extends            \"Backbone.View\"\n\n# includes are extensions to the prototype, and have no special behavior\nview.includes           \"Luca.Events\",\n                        \"Luca.concerns.DomHelpers\",\n                        \"Luca.concerns.DevelopmentToolHelpers\"\n\n# concerns are includes with special property / method conventions\n# which customize the components through the use of __initializer and\n# __included method names.  These will be called every time an instance\n# is created, and the first time the mixin is used to enhance a component.\nview.mixesIn            \"DomHelpers\",\n                        \"Templating\",\n                        \"EnhancedProperties\",\n                        \"CollectionEventBindings\",\n                        \"ApplicationEventBindings\",\n                        \"StateModel\"\n\n# Luca.View classes have the concept of special events called hooks\n# which allow you to tap into the lifecycle events of your view to\n# customize their behavior.  This is especially useful in subclasses.\n#\n# You can utilize a @hook method by camelcasing the triggers defined below:\nview.triggers           \"before:initialize\",\n                        \"after:initialize\",\n                        \"before:render\",\n                        \"after:render\",\n                        \"first:activation\",\n                        \"activation\",\n                        \"deactivation\"\n\nview.publicConfiguration\n  # Specifying a `@name` for your views is useful for views which\n  # there will only be one instance.  This allows you to reference\n  # the view instances by name using the application helper:\n  #       Luca(\"my_view_name\")\n  name: undefined\n\n  # Setting this property to true will automatically bind the context\n  # of your event handler methods to the instance of this view.  This\n  # saves you from having to manually do:\n  #\n  #       Luca.View.extend\n  #         events:\n  #           \"click .one\" : \"oneHandler\"\n  #           \"click .two\" : \"twoHandler\"\n  #         initialize: ()->\n  #           _.bindAll(@, \"oneHandler\", \"twoHandler\")\n  #\n  #  Instead:\n  #\n  #       Luca.View.extend\n  #         autoBindEventHandlers: true\n  #         events: \n  #           \"click .one\" : \"oneHandler\"\n  #\n  # Optionally, you can define an array of method names you want bound\n  # to this view:\n  #\n  #       Luca.View.extend\n  #         bindMethods:[\"oneHandler\",\"twoHandler\"]\n  #\n  autoBindEventHandlers: false\n\n  # Supplying configuration to `@_events` will ensure that this configuration\n  # is present on views which extend from this view.  In normal Backbone behavior\n  # the `@events` property can be overridden by views which extend, and this isn't\n  # always what you want from your component.   \n  _inheritEvents: undefined\n\n\n\n# Luca.View decorates Backbone.View with some patterns and conventions.\nview.publicMethods\n  identifier: ()->\n    (@displayName || @type ) + \":\" + (@name || @role || @cid)\n\n  # Calls Backbone.View::remove, and removes the view from the \n  # instance cache.  Triggers a \"before:remove\" event.\n  remove: ()->\n    @trigger(\"before:remove\", @)\n    Luca.remove(@)\n    Backbone.View::remove.apply(@, arguments)\n\n  initialize: (@options={})->\n    @trigger \"before:initialize\", @, @options\n\n    _.extend @, @options\n\n    if @autoBindEventHandlers is true or @bindAllEvents is true\n      bindAllEventHandlers.call(@)\n\n    @cid = _.uniqueId(@name) if @name?\n\n    @$el.attr(\"data-luca-id\", @name || @cid)\n\n    Luca.registry.cacheInstance( @cid, @ )\n\n    @setupHooks _( Luca.View::hooks.concat( @hooks ) ).uniq()\n\n    Luca.concern.setup.call(@)\n\n    @delegateEvents() unless _.isEmpty(@events)\n\n    @trigger \"after:initialize\", @\n\n    _.bindAll(@, @bindMethods...) if @bindMethods?.legth > 0\n\n    unless _.isEmpty(@_inheritEvents)\n      for eventId, handler of @_inheritEvents\n        @registerEvent(eventId, handler)\n\n\n  debug: (args...)->\n    if @debugMode is true or window.LucaDebugMode is true\n      args.unshift @identifier()\n      console.log args...\n\n  trigger: ()->\n    if Luca.enableGlobalObserver\n      if Luca.developmentMode is true or @observeEvents is true\n        Luca.ViewObserver ||= new Luca.Observer(type:\"view\")\n        Luca.ViewObserver.relay @, arguments\n\n    Backbone.View::trigger.apply @, arguments\n\n  # Backbone.View.prototype.make is removed in 0.9.10.\n  # As we happen to rely on this little utility heavily,\n  # we add it to Luca.View\n  make: (tagName, attributes, content)->\n    el = document.createElement(tagName);\n    if (attributes) \n      Backbone.$(el).attr(attributes)\n    if (content != null) \n      Backbone.$(el).html(content)\n      \n    el    \n\n  registerEvent: (selector, handler)->\n    @events ||= {}\n\n    if _.isObject(selector)\n      @events = _.extend(@events, selector)\n    else\n      if _.isFunction(handler) || (_.isString(handler) && @[handler]?)\n        @events[selector] = handler \n\n    @delegateEvents()\n\nview.privateMethods\n  # Returns a reference to the class which this view is an instance of.\n  definitionClass: ()->\n    Luca.util.resolve(@displayName, window)?.prototype\n\n  # Returns a list of all of the collections which are properties on this view.\n  _collections: ()->\n    Luca.util.selectProperties( Luca.isBackboneCollection, @ )\n\n  # Returns a list of all of the models which are properties on this view.\n  _models: ()->\n    Luca.util.selectProperties( Luca.isBackboneModel, @ )\n\n  # Returns a list of all of the views which are properties on this view.\n  _views: ()->\n    Luca.util.selectProperties( Luca.isBackboneView, @ )\n\n  # views which inherit from Luca.View can define hooks\n  # or events which can be emitted from them.  Automatically,\n  # any functions on the view which are named according to the\n  # convention will automatically get run.\n  #\n  # by default, all Luca.View classes come with the following:\n  #\n  # - before:render     : beforeRender()\n  # - after:render      : afterRender()\n  # - after:initialize  : afterInitialize()\n  # - first:activation  : firstActivation()\n  setupHooks: Luca.util.setupHooks\n\n# In order to support some Luca apps which rely\n# on Backbone.View.make.  \nview.afterDefinition ()->\n  if not Backbone.View::make?\n    Backbone.View::make = ()->\n      console.log \"Backbone.View::make has been removed from backbone.  You should use Luca.View::make instead.\"\n      Luca.View::make\n\nview.register()\n\nLuca.View._originalExtend = Backbone.View.extend\n\n# Note:\n#\n# I will be removing this prior to 1.0.  Optimizing for collection based\n# views does not belong in here, so the deferrable / collection binding stuff\n# needs to go.\n#\n# Being able to defer rendering until the firing of an event on another object\n# is something that does ask for some syntactic sugar though, so need to rethink.\n\nLuca.View.renderStrategies =\n  legacy: ( _userSpecifiedMethod )->\n    view = @\n    # if a view has a deferrable property set\n\n    if @deferrable\n      target = @deferrable_target\n\n      unless Luca.isBackboneCollection(@deferrable)\n        @deferrable = @collection\n\n      target ||= @deferrable\n      trigger = if @deferrable_event then @deferrable_event else Luca.View.deferrableEvent\n\n      deferred = ()->\n        _userSpecifiedMethod.call(view)\n        @rendered = true\n        view.trigger(\"after:render\", view)\n\n      view.defer(deferred).until(target, trigger)\n\n      view.trigger \"before:render\", @\n\n      autoTrigger = @deferrable_trigger || @deferUntil\n\n      if !autoTrigger?\n        target[ (@deferrable_method||\"fetch\") ].call(target)\n      else\n        fn = _.once ()=> @deferrable[ (@deferrable_method||\"fetch\") ]?()\n        (@deferrable_target || @ ).bind(@deferrable_trigger, fn)\n\n      return @\n\n    else\n      @trigger \"before:render\", @\n      _userSpecifiedMethod.apply(@, arguments)\n      @rendered = true\n      @trigger \"after:render\", @\n\n      return @\n\n  improved: (_userSpecifiedMethod)->\n    @trigger \"before:render\", @\n\n    deferred = ()=>\n      _userSpecifiedMethod.apply(@, arguments)\n      @trigger \"after:render\", @\n\n    console.log \"doing the improved one\", @deferrable\n\n    if @deferrable? and not _.isString(@deferrable)\n      throw \"Deferrable property is expected to be a event id\"\n\n    if _.isString(@deferrable)\n      console.log \"binding to #{ @deferrable } on #{ @cid }\"\n      view.on @deferrable, ()->\n        console.log \"did the improved one\"\n        deferred.call(view)\n        view.unbind(listenForEvent, @)\n\n    else\n      deferred.call(@)\n\n\n\nLuca.View.renderWrapper = (definition)->\n  _userSpecifiedMethod = definition.render\n\n  _userSpecifiedMethod ||= ()-> @trigger \"empty:render\"\n\n  definition.render = ()->\n    strategy = Luca.View.renderStrategies[ @renderStrategy ||= \"legacy\" ]\n\n    unless _.isFunction(strategy)\n      throw \"Invalid rendering strategy.  Please see Luca.View.renderStrategies\"\n\n    strategy.call(@, _userSpecifiedMethod)\n\n    @\n\n  definition\n\nbindAllEventHandlers = ()->\n  for config in [@events, @componentEvents, @collectionEvents, @applicationEvents] when not _.isEmpty(config)\n    bindEventHandlers.call(@, config)\n\nbindEventHandlers = (events={})->\n  for eventSignature, handler of events\n    if _.isString(handler)\n      try\n        _.bindAll @, handler\n      catch e\n        console.log \"Error binding to handler - #{handler} = #{e} #{@identifier()}\"\n\nLuca.View.deferrableEvent = \"reset\"\n\nLuca.View.extend = (definition={})->\n  definition = Luca.View.renderWrapper( definition )\n  # for backward compatibility\n  definition.concerns ||= definition.concerns if definition.concerns?\n\n  componentClass = Luca.View._originalExtend.call(@, definition)\n\n  if definition.concerns? and _.isArray( definition.concerns )\n    for module in definition.concerns\n      Luca.decorate( componentClass ).with( module )\n\n  componentClass\n\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/development/code_sync_manager.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/development/code_sync_manager.coffee","type":"component_definition","class_name":"Luca.CodeSyncManager","header_documentation":"","type_alias":"code_sync_manager","css_class_identifier":"luca-code-sync-manager","defines_methods":{"setup":{"defined_on_line":10,"documentation":"","arguments":[{"argument":"options","value":"{}"}]},"initialize":{"defined_on_line":15,"documentation":"","arguments":[{"argument":"@attributes","value":"{}"}]},"bindToChannel":{"defined_on_line":22,"documentation":"","arguments":[]},"onChangesNotification":{"defined_on_line":34,"documentation":"<p>changeData is a payload that gets sent over the socket\nwhenever an asset that is being watched changes.\nit is different if the type of file is css or javascript.</p>\n","arguments":[{"argument":"changeData","value":"{}"},{"argument":"applicationName","value":null}]},"rerunSyncPad":{"defined_on_line":56,"documentation":"","arguments":[]},"processTemplate":{"defined_on_line":60,"documentation":"","arguments":[{"argument":"change","value":"{}"}]},"processComponentDefinitionChange":{"defined_on_line":66,"documentation":"","arguments":[{"argument":"change","value":"{}"}]},"processJavascriptChange":{"defined_on_line":76,"documentation":"","arguments":[{"argument":"change","value":"{}"}]},"processStylesheetChange":{"defined_on_line":90,"documentation":"","arguments":[{"argument":"change","value":"{}"}]},"replaceStylesheetAndEverythingAfter":{"defined_on_line":98,"documentation":"","arguments":[{"argument":"path","value":null}]},"syncStylesheet":{"defined_on_line":115,"documentation":"","arguments":[{"argument":"change","value":null}]}},"defines_properties":{"host":{"defined_on_line":5,"documentation":"","default":""},"namespace":{"defined_on_line":6,"documentation":"","default":""},"channel":{"defined_on_line":7,"documentation":"","default":""},"make":{"defined_on_line":126,"documentation":"","default":""}},"source_file_contents":"codeManager = Luca.register     \"Luca.CodeSyncManager\"\ncodeManager.extends             \"Luca.SocketManager\"\n\ncodeManager.publicConfiguration\n  host:       Luca.config.codeSyncHost || \"http://localhost:9292/faye\"\n  namespace:  \"luca\"\n  channel:    Luca.config.codeSyncChannel || \"/changes\"\n\ncodeManager.classMethods\n  setup: (options={})->\n    @codeSyncManager = new Luca.CodeSyncManager(options) \n    @codeSyncManager.trigger(\"ready\")\n\ncodeManager.privateMethods\n  initialize: (@attributes={})->\n    unless @attributes.host?\n      _.extend(@attributes, host: (@host || Luca.config.codeSyncHost))\n\n    Luca.SocketManager::initialize.call(@, @attributes)\n    @bindToChannel()\n\n  bindToChannel: ()->\n    if @client?\n      @client.subscribe @channel, ()=>\n        @onChangesNotification.apply(@, arguments)\n    else\n      @on \"change:client\", (socketManager, client)=>\n        @client.subscribe @channel, ()=>\n          @onChangesNotification.apply(@, arguments)    \n\n  # changeData is a payload that gets sent over the socket\n  # whenever an asset that is being watched changes. \n  # it is different if the type of file is css or javascript.\n  onChangesNotification: (changeData={}, applicationName)->\n    return if _.isEmpty(changeData)\n    data = _( changeData ).values()[0] || {}\n\n    if data.type is \"template\"\n      @processTemplate(data)\n      @rerunSyncPad(data.type)\n\n    if data.type is \"component_definition\"\n      @processComponentDefinitionChange(data)\n      @processJavascriptChange(data)\n      \n      _.delay ()=>\n        @rerunSyncPad(data.type)\n      , 25\n\n    if data.type is \"javascript\"\n      @processJavascriptChange(data)\n\n    if data.type is \"stylesheet\" and data?.path\n      @processStylesheetChange(data)\n\n  rerunSyncPad: ()->\n    if last = @get(\"last_syncpad_javascript_payload\")\n      @processJavascriptChange(last)\n\n  processTemplate: (change={})->\n    fn = ()->\n      eval( change.contents )\n\n    fn.apply(window)\n\n  processComponentDefinitionChange: (change={})->\n    return if _.isEmpty(change)\n    @components ||= Luca.collections.Components.generate() \n\n    if change.class_name? \n      component = @components.findByClassName( change.class_name )\n\n      if component && change.source_file_contents?\n        component.set(source_file_contents: change.source_file_contents )\n\n  processJavascriptChange: (change={})->\n    return unless change?.compiled\n    existing = $(\"body script[data-path='#{ change.source }']\")\n\n    # just to be clean\n    if existing.length > 1\n      existing.remove()\n\n    if change.source?.match(/syncpad/) and change?.compiled and true\n      @set(\"last_syncpad_javascript_payload\", change)\n\n    script = @make(\"script\", {\"data-path\": change.source, type:\"text/javascript\"}, change.compiled)\n    $('body').append(script)\n\n  processStylesheetChange: (change={})->\n    return if _.isEmpty(change)\n\n    if change.path?.match(/syncpad/) or Luca.config.codeSyncStylesheetMode is \"single\"\n      @syncStylesheet(change)\n    else\n      @replaceStylesheetAndEverythingAfter(change.path)\n\n  replaceStylesheetAndEverythingAfter: (path)->\n    stylesheet  = path.replace('./app/assets/stylesheets', Luca.config.assetsUrlPrefix )\n    stylesheet  = stylesheet.replace('.scss','')\n    existing    = $(\"link[href*='#{ stylesheet }']\")\n    parent      = existing.parent()\n\n    return unless existing.length > 0\n\n    replaced = existing.clone()\n    comesAfter = existing.nextAll('link')\n    cloned = comesAfter.clone()\n\n    $(existing, comesAfter).remove()\n\n    parent.append( replaced )\n    parent.append( cloned )\n\n  syncStylesheet: (change)->\n    existing = $(\"head style[data-file='#{ change.path }']\")\n\n    if existing.length > 0\n      existing.remove()\n\n    if change.compiled? or change.contents?\n      link = @make(\"style\",{\"data-file\":change.path, type:\"text/css\"}, change.compiled || change.contents)\n      $('head').append( link )\n\ncodeManager.defines\n  make: Luca.View::make"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/development/component.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/development/component.coffee","type":"component_definition","class_name":"Luca.models.Component","header_documentation":"","type_alias":"component","css_class_identifier":"","defines_methods":{"documentation":{"defined_on_line":15,"documentation":"","arguments":[]},"documentationFor":{"defined_on_line":28,"documentation":"","arguments":[{"argument":"methodOrPropertyGroup","value":"\"publicMethods\""}]},"url":{"defined_on_line":41,"documentation":"","arguments":[]},"metaData":{"defined_on_line":44,"documentation":"","arguments":[]},"classNameId":{"defined_on_line":47,"documentation":"","arguments":[]},"componentGroup":{"defined_on_line":50,"documentation":"","arguments":[]},"componentType":{"defined_on_line":54,"documentation":"","arguments":[]},"componentTypeAlias":{"defined_on_line":73,"documentation":"","arguments":[]}},"defines_properties":{"idAttribute":{"defined_on_line":13,"documentation":"","default":""}},"source_file_contents":"model = Luca.register  \"Luca.models.Component\"\nmodel.extends           \"Luca.Model\"\n\nmodel.configuration\n  defaults:\n    class_name: undefined\n    superClass: undefined\n    asset_id: undefined\n    source_file_contents: \"\"\n    defined_in_file: \"\"\n\nmodel.defines\n  idAttribute: \"class_name\"\n  \n  documentation: ()->\n    base = _( @toJSON() ).pick 'header_documentation', 'class_name', 'defined_in_file'\n\n    _.extend base, @metaData(), \n      componentGroup: @componentGroup() \n      componentType: @componentType() \n      componentTypeAlias: @componentTypeAlias()\n      details:\n        publicMethods:        @documentationFor(\"publicMethods\")\n        privateMethods:       @documentationFor(\"privateMethods\")\n        privateProperties:    @documentationFor(\"privateProperties\")\n        publicProperties:     @documentationFor(\"publicProperties\")\n\n  documentationFor: (methodOrPropertyGroup=\"publicMethods\")->\n    documentationSource = _.extend({}, @get(\"defines_methods\"), @get(\"defines_properties\"))\n\n    result = {}\n\n    if list = @metaData()?[ methodOrPropertyGroup ]?()\n      _(list).reduce (memo, methodOrProperty)->\n        memo[ methodOrProperty ] = documentationSource[ methodOrProperty ]\n        memo\n      , result  \n\n    result\n\n  url: ()->\n    \"/project/components/#{ Luca.namespace }/#{ @classNameId() }\"\n\n  metaData: ()->\n    Luca( @get(\"class_name\") ).prototype.componentMetaData()\n\n  classNameId: ()->\n    @get(\"class_name\").replace(/\\./g,'__')\n\n  componentGroup: ()->\n    parts = @get('class_name').split('.')\n    parts.slice(0,2).join('.')\n\n  componentType: ()->\n    type  = \"view\"\n    parts = @get('class_name').split('.')\n\n    switch group = parts[1]\n      when \"collections\" then \"collection\"\n      when \"models\" then \"model\"\n      when (\"views\" || \"components\" || \"pages\") then \"view\"\n\n    return if group?\n\n    if componentPrototype = Luca.util.resolve( @get(\"class_name\") )\n      return \"view\" if Luca.isViewPrototype( componentPrototype:: )\n      return \"collection\" if Luca.isCollectionPrototype( componentPrototype:: )\n      return \"model\" if Luca.isModelProtoype( componentPrototype:: )\n\n    # meh, but what about Router?\n    \"view\"\n\n  componentTypeAlias: ()->\n    parts = @get('class_name').split('.')\n    name = parts.pop()\n    _.str.underscored( name )\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/development/components.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/development/components.coffee","type":"component_definition","class_name":"Luca.collections.Components","header_documentation":"","type_alias":"components","css_class_identifier":"","defines_methods":{"generate":{"defined_on_line":9,"documentation":"","arguments":[]},"findByClassName":{"defined_on_line":15,"documentation":"","arguments":[{"argument":"class_name","value":null}]},"filterByNamespace":{"defined_on_line":19,"documentation":"","arguments":[{"argument":"namespace","value":null}]},"classNames":{"defined_on_line":23,"documentation":"","arguments":[]},"groupsInsideOf":{"defined_on_line":26,"documentation":"","arguments":[{"argument":"namespace","value":null}]},"namespaces":{"defined_on_line":36,"documentation":"","arguments":[]},"fetch":{"defined_on_line":42,"documentation":"","arguments":[{"argument":"options","value":"{}"}]},"comparator":{"defined_on_line":45,"documentation":"","arguments":[{"argument":"model","value":null}]},"populateFromRegistry":{"defined_on_line":48,"documentation":"","arguments":[{"argument":"options","value":"{}"}]}},"defines_properties":{"model":{"defined_on_line":5,"documentation":"","default":""},"namespace":{"defined_on_line":6,"documentation":"","default":""}},"source_file_contents":"components = Luca.register   \"Luca.collections.Components\"\ncomponents.extends            \"Luca.Collection\"\n\ncomponents.configuration\n  model: Luca.models.Component\n  namespace: \"components\"\n\ncomponents.classMethods\n  generate: ()->\n    @collection = new Luca.collections.Components()\n    @collection.fetch()\n    @collection\n\ncomponents.defines\n  findByClassName: (class_name)->\n    @detect (model)->\n      model.get(\"class_name\") is class_name\n        \n  filterByNamespace: (namespace)->\n    @query\n      class_name: $like: namespace\n\n  classNames: ()->\n    @pluck('class_name')\n\n  groupsInsideOf: (namespace)->\n    classes = @filterByNamespace(namespace)\n    unique = {}\n    \n    for component in classes when not unique[ component.componentGroup() ]?\n      if component.get(\"class_name\")?.split('.')?.length > 2\n        unique[ component.componentGroup() ] = component.componentGroup().split('.')[1] \n\n    _.values(unique)\n\n  namespaces: ()->\n    list = _( @classNames() ).map (className)->\n      className.split('.')[0]\n\n    _( list ).uniq()\n\n  fetch: (options={})->\n    @populateFromRegistry(options)\n\n  comparator: (model)->\n    model.get(\"class_name\")\n      \n  populateFromRegistry: (options={})->\n    registeredClassNames = for class_name in Luca.registry.classes(true)\n      {class_name, name: class_name}\n\n    if options.namespace\n      registeredClassNames = for model in registeredClassNames when model.name.match(options.namespace)\n        model\n\n      \n    @reset(registeredClassNames, options={})\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/development/console.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/development/console.coffee","type":"component_definition","class_name":"Luca.tools.DevelopmentConsole","header_documentation":"","type_alias":"development_console","css_class_identifier":"luca-tools-development-console","defines_methods":{"afterRender":{"defined_on_line":59,"documentation":"","arguments":[]},"show":{"defined_on_line":66,"documentation":"","arguments":[{"argument":"options","value":"{}"}]},"getContext":{"defined_on_line":70,"documentation":"","arguments":[]},"initialize":{"defined_on_line":73,"documentation":"","arguments":[]},"saveHistory":{"defined_on_line":77,"documentation":"","arguments":[{"argument":"command","value":null}]},"historyUp":{"defined_on_line":81,"documentation":"","arguments":[]},"historyDown":{"defined_on_line":88,"documentation":"","arguments":[]},"append":{"defined_on_line":96,"documentation":"","arguments":[{"argument":"code","value":null},{"argument":"result","value":null},{"argument":"skipFormatting","value":"false"}]},"onSuccess":{"defined_on_line":110,"documentation":"","arguments":[{"argument":"result","value":null},{"argument":"js","value":null},{"argument":"coffee","value":null}]},"onError":{"defined_on_line":122,"documentation":"","arguments":[{"argument":"error","value":null},{"argument":"js","value":null},{"argument":"coffee","value":null}]},"evaluateCode":{"defined_on_line":125,"documentation":"","arguments":[{"argument":"code","value":null},{"argument":"raw","value":null}]},"runCommand":{"defined_on_line":165,"documentation":"","arguments":[]}},"defines_properties":{"className":{"defined_on_line":6,"documentation":"","default":""},"name":{"defined_on_line":7,"documentation":"","default":""},"historyIndex":{"defined_on_line":9,"documentation":"","default":""},"width":{"defined_on_line":10,"documentation":"","default":""}},"source_file_contents":"developmentConsole = Luca.register    \"Luca.tools.DevelopmentConsole\"\n\ndevelopmentConsole.extends            \"Luca.Container\"\n\ndevelopmentConsole.defines\n  className: \"luca-ui-console\"\n  name: \"console\"\n  history: []\n  historyIndex: 0\n  width: 1000\n\n  componentEvents:\n    \"input key:keyup\"    : \"historyUp\"\n    \"input key:keydown\"  : \"historyDown\"\n    \"input key:enter\"    : \"runCommand\"\n\n  compileOptions:\n    bare: true\n\n  components:[\n    type: \"code_mirror_field\"\n    role: \"code_mirror\"\n    additionalClassNames: \"clearfix\"\n    name: \"code_output\"\n    readOnly: true\n    lineNumbers: false\n    mode: \"javascript\"\n    lineWrapping: true\n    gutter: false\n  ,\n    type: \"text_field\"\n    name: \"code_input\"\n    role: \"input\"\n    lineNumbers: false\n    height: '30px'\n    maxHeight: '30px'\n    gutter: false\n    autoBindEventHandlers: true\n    hideLabel: true\n    prepend: \"Coffee>\"\n    events:\n      \"keypress input\" : \"onKeyEvent\"\n      \"keydown input\" : \"onKeyEvent\"\n\n    onKeyEvent: (keyEvent)->\n      if keyEvent.type is \"keypress\" and keyEvent.keyCode is Luca.keys.ENTER\n        @trigger(\"key:enter\", @getValue())\n\n      if keyEvent.type is \"keydown\" and keyEvent.keyCode is Luca.keys.KEYUP\n        @trigger(\"key:keyup\")\n\n      if keyEvent.type is \"keydown\" and keyEvent.keyCode is Luca.keys.KEYDOWN\n        @trigger(\"key:keydown\")\n\n    afterRender: ()->\n      @$('input').focus()\n  ]\n\n  afterRender: ()->\n    @$container().modal(backdrop: false)\n\n    if @width?\n      marginLeft = parseInt(@width) * 0.5 * -1\n      @$container().css(\"width\", @width).css('margin-left', parseInt(marginLeft) )\n\n  show: (options={})->\n    @$container().modal('show')\n    @\n\n  getContext: ()->\n    window\n\n  initialize: ()->\n    @_super(\"initialize\", @, arguments)\n    _.bindAll @, \"historyUp\", \"historyDown\", \"onSuccess\", \"onError\", \"runCommand\"\n\n  saveHistory: (command)->\n    @history.push( command ) if command?.length > 0\n    @historyIndex = 0\n\n  historyUp: ()->\n    @historyIndex -= 1\n    @historyIndex = 0 if @historyIndex < 0\n\n    currentValue = @getInput().getValue()\n    @getInput().setValue( @history[ @historyIndex ] || currentValue )\n\n  historyDown: ()->\n    @historyIndex += 1\n    @historyIndex = @history.length - 1 if @historyIndex > @history.length - 1\n\n    currentValue = @getInput().getValue()\n\n    @getInput().setValue( @history[ @historyIndex ] || currentValue)\n\n  append: (code, result, skipFormatting=false)->\n    output = @getCodeMirror()\n    current = output.getValue()\n\n    source = \"// #{ code }\" if code?\n\n    payload = if skipFormatting or code.match(/^console\\.log/)\n      [current,result]\n    else\n      [current,source, result]\n\n    output.setValue( _.compact(payload).join(\"\\n\") )\n    output.getCodeMirror().scrollTo(0,90000)\n\n  onSuccess: (result, js, coffee)->\n    @saveHistory(coffee)\n\n    dump = \"\"\n\n    if _.isArray( result ) or _.isObject( result ) or _.isString( result ) or _.isNumber(result)\n      dump = JSON.stringify(result, null, \"\\t\")\n\n    dump ||= result.toString?()\n\n    @append(js, dump || \"undefined\")\n\n  onError: (error, js, coffee)->\n    @append(js, \"// ERROR: #{ error.message }\")\n\n  evaluateCode: (code, raw)->\n    return unless code?.length > 0\n\n    raw = _.string.strip(raw)\n    output = @getCodeMirror()\n    dev = @\n\n    evaluator = ()->\n      old_console = window.console\n\n      console =\n        log: ()->\n          for arg in arguments\n            dev.append(undefined, arg, true)\n\n      log = console.log\n\n      try\n        result = eval( code )\n      catch error\n        window.console = old_console\n        throw(error)\n\n      window.console = old_console\n\n      result\n\n    try\n      result = evaluator.call( @getContext() )\n\n      # capture luca objects for special inspection \n      if Luca.isComponent( result )\n        result = Luca.util.inspectComponent( result )\n      else if Luca.isComponentPrototype( result )\n        result = Luca.util.inspectComponentPrototype( result )\n\n      @onSuccess(result, code, raw) unless raw.match(/^console\\.log/)\n    catch error\n      @onError(error, code, raw)\n\n  runCommand: ()->\n    dev     = @\n    compile = _.bind(Luca.tools.CoffeeEditor::compile, @)\n    raw = @getInput().getValue()\n    compiled = compile raw, (compiled)->\n      dev.evaluateCode(compiled, raw)\n\nLuca.util.launchers ||= {}\n\nLuca.util.inspectComponentPrototype = (componentPrototype)->\n  liveInstances = Luca.registry.findInstancesByClass( componentPrototype )\n\nLuca.util.inspectComponent = (component)->\n  component = Luca(component) if _.isString(component)\n\n  {\n    name:         component.name  \n    instanceOf:   component.displayName \n    subclassOf:   component._superClass()::displayName\n    inheritsFrom: Luca.parentClasses( component )\n  }\n\nLuca.util.launchers.developmentConsole = (name=\"luca-development-console\")->\n  @_lucaDevConsole = Luca name, ()=>\n    @$el.append Luca.View::make(\"div\", id: \"#{ name }-wrapper\", class: \"modal fade large\")\n\n    dconsole = new Luca.tools.DevelopmentConsole\n      name: name\n      container: \"##{ name }-wrapper\"\n\n    dconsole.render()\n    dconsole.getCodeMirror().setHeight(602)\n\n  @_lucaDevConsole.show()\n  Luca(name)\n"},{"source":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/managers/socket_manager.coffee","defined_in_file":"/Users/jonathan/Projects/luca/app/assets/javascripts/luca/managers/socket_manager.coffee","type":"component_definition","class_name":"Luca.SocketManager","header_documentation":"<p>The SocketManager provides communication between a Websocket / Pubsub\nsystem and routes messages through the application to instances\nof a specific view, model, collection, or other Backbone.Events object. \nYou will need to create the socket manager specifying your provider and host:\n      @socket = new Luca.SocketManager(host:&quot;//localhost:9292/faye&quot;)</p>\n","type_alias":"socket_manager","css_class_identifier":"","defines_methods":{"initialize":{"defined_on_line":24,"documentation":"","arguments":[{"argument":"@attributes","value":"{}"}]},"isReady":{"defined_on_line":50,"documentation":"<p>The socket manager is ready once &#39;ready&#39; event has been\ntriggered on it.  ( usually by the application ). and once\nthe provider client library as been loaded.</p>\n","arguments":[]},"providerLibraryIsAvailable":{"defined_on_line":53,"documentation":"","arguments":[]},"connect":{"defined_on_line":62,"documentation":"","arguments":[]},"providerSourceLoaded":{"defined_on_line":70,"documentation":"","arguments":[]},"providerSourceUrl":{"defined_on_line":73,"documentation":"","arguments":[]},"loadProviderSource":{"defined_on_line":78,"documentation":"","arguments":[]}},"defines_properties":{},"source_file_contents":"# The SocketManager provides communication between a Websocket / Pubsub\n# system and routes messages through the application to instances\n# of a specific view, model, collection, or other Backbone.Events object. \n#\n# You will need to create the socket manager specifying your provider and host:\n#       @socket = new Luca.SocketManager(host:\"//localhost:9292/faye\")\n#\nsocketManager = Luca.register \"Luca.SocketManager\"\nsocketManager.extends         \"Luca.Model\"\n\nsocketManager.defines\n  # The SocketManager can be configured with the following options:\n  #\n  # autoStart: default(true) immediately begins to load the provider\n  # script, setup the connection, etc\n  #\n  # provider: faye.js or socket.io\n  defaults:\n    autoStart: true  \n    providerAvailable: false\n    ready: false\n    provider: \"faye.js\"\n\n  initialize: (@attributes={})->\n    unless @providerLibraryIsAvailable()\n      @loadProviderSource() \n\n    Luca.Model::initialize?.apply(@, arguments)\n\n    model = @\n\n    connectOnReady = ()=> \n      @connect() if @isReady()\n\n    model.on \"change:ready\", ()->\n      connectOnReady()\n      model.unbind(\"change:ready\", @)\n\n    model.on \"change:providerAvailable\", ()->\n      connectOnReady()\n      model.unbind(\"change:ready\", @)\n\n    @on \"ready\", _.once ()=> @set('ready', true)\n\n    @trigger \"change\"\n\n  # The socket manager is ready once 'ready' event has been\n  # triggered on it.  ( usually by the application ). and once\n  # the provider client library as been loaded.\n  isReady: ()->\n    @get(\"ready\") is true and @get(\"providerAvailable\") is true\n\n  providerLibraryIsAvailable: ()->\n    providerTest = switch @get('provider')\n      when \"socket.io\"\n        \"io\"\n      when \"faye.js\"\n        \"Faye.Client\"\n\n    !!(Luca.util.resolve(providerTest)?)\n\n  connect: ()->\n    switch @get('provider')\n      when \"socket.io\"\n        @client = io.connect( @get('host') )\n      when \"faye.js\"\n        @client = new Faye.Client(@get('host'))\n        @set(\"client\", @client)\n\n  providerSourceLoaded: ()-> \n    @set \"providerAvailable\", true\n\n  providerSourceUrl: ()->\n    switch @get('provider')\n      when \"socket.io\" then \"#{  @get('host')  }/socket.io/socket.io.js\"\n      when \"faye.js\" then \"#{  @get('host')  }/faye.js\"\n\n  loadProviderSource: ()->\n    script = document.createElement 'script'\n    script.setAttribute \"type\", \"text/javascript\"\n    script.setAttribute \"src\", @providerSourceUrl()\n    script.onload = _.bind(@providerSourceLoaded,@)\n\n    if Luca.util.isIE()\n      script.onreadystatechange = ()=>\n        if script.readyState is \"loaded\"\n          @providerSourceLoaded()\n\n    document.getElementsByTagName('head')[0].appendChild script\n"}];
